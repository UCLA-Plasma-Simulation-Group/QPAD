var tipuesearch = {"pages":[{"title":" QuickPIC wit Azimuzal Decomposition ","text":"QuickPIC wit Azimuzal Decomposition QuickPIC is a 3D parallel (MPI & OpenMP Hybrid) Quasi-Static PIC code, which is developed based on the framework UPIC. This is the UCLA Plasma Simulation Group's official open-source repository for QuickPIC. Developer Info Fei Li and Weiming An","tags":"home","loc":"index.html"},{"title":"input_class.f03 – QuickPIC wit Azimuzal Decomposition","text":"This file depends on sourcefile~~input_class.f03~~EfferentGraph sourcefile~input_class.f03 input_class.f03 sourcefile~system.f03 system.f03 sourcefile~input_class.f03->sourcefile~system.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~input_class.f03->sourcefile~parallel_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~input_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~grid_class.f03 grid_class.f03 sourcefile~input_class.f03->sourcefile~grid_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~grid_class.f03->sourcefile~system.f03 sourcefile~grid_class.f03->sourcefile~parallel_pipe_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~input_class.f03~~AfferentGraph sourcefile~input_class.f03 input_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~input_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules input_class Source Code input_class.f03 Source Code module input_class use parallel_class use parallel_pipe_class use grid_class use mpi use json_module use system implicit none private public :: input_json type input_json class ( parallel ), pointer :: p => null () class ( parallel_pipe ), pointer :: pp => null () class ( grid ), pointer :: gp => null () type ( json_file ), private , pointer :: input => null () contains generic :: new => read_input_json generic :: get => json_file_get_object , json_file_get_integer ,& & json_file_get_double , json_file_get_logical ,& & json_file_get_string , json_file_get_integer_vec ,& & json_file_get_double_vec , json_file_get_logical_vec ,& & json_file_get_string_vec , json_file_get_alloc_string_vec ,& & json_file_get_root generic :: info => json_file_variable_info procedure :: found procedure , private :: read_input_json procedure , private :: initialize , set_json_core_in_file procedure , private :: load_file , print_to_string procedure , private :: load_from_string procedure , private :: json_file_get_object , json_file_get_integer ,& & json_file_get_double , json_file_get_logical ,& & json_file_get_string , json_file_get_integer_vec ,& & json_file_get_double_vec , json_file_get_logical_vec ,& & json_file_get_string_vec , json_file_get_alloc_string_vec ,& & json_file_get_root procedure , private :: json_file_variable_info end type character ( len = 10 ), save :: cls_name = 'input' integer , parameter :: cls_level = 1 type ( grid ), save , target :: gp type ( parallel ), save , target :: p type ( parallel_pipe ), save , target :: pp contains ! subroutine read_input_json ( this ) implicit none class ( input_json ), intent ( inout ) :: this ! local data character ( len = 18 ), save :: sname = 'read_input_json' logical :: found , stat character ( len = :), allocatable :: ff , boundary , error_msg integer :: length , num_stages , verbose , nr , nz , psolve , ierr call p % new () this % p => p call write_dbg ( cls_name , sname , cls_level , 'starts' ) call this % initialize ( comment_char = '!' ) if ( p % getidproc () == 0 ) then inquire ( FILE = './qpinput.json' , EXIST = found ) if ( found ) then ! read the file call this % load_file ( filename = './qpinput.json' ) call this % input % check_for_errors ( stat , error_msg ) if (. not . stat ) then call write_err ( error_msg ) end if else call write_err ( 'cannot find the input file' ) end if call this % print_to_string ( ff ) length = len ( ff ) end if call MPI_BCAST ( length , 1 , this % p % getmint (), 0 , this % p % getlworld (), ierr ) if (. not . allocated ( ff )) allocate ( character ( len = length ) :: ff ) call MPI_BCAST ( ff , length , this % p % getmchar (), 0 , this % p % getlworld (), ierr ) call this % load_from_string ( ff ) call this % get ( 'simulation.nodes(2)' , num_stages ) call pp % new ( nst = num_stages ) this % pp => pp call this % get ( 'simulation.nr' , nr ) call this % get ( 'simulation.nz' , nz ) ! call this%get('simulation.boundary',boundary) ! select case (trim(boundary)) ! case (\"conducting\") !    psolve = 1 ! case default !    psolve = 1 ! end select call gp % new ( pp , nr , nz ) this % gp => gp ! call this%get('simulation.verbose',verbose) ! call err%setmonitor(verbose) call write_dbg ( cls_name , sname , cls_level , ff ) call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine read_input_json ! subroutine initialize ( this , verbose , compact_reals , print_signs ,& & real_format , spaces_per_tab , strict_type_checking , trailing_spaces_significant ,& & case_sensitive_keys , no_whitespace , unescape_strings , comment_char , path_mode ,& & path_separator , compress_vectors , allow_duplicate_keys ) implicit none class ( input_json ), intent ( inout ) :: this logical , intent ( in ), optional :: verbose logical , intent ( in ), optional :: compact_reals logical , intent ( in ), optional :: print_signs character ( len =* ), intent ( in ), optional :: real_format integer , intent ( in ), optional :: spaces_per_tab logical , intent ( in ), optional :: strict_type_checking logical , intent ( in ), optional :: trailing_spaces_significant logical , intent ( in ), optional :: case_sensitive_keys logical , intent ( in ), optional :: no_whitespace logical , intent ( in ), optional :: unescape_strings character ( len = 1 ), intent ( in ), optional :: comment_char integer , intent ( in ), optional :: path_mode character ( len = 1 ), intent ( in ), optional :: path_separator logical , intent ( in ), optional :: compress_vectors logical , intent ( in ), optional :: allow_duplicate_keys ! local data character ( len = 38 ), save :: sname = 'initialize_json_core_in_file' call write_dbg ( cls_name , sname , cls_level , 'starts' ) allocate ( this % input ) call this % input % initialize ( verbose , compact_reals , print_signs ,& & real_format , spaces_per_tab , strict_type_checking , trailing_spaces_significant ,& & case_sensitive_keys , no_whitespace , unescape_strings , comment_char , path_mode ,& & path_separator , compress_vectors , allow_duplicate_keys ) call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine initialize ! subroutine set_json_core_in_file ( this , core ) implicit none class ( input_json ), intent ( inout ) :: this type ( json_core ), intent ( in ) :: core ! local data character ( len = 38 ), save :: sname = 'set_json_core_in_file' call write_dbg ( cls_name , sname , cls_level , 'starts' ) call this % input % initialize ( core ) call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine set_json_core_in_file ! subroutine load_file ( this , filename , unit ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: filename integer , intent ( in ), optional :: unit ! local data character ( len = 18 ), save :: sname = 'json_file_load' call write_dbg ( cls_name , sname , cls_level , 'starts' ) call this % input % load_file ( filename , unit ) call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine load_file ! subroutine print_to_string ( this , str ) implicit none class ( input_json ), intent ( inout ) :: this character ( len = :), allocatable , intent ( out ) :: str ! local data character ( len = 38 ), save :: sname = 'json_file_print_to_string' call write_dbg ( cls_name , sname , cls_level , 'starts' ) call this % input % print_to_string ( str ) call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine print_to_string ! subroutine load_from_string ( this , str ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: str ! local data character ( len = 38 ), save :: sname = 'json_file_load_from_string' call write_dbg ( cls_name , sname , cls_level , 'starts' ) call this % input % load_from_string ( str ) call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine load_from_string ! function found ( this , path ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: path logical :: found ! local data character ( len = 38 ), save :: sname = 'json_file_found' call write_dbg ( cls_name , sname , cls_level , 'starts' ) call this % input % info ( path , found = found ) call write_dbg ( cls_name , sname , cls_level , 'ends' ) end function found ! subroutine json_file_get_object ( this , path , p ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: path type ( json_value ), pointer , intent ( out ) :: p ! local data character ( len = 38 ), save :: sname = 'json_file_get_object' character ( len = :), allocatable :: error logical :: st call write_dbg ( cls_name , sname , cls_level , 'starts' ) call this % input % get ( path , p ) if ( this % input % failed ()) then call this % input % check_for_errors ( st , error ) call this % input % clear_exceptions () call write_err ( error ) end if call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine json_file_get_object ! subroutine json_file_get_integer ( this , path , val ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: path integer , intent ( out ) :: val ! local data character ( len = 38 ), save :: sname = 'json_file_get_integer' character ( len = :), allocatable :: error logical :: st call write_dbg ( cls_name , sname , cls_level , 'starts' ) call this % input % get ( path , val ) if ( this % input % failed ()) then call this % input % check_for_errors ( st , error ) call this % input % clear_exceptions () call write_err ( error ) end if call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine json_file_get_integer ! subroutine json_file_get_double ( this , path , val ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: path real , intent ( out ) :: val ! local data character ( len = 38 ), save :: sname = 'json_file_get_double' character ( len = :), allocatable :: error logical :: st call write_dbg ( cls_name , sname , cls_level , 'starts' ) call this % input % get ( path , val ) if ( this % input % failed ()) then call this % input % check_for_errors ( st , error ) call this % input % clear_exceptions () call write_err ( error ) end if call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine json_file_get_double ! subroutine json_file_get_logical ( this , path , val ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: path logical , intent ( out ) :: val ! local data character ( len = 38 ), save :: sname = 'json_file_get_logical' character ( len = :), allocatable :: error logical :: st call write_dbg ( cls_name , sname , cls_level , 'starts' ) call this % input % get ( path , val ) if ( this % input % failed ()) then call this % input % check_for_errors ( st , error ) call this % input % clear_exceptions () call write_err ( error ) end if call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine json_file_get_logical ! subroutine json_file_get_string ( this , path , val ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: path character ( len = :), allocatable , intent ( out ) :: val ! local data character ( len = 38 ), save :: sname = 'json_file_get_string' character ( len = :), allocatable :: error logical :: st call write_dbg ( cls_name , sname , cls_level , 'starts' ) call this % input % get ( path , val ) if ( this % input % failed ()) then call this % input % check_for_errors ( st , error ) call this % input % clear_exceptions () call write_err ( error ) end if call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine json_file_get_string ! subroutine json_file_get_integer_vec ( this , path , vec ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: path integer , dimension (:), allocatable , intent ( out ) :: vec ! local data character ( len = 38 ), save :: sname = 'json_file_get_integer_vec' character ( len = :), allocatable :: error logical :: st call write_dbg ( cls_name , sname , cls_level , 'starts' ) call this % input % get ( path , vec ) if ( this % input % failed ()) then call this % input % check_for_errors ( st , error ) call this % input % clear_exceptions () call write_err ( error ) end if call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine json_file_get_integer_vec ! subroutine json_file_get_double_vec ( this , path , vec ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: path real , dimension (:), allocatable , intent ( out ) :: vec ! local data character ( len = 38 ), save :: sname = 'json_file_get_double_vec' character ( len = :), allocatable :: error logical :: st call write_dbg ( cls_name , sname , cls_level , 'starts' ) call this % input % get ( path , vec ) if ( this % input % failed ()) then call this % input % check_for_errors ( st , error ) call this % input % clear_exceptions () call write_err ( error ) end if call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine json_file_get_double_vec ! subroutine json_file_get_logical_vec ( this , path , vec ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: path logical , dimension (:), allocatable , intent ( out ) :: vec ! local data character ( len = 38 ), save :: sname = 'json_file_get_logical_vec' character ( len = :), allocatable :: error logical :: st call write_dbg ( cls_name , sname , cls_level , 'starts' ) call this % input % get ( path , vec ) if ( this % input % failed ()) then call this % input % check_for_errors ( st , error ) call this % input % clear_exceptions () call write_err ( error ) end if call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine json_file_get_logical_vec ! subroutine json_file_get_string_vec ( this , path , vec ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: path character ( len =* ), dimension (:), allocatable , intent ( out ) :: vec ! local data character ( len = 38 ), save :: sname = 'json_file_get_string_vec' character ( len = :), allocatable :: error logical :: st call write_dbg ( cls_name , sname , cls_level , 'starts' ) call this % input % get ( path , vec ) if ( this % input % failed ()) then call this % input % check_for_errors ( st , error ) call this % input % clear_exceptions () call write_err ( error ) end if call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine json_file_get_string_vec ! subroutine json_file_get_alloc_string_vec ( this , path , vec , ilen ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: path character ( len = :), dimension (:), allocatable , intent ( out ) :: vec integer , dimension (:), allocatable , intent ( out ) :: ilen ! local data character ( len = 38 ), save :: sname = 'json_file_get_alloc_string_vec' character ( len = :), allocatable :: error logical :: st call write_dbg ( cls_name , sname , cls_level , 'starts' ) call this % input % get ( path , vec , ilen ) if ( this % input % failed ()) then call this % input % check_for_errors ( st , error ) call this % input % clear_exceptions () call write_err ( error ) end if call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine json_file_get_alloc_string_vec ! subroutine json_file_get_root ( this , p ) implicit none class ( input_json ), intent ( inout ) :: this type ( json_value ), pointer , intent ( out ) :: p ! local data character ( len = 38 ), save :: sname = 'json_file_get_root' call write_dbg ( cls_name , sname , cls_level , 'starts' ) call this % input % get ( p ) call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine json_file_get_root ! subroutine json_file_variable_info ( this , path , n_children ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: path integer , intent ( out ) :: n_children ! local data character ( len = 38 ), save :: sname = 'json_file_variable_info' character ( len = :), allocatable :: error logical :: st integer :: var_type character ( len = :), allocatable :: name call write_dbg ( cls_name , sname , cls_level , 'starts' ) call this % input % info ( path , var_type = var_type , n_children = n_children , name = name ) if ( this % input % failed ()) then call this % input % check_for_errors ( st , error ) call this % input % clear_exceptions () call write_err ( error ) end if call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine json_file_variable_info ! end module input_class","tags":"","loc":"sourcefile/input_class.f03.html"},{"title":"grid_class.f03 – QuickPIC wit Azimuzal Decomposition","text":"This file depends on sourcefile~~grid_class.f03~~EfferentGraph sourcefile~grid_class.f03 grid_class.f03 sourcefile~system.f03 system.f03 sourcefile~grid_class.f03->sourcefile~system.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~grid_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~grid_class.f03~~AfferentGraph sourcefile~grid_class.f03 grid_class.f03 sourcefile~field_e_class.f03 field_e_class.f03 sourcefile~field_e_class.f03->sourcefile~grid_class.f03 sourcefile~field_src_class.f03 field_src_class.f03 sourcefile~field_e_class.f03->sourcefile~field_src_class.f03 sourcefile~ufield_class.f03 ufield_class.f03 sourcefile~field_e_class.f03->sourcefile~ufield_class.f03 sourcefile~field_b_class.f03 field_b_class.f03 sourcefile~field_e_class.f03->sourcefile~field_b_class.f03 sourcefile~field_class.f03 field_class.f03 sourcefile~field_e_class.f03->sourcefile~field_class.f03 sourcefile~field_psi_class.f03 field_psi_class.f03 sourcefile~field_e_class.f03->sourcefile~field_psi_class.f03 sourcefile~field_src_class.f03->sourcefile~grid_class.f03 sourcefile~field_src_class.f03->sourcefile~field_class.f03 sourcefile~ufield_class.f03->sourcefile~grid_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~grid_class.f03 sourcefile~simulation_class.f03->sourcefile~field_e_class.f03 sourcefile~simulation_class.f03->sourcefile~field_src_class.f03 sourcefile~input_class.f03 input_class.f03 sourcefile~simulation_class.f03->sourcefile~input_class.f03 sourcefile~simulation_class.f03->sourcefile~field_b_class.f03 sourcefile~simulation_class.f03->sourcefile~field_psi_class.f03 sourcefile~input_class.f03->sourcefile~grid_class.f03 sourcefile~field_b_class.f03->sourcefile~grid_class.f03 sourcefile~field_b_class.f03->sourcefile~field_src_class.f03 sourcefile~field_b_class.f03->sourcefile~ufield_class.f03 sourcefile~field_b_class.f03->sourcefile~field_class.f03 sourcefile~field_class.f03->sourcefile~grid_class.f03 sourcefile~field_class.f03->sourcefile~ufield_class.f03 sourcefile~field_psi_class.f03->sourcefile~grid_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_src_class.f03 sourcefile~field_psi_class.f03->sourcefile~ufield_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_class.f03 sourcefile~test_field_bperp.f03 TEST_field_bperp.f03 sourcefile~test_field_bperp.f03->sourcefile~field_src_class.f03 sourcefile~test_field_bperp.f03->sourcefile~ufield_class.f03 sourcefile~test_field_bperp.f03->sourcefile~field_b_class.f03 sourcefile~test_field_bperp.f03->sourcefile~field_class.f03 sourcefile~test_field_ez.f03 TEST_field_ez.f03 sourcefile~test_field_ez.f03->sourcefile~field_e_class.f03 sourcefile~test_field_ez.f03->sourcefile~field_src_class.f03 sourcefile~test_field_ez.f03->sourcefile~ufield_class.f03 sourcefile~test_field_ez.f03->sourcefile~field_class.f03 sourcefile~test_field_bz.f03 TEST_field_bz.f03 sourcefile~test_field_bz.f03->sourcefile~field_src_class.f03 sourcefile~test_field_bz.f03->sourcefile~ufield_class.f03 sourcefile~test_field_bz.f03->sourcefile~field_b_class.f03 sourcefile~test_field_bz.f03->sourcefile~field_class.f03 sourcefile~test_ufield.f03 TEST_ufield.f03 sourcefile~test_ufield.f03->sourcefile~ufield_class.f03 sourcefile~test_field_eperp.f03 TEST_field_eperp.f03 sourcefile~test_field_eperp.f03->sourcefile~field_e_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_src_class.f03 sourcefile~test_field_eperp.f03->sourcefile~ufield_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_b_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_bperp_iter.f03 TEST_field_bperp_iter.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_src_class.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~ufield_class.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_b_class.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_class.f03 sourcefile~test_field_psi.f03 TEST_field_psi.f03 sourcefile~test_field_psi.f03->sourcefile~field_src_class.f03 sourcefile~test_field_psi.f03->sourcefile~ufield_class.f03 sourcefile~test_field_psi.f03->sourcefile~field_class.f03 sourcefile~test_field_psi.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_eperp_beam.f03 TEST_field_eperp_beam.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_e_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_src_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~ufield_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_b_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_class.f03 var pansourcefilegrid_classf03AfferentGraph = svgPanZoom('#sourcefilegrid_classf03AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules grid_class Source Code grid_class.f03 Source Code module grid_class use parallel_pipe_class use system implicit none private character ( len = 18 ), save :: cls_name = 'grid' integer , parameter :: cls_level = 0 public :: grid type :: grid private integer , dimension ( 2 ) :: nd ! number of global grid points integer , dimension ( 2 ) :: ndp ! number of local grid points integer , dimension ( 2 ) :: nvp ! number of processors integer , dimension ( 2 ) :: noff ! grid index offset contains generic :: new => init_grid generic :: del => end_grid generic :: get_noff => get_noff_all , get_noff_dim generic :: get_nd => get_nd_all , get_nd_dim generic :: get_ndp => get_ndp_all , get_ndp_dim generic :: get_nvp => get_nvp_all , get_nvp_dim procedure , private :: init_grid , end_grid procedure , private :: get_noff_all , get_noff_dim procedure , private :: get_nd_all , get_nd_dim procedure , private :: get_ndp_all , get_ndp_dim procedure , private :: get_nvp_all , get_nvp_dim end type grid contains subroutine init_grid ( this , pp , nr , nz ) implicit none class ( grid ), intent ( inout ) :: this class ( parallel_pipe ), intent ( in ) :: pp integer , intent ( in ) :: nr , nz integer :: lidproc , stageid , local_size , extra character ( len = 18 ), save :: sname = 'init_grid' call write_dbg ( cls_name , sname , cls_level , 'starts' ) this % nd ( 1 ) = nr this % nd ( 2 ) = nz this % nvp ( 1 ) = pp % getlnvp () this % nvp ( 2 ) = pp % getnstage () lidproc = pp % getlidproc () stageid = pp % getstageid () ! the un-evenly distributed grid points among processors are accounted for local_size = nr / this % nvp ( 1 ) extra = nr - local_size * this % nvp ( 1 ) this % noff ( 1 ) = local_size * lidproc + min ( lidproc , extra ) this % ndp ( 1 ) = local_size + merge ( 1 , 0 , lidproc < extra ) local_size = nz / this % nvp ( 2 ) extra = nz - local_size * this % nvp ( 2 ) this % noff ( 2 ) = local_size * stageid + min ( stageid , extra ) this % ndp ( 2 ) = local_size + merge ( 1 , 0 , stageid < extra ) call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine init_grid subroutine end_grid ( this ) implicit none class ( grid ), intent ( inout ) :: this character ( len = 18 ), save :: sname = 'init_grid' call write_dbg ( cls_name , sname , cls_level , 'starts' ) ! this routine is only a place-holder now, do nothing. call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine end_grid function get_nd_all ( this ) implicit none class ( grid ), intent ( in ) :: this integer , dimension ( 2 ) :: get_nd_all get_nd_all = this % nd end function get_nd_all function get_nd_dim ( this , dim ) implicit none class ( grid ), intent ( in ) :: this integer , intent ( in ) :: dim integer :: get_nd_dim get_nd_dim = this % nd ( dim ) end function get_nd_dim function get_ndp_all ( this ) implicit none class ( grid ), intent ( in ) :: this integer , dimension ( 2 ) :: get_ndp_all get_ndp_all = this % ndp end function get_ndp_all function get_ndp_dim ( this , dim ) implicit none class ( grid ), intent ( in ) :: this integer , intent ( in ) :: dim integer :: get_ndp_dim get_ndp_dim = this % ndp ( dim ) end function get_ndp_dim function get_nvp_all ( this ) implicit none class ( grid ), intent ( in ) :: this integer , dimension ( 2 ) :: get_nvp_all get_nvp_all = this % nvp end function get_nvp_all function get_nvp_dim ( this , dim ) implicit none class ( grid ), intent ( in ) :: this integer , intent ( in ) :: dim integer :: get_nvp_dim get_nvp_dim = this % nvp ( dim ) end function get_nvp_dim function get_noff_all ( this ) implicit none class ( grid ), intent ( in ) :: this integer , dimension ( 2 ) :: get_noff_all get_noff_all = this % noff end function get_noff_all function get_noff_dim ( this , dim ) implicit none class ( grid ), intent ( in ) :: this integer , intent ( in ) :: dim integer :: get_noff_dim get_noff_dim = this % noff ( dim ) end function get_noff_dim end module grid_class","tags":"","loc":"sourcefile/grid_class.f03.html"},{"title":"main.f03 – QuickPIC wit Azimuzal Decomposition","text":"Contents Programs quickpic Source Code main.f03 Source Code program quickpic implicit none ! Placeholder now end program quickpic","tags":"","loc":"sourcefile/main.f03.html"},{"title":"field_psi_class.f03 – QuickPIC wit Azimuzal Decomposition","text":"This file depends on sourcefile~~field_psi_class.f03~~EfferentGraph sourcefile~field_psi_class.f03 field_psi_class.f03 sourcefile~field_solver_class.f03 field_solver_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_solver_class.f03 sourcefile~param.f03 param.f03 sourcefile~field_psi_class.f03->sourcefile~param.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~field_psi_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~system.f03 system.f03 sourcefile~field_psi_class.f03->sourcefile~system.f03 sourcefile~grid_class.f03 grid_class.f03 sourcefile~field_psi_class.f03->sourcefile~grid_class.f03 sourcefile~field_src_class.f03 field_src_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_src_class.f03 sourcefile~ufield_class.f03 ufield_class.f03 sourcefile~field_psi_class.f03->sourcefile~ufield_class.f03 sourcefile~field_class.f03 field_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_class.f03 sourcefile~field_solver_class.f03->sourcefile~param.f03 sourcefile~field_solver_class.f03->sourcefile~system.f03 sourcefile~debug_tool.f03 debug_tool.f03 sourcefile~field_solver_class.f03->sourcefile~debug_tool.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~grid_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~grid_class.f03->sourcefile~system.f03 sourcefile~field_src_class.f03->sourcefile~param.f03 sourcefile~field_src_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_src_class.f03->sourcefile~system.f03 sourcefile~field_src_class.f03->sourcefile~grid_class.f03 sourcefile~field_src_class.f03->sourcefile~field_class.f03 sourcefile~ufield_class.f03->sourcefile~param.f03 sourcefile~ufield_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield_class.f03->sourcefile~system.f03 sourcefile~ufield_class.f03->sourcefile~grid_class.f03 sourcefile~field_class.f03->sourcefile~param.f03 sourcefile~field_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_class.f03->sourcefile~system.f03 sourcefile~field_class.f03->sourcefile~grid_class.f03 sourcefile~field_class.f03->sourcefile~ufield_class.f03 var pansourcefilefield_psi_classf03EfferentGraph = svgPanZoom('#sourcefilefield_psi_classf03EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~field_psi_class.f03~~AfferentGraph sourcefile~field_psi_class.f03 field_psi_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~field_psi_class.f03 sourcefile~field_e_class.f03 field_e_class.f03 sourcefile~simulation_class.f03->sourcefile~field_e_class.f03 sourcefile~field_e_class.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_psi.f03 TEST_field_psi.f03 sourcefile~test_field_psi.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_eperp.f03 TEST_field_eperp.f03 sourcefile~test_field_eperp.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_e_class.f03 sourcefile~test_field_ez.f03 TEST_field_ez.f03 sourcefile~test_field_ez.f03->sourcefile~field_e_class.f03 sourcefile~test_field_eperp_beam.f03 TEST_field_eperp_beam.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_e_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules field_psi_class Source Code field_psi_class.f03 Source Code module field_psi_class use parallel_pipe_class use grid_class use field_class use field_solver_class use field_src_class use ufield_class use param use system implicit none private character ( len = 20 ), parameter :: cls_name = \"field_psi\" integer , parameter :: cls_level = 1 public :: field_psi type , extends ( field ) :: field_psi ! private class ( field_solver ), dimension (:), pointer :: solver => null () real , dimension (:), pointer :: buf_re => null (), buf_im => null () ! buffer for source term contains generic :: new => init_field_psi procedure :: del => end_field_psi ! generic :: read_input => read_input_field_psi generic :: solve => solve_field_psi procedure , private :: init_field_psi procedure , private :: end_field_psi procedure , private :: set_source procedure , private :: get_solution procedure , private :: solve_field_psi end type field_psi contains subroutine init_field_psi ( this , pp , gp , dr , dxi , num_modes , part_shape ) implicit none class ( field_psi ), intent ( inout ) :: this class ( parallel_pipe ), intent ( in ), pointer :: pp class ( grid ), intent ( in ), pointer :: gp integer , intent ( in ) :: num_modes , part_shape real , intent ( in ) :: dr , dxi integer , dimension ( 2 , 2 ) :: gc_num integer :: dim , i , solver_type , kind , entity integer , dimension ( 2 ) :: ndp , noff , nd real :: tol character ( len = 20 ), save :: sname = \"init_field_psi\" call write_dbg ( cls_name , sname , cls_level , 'starts' ) nd = gp % get_nd () ndp = gp % get_ndp () noff = gp % get_noff () solver_type = p_hypre_cycred kind = p_fk_psi entity = p_entity_plasma tol = 1.0d-6 select case ( part_shape ) case ( p_ps_linear ) gc_num (:, 1 ) = ( / 0 , 1 / ) gc_num (:, 2 ) = ( / 0 , 1 / ) case ( p_ps_quadratic ) call write_err ( \"Quadratic particle shape not implemented.\" ) case default call write_err ( \"Invalid particle shape.\" ) end select dim = 1 ! call initialization routine of the parent class call this % field % new ( pp , gp , dim , dr , dxi , num_modes , gc_num ) ! initialize solver allocate ( this % solver ( 0 : num_modes ) ) do i = 0 , num_modes call this % solver ( i )% new ( nd , ndp , noff , kind , i , dr , solver_type , tol ) enddo call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine init_field_psi subroutine end_field_psi ( this ) implicit none class ( field_psi ), intent ( inout ) :: this integer :: i character ( len = 20 ), save :: sname = 'end_field_psi' call write_dbg ( cls_name , sname , cls_level , 'starts' ) do i = 0 , this % num_modes call this % solver ( i )% del () enddo deallocate ( this % solver ) if ( associated ( this % buf_re ) ) deallocate ( this % buf_re ) if ( associated ( this % buf_im ) ) deallocate ( this % buf_im ) call this % field % del () call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine end_field_psi subroutine set_source ( this , mode , q_re , q_im ) implicit none class ( field_psi ), intent ( inout ) :: this class ( ufield ), intent ( in ) :: q_re class ( ufield ), intent ( in ), optional :: q_im integer , intent ( in ) :: mode integer :: i , nd1p real , dimension (:,:), pointer :: f1_re => null (), f1_im => null () character ( len = 20 ), save :: sname = 'set_source' call write_dbg ( cls_name , sname , cls_level , 'starts' ) nd1p = q_re % get_ndp ( 1 ) f1_re => q_re % get_f1 () if ( . not . associated ( this % buf_re ) ) then allocate ( this % buf_re ( nd1p ) ) elseif ( size ( this % buf_re ) < nd1p ) then deallocate ( this % buf_re ) allocate ( this % buf_re ( nd1p ) ) endif if ( present ( q_im ) ) then f1_im => q_im % get_f1 () if ( . not . associated ( this % buf_im ) ) then allocate ( this % buf_im ( nd1p ) ) elseif ( size ( this % buf_im ) < nd1p ) then deallocate ( this % buf_im ) allocate ( this % buf_im ( nd1p ) ) endif endif if ( mode == 0 ) then do i = 1 , nd1p this % buf_re ( i ) = f1_re ( 1 , i ) enddo elseif ( mode > 0 . and . present ( q_im ) ) then do i = 1 , nd1p this % buf_re ( i ) = f1_re ( 1 , i ) this % buf_im ( i ) = f1_im ( 1 , i ) enddo else call write_err ( 'Invalid input arguments!' ) endif call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine set_source subroutine get_solution ( this , mode ) implicit none class ( field_psi ), intent ( inout ) :: this integer , intent ( in ) :: mode integer :: i , nd1p real , dimension (:,:), pointer :: f1_re => null (), f1_im => null () character ( len = 20 ), save :: sname = 'get_solution' call write_dbg ( cls_name , sname , cls_level , 'starts' ) nd1p = this % rf_re ( mode )% get_ndp ( 1 ) f1_re => this % rf_re ( mode )% get_f1 () do i = 1 , nd1p f1_re ( 1 , i ) = this % buf_re ( i ) enddo if ( mode > 0 ) then f1_im => this % rf_im ( mode )% get_f1 () do i = 1 , nd1p f1_im ( 1 , i ) = this % buf_im ( i ) enddo endif call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine get_solution subroutine solve_field_psi ( this , q ) implicit none class ( field_psi ), intent ( inout ) :: this class ( field_rho ), intent ( in ) :: q type ( ufield ), dimension (:), pointer :: q_re => null (), q_im => null () integer :: i character ( len = 20 ), save :: sname = 'solve_field_psi' call write_dbg ( cls_name , sname , cls_level , 'starts' ) q_re => q % get_rf_re () q_im => q % get_rf_im () do i = 0 , this % num_modes if ( i == 0 ) then call this % set_source ( i , q_re ( i ) ) call this % solver ( i )% solve ( this % buf_re ) call this % get_solution ( i ) cycle endif call this % set_source ( i , q_re ( i ), q_im ( i ) ) call this % solver ( i )% solve ( this % buf_re ) call this % solver ( i )% solve ( this % buf_im ) call this % get_solution ( i ) enddo call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine solve_field_psi end module field_psi_class","tags":"","loc":"sourcefile/field_psi_class.f03.html"},{"title":"simulation_class.f03 – QuickPIC wit Azimuzal Decomposition","text":"This file depends on sourcefile~~simulation_class.f03~~EfferentGraph sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~field_e_class.f03 field_e_class.f03 sourcefile~simulation_class.f03->sourcefile~field_e_class.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~simulation_class.f03->sourcefile~parallel_class.f03 sourcefile~param.f03 param.f03 sourcefile~simulation_class.f03->sourcefile~param.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~simulation_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~system.f03 system.f03 sourcefile~simulation_class.f03->sourcefile~system.f03 sourcefile~grid_class.f03 grid_class.f03 sourcefile~simulation_class.f03->sourcefile~grid_class.f03 sourcefile~field_src_class.f03 field_src_class.f03 sourcefile~simulation_class.f03->sourcefile~field_src_class.f03 sourcefile~field_b_class.f03 field_b_class.f03 sourcefile~simulation_class.f03->sourcefile~field_b_class.f03 sourcefile~input_class.f03 input_class.f03 sourcefile~simulation_class.f03->sourcefile~input_class.f03 sourcefile~field_psi_class.f03 field_psi_class.f03 sourcefile~simulation_class.f03->sourcefile~field_psi_class.f03 sourcefile~field_e_class.f03->sourcefile~param.f03 sourcefile~field_e_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_e_class.f03->sourcefile~system.f03 sourcefile~field_e_class.f03->sourcefile~grid_class.f03 sourcefile~field_e_class.f03->sourcefile~field_src_class.f03 sourcefile~field_e_class.f03->sourcefile~field_b_class.f03 sourcefile~field_e_class.f03->sourcefile~field_psi_class.f03 sourcefile~field_solver_class.f03 field_solver_class.f03 sourcefile~field_e_class.f03->sourcefile~field_solver_class.f03 sourcefile~ufield_class.f03 ufield_class.f03 sourcefile~field_e_class.f03->sourcefile~ufield_class.f03 sourcefile~field_class.f03 field_class.f03 sourcefile~field_e_class.f03->sourcefile~field_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~grid_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~grid_class.f03->sourcefile~system.f03 sourcefile~field_src_class.f03->sourcefile~param.f03 sourcefile~field_src_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_src_class.f03->sourcefile~system.f03 sourcefile~field_src_class.f03->sourcefile~grid_class.f03 sourcefile~field_src_class.f03->sourcefile~field_class.f03 sourcefile~field_b_class.f03->sourcefile~param.f03 sourcefile~field_b_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_b_class.f03->sourcefile~system.f03 sourcefile~field_b_class.f03->sourcefile~grid_class.f03 sourcefile~field_b_class.f03->sourcefile~field_src_class.f03 sourcefile~field_b_class.f03->sourcefile~field_solver_class.f03 sourcefile~field_b_class.f03->sourcefile~ufield_class.f03 sourcefile~field_b_class.f03->sourcefile~field_class.f03 sourcefile~debug_tool.f03 debug_tool.f03 sourcefile~field_b_class.f03->sourcefile~debug_tool.f03 sourcefile~input_class.f03->sourcefile~parallel_class.f03 sourcefile~input_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~input_class.f03->sourcefile~system.f03 sourcefile~input_class.f03->sourcefile~grid_class.f03 sourcefile~field_psi_class.f03->sourcefile~param.f03 sourcefile~field_psi_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_psi_class.f03->sourcefile~system.f03 sourcefile~field_psi_class.f03->sourcefile~grid_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_src_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_solver_class.f03 sourcefile~field_psi_class.f03->sourcefile~ufield_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_class.f03 sourcefile~field_solver_class.f03->sourcefile~param.f03 sourcefile~field_solver_class.f03->sourcefile~system.f03 sourcefile~field_solver_class.f03->sourcefile~debug_tool.f03 sourcefile~ufield_class.f03->sourcefile~param.f03 sourcefile~ufield_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield_class.f03->sourcefile~system.f03 sourcefile~ufield_class.f03->sourcefile~grid_class.f03 sourcefile~field_class.f03->sourcefile~param.f03 sourcefile~field_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_class.f03->sourcefile~system.f03 sourcefile~field_class.f03->sourcefile~grid_class.f03 sourcefile~field_class.f03->sourcefile~ufield_class.f03 var pansourcefilesimulation_classf03EfferentGraph = svgPanZoom('#sourcefilesimulation_classf03EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules simulation_class Source Code simulation_class.f03 Source Code module simulation_class use parallel_class use parallel_pipe_class use grid_class use field_psi_class use field_e_class use field_b_class use field_src_class use input_class use system use param use mpi implicit none private public :: simulation type sim_fields private class ( parallel_pipe ), pointer :: pp => null () class ( grid ), pointer :: gp => null () type ( field_psi ), allocatable :: psi type ( field_b ), allocatable :: b_spe , b_beam type ( field_e ), allocatable :: e_spe , e_beam type ( field_jay ), allocatable :: jay type ( field_rho ), allocatable :: q_spe , q_beam type ( field_djdxi ), allocatable :: djdxi contains generic :: new => init_sim_fields generic :: del => end_sim_fields procedure , private :: init_sim_fields , end_sim_fields end type sim_fields type simulation private type ( input_json ), pointer :: input => null () class ( parallel_pipe ), pointer :: pp => null () class ( grid ), pointer :: gp => null () type ( sim_fields ) :: fields real :: dr , dxi , dt integer :: iter , nstep3d , nstep2d , start3d , nbeams , nspecies , tstep integer :: num_modes , interp contains generic :: new => init_simulation generic :: del => end_simulation ! generic :: go => go_simulation procedure , private :: init_simulation , end_simulation ! procedure, private :: init_diag, diag_simulation ! procedure, private :: go_simulation end type simulation contains subroutine init_sim_fields ( this , input , dr , dxi , num_modes , part_shape ) implicit none class ( sim_fields ), intent ( inout ) :: this type ( input_json ), pointer , intent ( inout ) :: input real , intent ( in ) :: dr , dxi integer , intent ( in ) :: num_modes , part_shape ! local data character ( len = 18 ), save :: sname = 'init_sim_fields' character ( len = 18 ), save :: cls_name = 'sim_fields' integer , save :: cls_level = 1 character ( len = 20 ) :: s1 , s2 , s3 character ( len = :), allocatable :: ff integer :: i , n , ndump , j , k , l , m integer :: entity this % gp => input % gp this % pp => input % pp call write_dbg ( cls_name , sname , cls_level , 'starts' ) allocate ( this % psi , this % e_spe , this % b_spe , this % e_beam , this % b_beam , & this % jay , this % q_spe , this % q_beam , this % djdxi ) call this % psi % new ( this % pp , this % gp , dr , dxi , num_modes , part_shape ) call this % jay % new ( this % pp , this % gp , dr , dxi , num_modes , part_shape ) call this % q_spe % new ( this % pp , this % gp , dr , dxi , num_modes , part_shape ) call this % q_beam % new ( this % pp , this % gp , dr , dxi , num_modes , part_shape ) call this % djdxi % new ( this % pp , this % gp , dr , dxi , num_modes , part_shape ) entity = p_entity_plasma call this % e_spe % new ( this % pp , this % gp , dr , dxi , num_modes , part_shape , entity ) call this % b_spe % new ( this % pp , this % gp , dr , dxi , num_modes , part_shape , entity ) entity = p_entity_beam call this % e_beam % new ( this % pp , this % gp , dr , dxi , num_modes , part_shape , entity ) call this % b_beam % new ( this % pp , this % gp , dr , dxi , num_modes , part_shape , entity ) ! call input%get('simulation.nspecies',n) ! loop1: do i = 1, n !   write (s1, '(I4.4)') i !   call input%info('species('//trim(s1)//').diag',n_children=m) !   do j = 1, m !      write (s2, '(I4.4)') j !      call input%get('species('//trim(s1)//').diag'//'('//trim(s2)//').ndump',ndump) !      if (ndump>0) then !         call input%info('species('//trim(s1)//').diag'//'('//trim(s2)//').name',n_children=l) !         do k = 1, l !            write (s3, '(I4.4)') k !            if(allocated(ff)) deallocate(ff) !            call input%get('species('//trim(s1)//').diag'//'('//trim(s2)//').name'& !            &//'('//trim(s3)//')',ff) !            if (ff == 'jx' .or. ff == 'jy' .or. ff == 'jz') then !               allocate(this%cu3d) !               call this%cu3d%new(this%p,this%err,this%sp3,dim=1) !               exit loop1 !            end if !         end do !      end if !   end do ! end do loop1 ! call input%info('field.diag',n_children=n) ! loop2: do i = 1, n !   write (s1,'(I4.4)') i !   call input%get('field.diag('//trim(s1)//').ndump',ndump) !   if (ndump > 0) then !      call input%info('field.diag('//trim(s1)//').name',n_children=m) !      do j = 1, m !         write (s2,'(I4.4)') j !         if(allocated(ff)) deallocate(ff) !         call input%get('field.diag('//trim(s1)//').name('//trim(s2)//')',ff) !         if (ff == 'psi') then !            allocate(this%psi3d) !            call this%psi3d%new(this%p,this%err,this%sp3,dim=1) !            exit loop2 !         end if !      end do !   end if ! end do loop2 call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine init_sim_fields subroutine end_sim_fields ( this ) implicit none class ( sim_fields ), intent ( inout ) :: this ! local data character ( len = 18 ), save :: sname = 'end_sim_fields' character ( len = 18 ), save :: cls_name = 'sim_fields' integer , save :: cls_level = 1 integer :: i , n call write_dbg ( cls_name , sname , cls_level , 'starts' ) call this % psi % del () call this % e_spe % del () call this % b_spe % del () call this % e_beam % del () call this % b_beam % del () call this % jay % del () call this % q_spe % del () call this % q_beam % del () call this % djdxi % del () call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine end_sim_fields subroutine init_simulation ( this ) implicit none class ( simulation ), intent ( inout ) :: this ! local data character ( len = 18 ), save :: sname = 'init_simulation:' character ( len = 18 ), save :: cls_name = 'simulation' integer , save :: cls_level = 0 real :: min , max , n0 , dr , dxi , dt , time integer :: nr , nz logical :: read_rst character ( len = :), allocatable :: interp_str allocate ( this % input ) call this % input % new () this % pp => this % input % pp this % gp => this % input % gp call write_dbg ( cls_name , sname , cls_level , 'starts' ) call this % input % get ( 'simulation.n0' , n0 ) call this % input % get ( 'simulation.box.r(1)' , min ) call this % input % get ( 'simulation.box.r(2)' , max ) nr = this % gp % get_nd ( 1 ) dr = ( max - min ) / real ( nr ) call this % input % get ( 'simulation.box.z(1)' , min ) call this % input % get ( 'simulation.box.z(2)' , max ) nz = this % gp % get_nd ( 2 ) dxi = ( max - min ) / real ( nz ) this % dr = dr this % dxi = dxi this % nstep2d = this % gp % get_ndp ( 2 ) call this % input % get ( 'simulation.time' , time ) call this % input % get ( 'simulation.dt' , dt ) this % nstep3d = time / dt this % dt = dt call this % input % get ( 'simulation.read_restart' , read_rst ) if ( read_rst ) then call this % input % get ( 'simulation.restart_timestep' , this % start3d ) this % start3d = this % start3d + 1 else this % start3d = 1 endif call this % input % get ( 'simulation.iter' , this % iter ) call this % input % get ( 'simulation.nbeams' , this % nbeams ) call this % input % get ( 'simulation.nspecies' , this % nspecies ) call this % input % get ( 'simulation.num_modes' , this % num_modes ) call this % input % get ( 'simulation.interp' , interp_str ) select case ( trim ( interp_str ) ) case ( 'linear' ) this % interp = p_ps_linear case ( 'quadratic' ) this % interp = p_ps_quadratic case default call write_err ( 'Invalid interpolation type!' ) end select call this % fields % new ( this % input , this % dr , this % dxi , this % num_modes , this % interp ) ! call this%beams%new(this%in,this%fields) ! call this%species%new(this%in,this%fields,(this%start3d-1)*dt) ! call this%init_diag() ! allocate(this%tag_spe(this%nspecies),this%tag_beam(this%nbeams)) ! allocate(this%id_spe(this%nspecies),this%id_beam(this%nbeams)) ! allocate(this%id_bq(this%nbeams,3),this%tag_bq(this%nbeams,2)) ! allocate(this%id(9+size(this%diag))) ! this%id(:) = MPI_REQUEST_NULL ! this%id_spe(:) = MPI_REQUEST_NULL ! this%id_beam(:) = MPI_REQUEST_NULL ! this%id_bq(:,:) = MPI_REQUEST_NULL call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine init_simulation subroutine end_simulation ( this ) implicit none class ( simulation ), intent ( inout ) :: this ! local data character ( len = 18 ), save :: sname = 'end_simulation' character ( len = 18 ), save :: cls_name = 'simulation' integer , save :: cls_level = 0 integer :: ierr call write_dbg ( cls_name , sname , cls_level , 'starts' ) call this % fields % del () ! call this%beams%del() ! call this%species%del() call this % gp % del () call this % pp % del () call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine end_simulation end module simulation_class","tags":"","loc":"sourcefile/simulation_class.f03.html"},{"title":"field_b_class.f03 – QuickPIC wit Azimuzal Decomposition","text":"This file depends on sourcefile~~field_b_class.f03~~EfferentGraph sourcefile~field_b_class.f03 field_b_class.f03 sourcefile~field_solver_class.f03 field_solver_class.f03 sourcefile~field_b_class.f03->sourcefile~field_solver_class.f03 sourcefile~param.f03 param.f03 sourcefile~field_b_class.f03->sourcefile~param.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~field_b_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~debug_tool.f03 debug_tool.f03 sourcefile~field_b_class.f03->sourcefile~debug_tool.f03 sourcefile~system.f03 system.f03 sourcefile~field_b_class.f03->sourcefile~system.f03 sourcefile~grid_class.f03 grid_class.f03 sourcefile~field_b_class.f03->sourcefile~grid_class.f03 sourcefile~field_src_class.f03 field_src_class.f03 sourcefile~field_b_class.f03->sourcefile~field_src_class.f03 sourcefile~ufield_class.f03 ufield_class.f03 sourcefile~field_b_class.f03->sourcefile~ufield_class.f03 sourcefile~field_class.f03 field_class.f03 sourcefile~field_b_class.f03->sourcefile~field_class.f03 sourcefile~field_solver_class.f03->sourcefile~param.f03 sourcefile~field_solver_class.f03->sourcefile~debug_tool.f03 sourcefile~field_solver_class.f03->sourcefile~system.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~grid_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~grid_class.f03->sourcefile~system.f03 sourcefile~field_src_class.f03->sourcefile~param.f03 sourcefile~field_src_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_src_class.f03->sourcefile~system.f03 sourcefile~field_src_class.f03->sourcefile~grid_class.f03 sourcefile~field_src_class.f03->sourcefile~field_class.f03 sourcefile~ufield_class.f03->sourcefile~param.f03 sourcefile~ufield_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield_class.f03->sourcefile~system.f03 sourcefile~ufield_class.f03->sourcefile~grid_class.f03 sourcefile~field_class.f03->sourcefile~param.f03 sourcefile~field_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_class.f03->sourcefile~system.f03 sourcefile~field_class.f03->sourcefile~grid_class.f03 sourcefile~field_class.f03->sourcefile~ufield_class.f03 var pansourcefilefield_b_classf03EfferentGraph = svgPanZoom('#sourcefilefield_b_classf03EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~field_b_class.f03~~AfferentGraph sourcefile~field_b_class.f03 field_b_class.f03 sourcefile~test_field_bperp.f03 TEST_field_bperp.f03 sourcefile~test_field_bperp.f03->sourcefile~field_b_class.f03 sourcefile~field_e_class.f03 field_e_class.f03 sourcefile~field_e_class.f03->sourcefile~field_b_class.f03 sourcefile~test_field_bz.f03 TEST_field_bz.f03 sourcefile~test_field_bz.f03->sourcefile~field_b_class.f03 sourcefile~test_field_eperp.f03 TEST_field_eperp.f03 sourcefile~test_field_eperp.f03->sourcefile~field_b_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_e_class.f03 sourcefile~test_field_bperp_iter.f03 TEST_field_bperp_iter.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_b_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~field_b_class.f03 sourcefile~simulation_class.f03->sourcefile~field_e_class.f03 sourcefile~test_field_eperp_beam.f03 TEST_field_eperp_beam.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_b_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_e_class.f03 sourcefile~test_field_ez.f03 TEST_field_ez.f03 sourcefile~test_field_ez.f03->sourcefile~field_e_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules field_b_class Source Code field_b_class.f03 Source Code module field_b_class use field_class use field_src_class use field_solver_class use ufield_class use param use system use parallel_pipe_class use grid_class use debug_tool implicit none private character ( len = 20 ), parameter :: cls_name = \"field_b\" integer , parameter :: cls_level = 1 public :: field_b type , extends ( field ) :: field_b ! private class ( field_solver ), dimension (:), pointer :: solver_bz => null () class ( field_solver ), dimension (:), pointer :: solver_bperp => null () class ( field_solver ), dimension (:), pointer :: solver_bperp_iter => null () real , dimension (:), pointer :: buf_re => null (), buf_im => null () real , dimension (:), pointer :: buf => null () contains generic :: new => init_field_b procedure :: del => end_field_b ! generic :: read_input => read_input_field_b generic :: solve => solve_field_bz , solve_field_bperp , solve_field_bperp_iter procedure , private :: init_field_b procedure , private :: end_field_b procedure , private :: set_source_bz procedure , private :: set_source_bperp procedure , private :: set_source_bperp_iter procedure , private :: get_solution_bz procedure , private :: get_solution_bperp procedure , private :: get_solution_bperp_iter procedure , private :: solve_field_bz procedure , private :: solve_field_bperp procedure , private :: solve_field_bperp_iter end type field_b contains subroutine init_field_b ( this , pp , gp , dr , dxi , num_modes , part_shape , entity ) implicit none class ( field_b ), intent ( inout ) :: this class ( parallel_pipe ), intent ( in ), pointer :: pp class ( grid ), intent ( in ), pointer :: gp integer , intent ( in ) :: num_modes , part_shape , entity real , intent ( in ) :: dr , dxi integer , dimension ( 2 , 2 ) :: gc_num integer :: dim , i integer , dimension ( 2 ) :: nd , ndp , noff real :: tol character ( len = 20 ), save :: sname = \"init_field_b\" call write_dbg ( cls_name , sname , cls_level , 'starts' ) nd = gp % get_nd () ndp = gp % get_ndp () noff = gp % get_noff () tol = 1.0d-6 select case ( part_shape ) case ( p_ps_linear ) gc_num (:, 1 ) = ( / 0 , 1 / ) gc_num (:, 2 ) = ( / 0 , 1 / ) case ( p_ps_quadratic ) print * , \"Quadratic particle shape not implemented.\" stop case default print * , \"Invalid particle shape.\" stop end select dim = 3 ! call initialization routine of the parent class call this % field % new ( pp , gp , dim , dr , dxi , num_modes , gc_num , entity ) ! initialize solver select case ( entity ) case ( p_entity_plasma ) allocate ( this % solver_bz ( 0 : num_modes ) ) allocate ( this % solver_bperp_iter ( 0 : num_modes ) ) do i = 0 , num_modes call this % solver_bz ( i )% new ( nd , ndp , noff , p_fk_bz , i , dr , p_hypre_cycred , tol ) call this % solver_bperp_iter ( i )% new ( nd , ndp , noff , p_fk_bperp_iter , i , dr , p_hypre_amg , tol ) enddo case ( p_entity_beam ) allocate ( this % solver_bperp ( 0 : num_modes ) ) do i = 0 , num_modes call this % solver_bperp ( i )% new ( nd , ndp , noff , p_fk_bperp , i , dr , p_hypre_amg , tol ) enddo case default call write_err ( 'Invalid field entity type.' ) end select call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine init_field_b subroutine end_field_b ( this ) implicit none class ( field_b ), intent ( inout ) :: this integer :: i character ( len = 20 ), save :: sname = 'end_field_b' call write_dbg ( cls_name , sname , cls_level , 'starts' ) select case ( this % entity ) case ( p_entity_plasma ) do i = 0 , this % num_modes call this % solver_bz ( i )% del () call this % solver_bperp_iter ( i )% del () enddo deallocate ( this % solver_bz ) deallocate ( this % solver_bperp_iter ) case ( p_entity_beam ) do i = 0 , this % num_modes call this % solver_bperp ( i )% del () enddo deallocate ( this % solver_bperp ) end select if ( associated ( this % buf_re ) ) deallocate ( this % buf_re ) if ( associated ( this % buf_im ) ) deallocate ( this % buf_im ) if ( associated ( this % buf ) ) deallocate ( this % buf ) call this % field % del () call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine end_field_b subroutine set_source_bz ( this , mode , jay_re , jay_im ) implicit none class ( field_b ), intent ( inout ) :: this class ( ufield ), intent ( in ) :: jay_re class ( ufield ), intent ( in ), optional :: jay_im integer , intent ( in ) :: mode integer :: i , nd1p real , dimension (:,:), pointer :: f1_re => null (), f1_im => null () real :: idrh , idr , a1 , a2 , a3 , b character ( len = 20 ), save :: sname = 'set_source_bz' call write_dbg ( cls_name , sname , cls_level , 'starts' ) nd1p = jay_re % get_ndp ( 1 ) idr = 1.0 / this % dr idrh = 0.5 * idr f1_re => jay_re % get_f1 () if ( . not . associated ( this % buf_re ) ) then allocate ( this % buf_re ( nd1p ) ) elseif ( size ( this % buf_re ) < nd1p ) then deallocate ( this % buf_re ) allocate ( this % buf_re ( nd1p ) ) endif if ( present ( jay_im ) ) then f1_im => jay_im % get_f1 () if ( . not . associated ( this % buf_im ) ) then allocate ( this % buf_im ( nd1p ) ) elseif ( size ( this % buf_im ) < nd1p ) then deallocate ( this % buf_im ) allocate ( this % buf_im ( nd1p ) ) endif endif if ( mode == 0 ) then do i = 2 , nd1p - 1 a1 = idrh * ( i - 1.0 ) / ( i - 0.5 ) a2 = - idrh / ( i - 0.5 ) a3 = - idrh * i / ( i - 0.5 ) this % buf_re ( i ) = a1 * f1_re ( 2 , i - 1 ) + a2 * f1_re ( 2 , i ) + a3 * f1_re ( 2 , i + 1 ) enddo ! calculate the derivatives at the boundary and axis this % buf_re ( 1 ) = - idr * ( f1_re ( 2 , 1 ) + f1_re ( 2 , 2 ) ) a2 = - idr * ( nd1p + 0.5 ) / ( nd1p - 0.5 ) this % buf_re ( nd1p ) = idr * f1_re ( 2 , nd1p - 1 ) + a2 * f1_re ( 2 , nd1p ) ! call write_data( this%buf_re, 'bsource-re-0.txt' ) elseif ( mode > 0 . and . present ( jay_im ) ) then do i = 2 , nd1p - 1 a1 = idrh * ( i - 1.0 ) / ( i - 0.5 ) a2 = - idrh / ( i - 0.5 ) a3 = - idrh * i / ( i - 0.5 ) b = idr * real ( mode ) / ( i - 0.5 ) this % buf_re ( i ) = a1 * f1_re ( 2 , i - 1 ) + a2 * f1_re ( 2 , i ) + a3 * f1_re ( 2 , i + 1 ) - & b * f1_im ( 1 , i ) this % buf_im ( i ) = a1 * f1_im ( 2 , i - 1 ) + a2 * f1_im ( 2 , i ) + a3 * f1_im ( 2 , i + 1 ) + & b * f1_re ( 1 , i ) enddo ! calculate the derivatives at the boundary and axis this % buf_re ( 1 ) = - idr * ( f1_re ( 2 , 1 ) + f1_re ( 2 , 2 ) + 2.0 * real ( mode ) * f1_im ( 1 , 1 ) ) this % buf_im ( 1 ) = - idr * ( f1_im ( 2 , 1 ) + f1_im ( 2 , 2 ) - 2.0 * real ( mode ) * f1_re ( 1 , 1 ) ) a2 = - idr * ( nd1p + 0.5 ) / ( nd1p - 0.5 ) b = idr * real ( mode ) / ( nd1p - 0.5 ) this % buf_re ( nd1p ) = idr * f1_re ( 2 , nd1p - 1 ) + a2 * f1_re ( 2 , nd1p ) - b * f1_im ( 1 , nd1p ) this % buf_im ( nd1p ) = idr * f1_im ( 2 , nd1p - 1 ) + a2 * f1_im ( 2 , nd1p ) + b * f1_re ( 1 , nd1p ) else call write_err ( 'Invalid input arguments!' ) endif call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine set_source_bz subroutine set_source_bperp ( this , mode , q_re , q_im ) implicit none class ( field_b ), intent ( inout ) :: this class ( ufield ), intent ( in ) :: q_re class ( ufield ), intent ( in ), optional :: q_im integer , intent ( in ) :: mode integer :: i , nd1p real , dimension (:,:), pointer :: f1_re => null (), f1_im => null () real :: idrh , idr , a1 , a2 , a3 , b , ir character ( len = 20 ), save :: sname = 'set_source_bperp' call write_dbg ( cls_name , sname , cls_level , 'starts' ) nd1p = q_re % get_ndp ( 1 ) idr = 1.0 / this % dr idrh = 0.5 * idr f1_re => q_re % get_f1 () if ( . not . associated ( this % buf ) ) then allocate ( this % buf ( nd1p * 4 ) ) endif if ( present ( q_im ) ) then f1_im => q_im % get_f1 () endif this % buf = 0.0 if ( mode == 0 ) then do i = 2 , nd1p - 1 ir = idr / ( i - 0.5 ) ! Re(Br) this % buf ( 4 * i - 3 ) = 0.0 ! Im(Br) this % buf ( 4 * i - 2 ) = 0.0 ! Re(Bphi) this % buf ( 4 * i - 1 ) = idrh * ( f1_re ( 1 , i + 1 ) - f1_re ( 1 , i - 1 ) ) ! Im(Bphi) this % buf ( 4 * i ) = 0.0 enddo ! calculate the derivatives at the boundary and axis this % buf ( 1 ) = 0.0 this % buf ( 2 ) = 0.0 this % buf ( 3 ) = idr * ( f1_re ( 1 , 2 ) - f1_re ( 1 , 1 ) ) this % buf ( 4 ) = 0.0 this % buf ( 4 * nd1p - 3 ) = 0.0 this % buf ( 4 * nd1p - 2 ) = 0.0 this % buf ( 4 * nd1p - 1 ) = idr * ( f1_re ( 1 , nd1p ) - f1_re ( 1 , nd1p - 1 ) ) this % buf ( 4 * nd1p ) = 0.0 ! call write_data( this%buf, 'bsource-re-0.txt' ) elseif ( mode > 0 . and . present ( q_im ) ) then do i = 2 , nd1p - 1 ir = idr / ( i - 0.5 ) this % buf ( 4 * i - 3 ) = mode * f1_im ( 1 , i ) * ir this % buf ( 4 * i - 2 ) = - mode * f1_re ( 1 , i ) * ir this % buf ( 4 * i - 1 ) = idrh * ( f1_re ( 1 , i + 1 ) - f1_re ( 1 , i - 1 ) ) this % buf ( 4 * i ) = idrh * ( f1_im ( 1 , i + 1 ) - f1_im ( 1 , i - 1 ) ) enddo ! calculate the derivatives at the boundary and axis ir = 2.0 * idr this % buf ( 1 ) = mode * f1_im ( 1 , 1 ) * ir this % buf ( 2 ) = - mode * f1_re ( 1 , 1 ) * ir this % buf ( 3 ) = idr * ( f1_re ( 1 , 2 ) - f1_re ( 1 , 1 ) ) this % buf ( 4 ) = idr * ( f1_im ( 1 , 2 ) - f1_im ( 1 , 1 ) ) ir = idr / ( nd1p - 0.5 ) this % buf ( 4 * nd1p - 3 ) = mode * f1_im ( 1 , nd1p ) * ir this % buf ( 4 * nd1p - 2 ) = - mode * f1_re ( 1 , nd1p ) * ir this % buf ( 4 * nd1p - 1 ) = idr * ( f1_re ( 1 , nd1p ) - f1_re ( 1 , nd1p - 1 ) ) this % buf ( 4 * nd1p ) = idr * ( f1_im ( 1 , nd1p ) - f1_im ( 1 , nd1p - 1 ) ) else call write_err ( 'Invalid input arguments!' ) endif call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine set_source_bperp subroutine set_source_bperp_iter ( this , mode , djdxi_re , jay_re , djdxi_im , jay_im ) implicit none class ( field_b ), intent ( inout ) :: this class ( ufield ), intent ( in ) :: djdxi_re , jay_re class ( ufield ), intent ( in ), optional :: djdxi_im , jay_im integer , intent ( in ) :: mode integer :: i , nd1p real , dimension (:,:), pointer :: f1_re => null (), f1_im => null () real , dimension (:,:), pointer :: f2_re => null (), f2_im => null () real , dimension (:,:), pointer :: f3_re => null (), f3_im => null () real :: idrh , idr , a1 , a2 , a3 , b , ir character ( len = 20 ), save :: sname = 'set_source_bperp_iter' call write_dbg ( cls_name , sname , cls_level , 'starts' ) nd1p = jay_re % get_ndp ( 1 ) idr = 1.0 / this % dr idrh = 0.5 * idr f1_re => djdxi_re % get_f1 () f2_re => jay_re % get_f1 () f3_re => this % rf_re ( mode )% get_f1 () if ( . not . associated ( this % buf ) ) then allocate ( this % buf ( nd1p * 4 ) ) endif if ( present ( djdxi_im ) . and . present ( jay_im ) ) then f1_im => djdxi_im % get_f1 () f2_im => jay_im % get_f1 () f3_im => this % rf_im ( mode )% get_f1 () endif this % buf = 0.0 if ( mode == 0 ) then do i = 2 , nd1p - 1 ir = idr / ( i - 0.5 ) ! Re(Br) this % buf ( 4 * i - 3 ) = - f1_re ( 2 , i ) - f3_re ( 1 , i ) ! Im(Br) this % buf ( 4 * i - 2 ) = 0.0 ! Re(Bphi) this % buf ( 4 * i - 1 ) = f1_re ( 1 , i ) + idrh * ( f2_re ( 3 , i + 1 ) - f2_re ( 3 , i - 1 ) ) - f3_re ( 2 , i ) ! Im(Bphi) this % buf ( 4 * i ) = 0.0 enddo ! calculate the derivatives at the boundary and axis this % buf ( 1 ) = - f1_re ( 2 , 1 ) - f3_re ( 1 , 1 ) this % buf ( 2 ) = 0.0 this % buf ( 3 ) = f1_re ( 1 , 1 ) + idr * ( f2_re ( 3 , 2 ) - f2_re ( 3 , 1 ) ) - f3_re ( 2 , 1 ) this % buf ( 4 ) = 0.0 this % buf ( 4 * nd1p - 3 ) = - f1_re ( 2 , nd1p ) - f3_re ( 1 , nd1p ) this % buf ( 4 * nd1p - 2 ) = 0.0 this % buf ( 4 * nd1p - 1 ) = f1_re ( 1 , nd1p ) + idr * ( f2_re ( 3 , nd1p ) - f2_re ( 3 , nd1p - 1 ) ) - f3_re ( 2 , nd1p ) this % buf ( 4 * nd1p ) = 0.0 ! call write_data( this%buf, 'bsource-re-0.txt' ) elseif ( mode > 0 . and . present ( jay_im ) . and . present ( djdxi_im ) ) then do i = 2 , nd1p - 1 ir = idr / ( i - 0.5 ) this % buf ( 4 * i - 3 ) = - f1_re ( 2 , i ) + mode * f2_im ( 3 , i ) * ir - f3_re ( 1 , i ) this % buf ( 4 * i - 2 ) = - f1_im ( 2 , i ) - mode * f2_re ( 3 , i ) * ir - f3_im ( 1 , i ) this % buf ( 4 * i - 1 ) = f1_re ( 1 , i ) + idrh * ( f2_re ( 3 , i + 1 ) - f2_re ( 3 , i - 1 ) ) - f3_re ( 2 , i ) this % buf ( 4 * i ) = f1_im ( 1 , i ) + idrh * ( f2_im ( 3 , i + 1 ) - f2_im ( 3 , i - 1 ) ) - f3_im ( 2 , i ) enddo ! calculate the derivatives at the boundary and axis ir = 2.0 * idr this % buf ( 1 ) = - f1_re ( 2 , 1 ) + mode * f2_im ( 3 , 1 ) * ir - f3_re ( 1 , 1 ) this % buf ( 2 ) = - f1_im ( 2 , 1 ) - mode * f2_re ( 3 , 1 ) * ir - f3_im ( 1 , 1 ) this % buf ( 3 ) = f1_re ( 1 , 1 ) + idr * ( f2_re ( 3 , 2 ) - f2_re ( 3 , 1 ) ) - f3_re ( 2 , 1 ) this % buf ( 4 ) = f1_im ( 1 , 1 ) + idr * ( f2_im ( 3 , 2 ) - f2_im ( 3 , 1 ) ) - f3_im ( 2 , 1 ) ir = idr / ( nd1p - 0.5 ) this % buf ( 4 * nd1p - 3 ) = - f1_re ( 2 , nd1p ) + mode * f2_im ( 3 , nd1p ) * ir - f3_re ( 1 , nd1p ) this % buf ( 4 * nd1p - 2 ) = - f1_im ( 2 , nd1p ) - mode * f2_re ( 3 , nd1p ) * ir - f3_im ( 1 , nd1p ) this % buf ( 4 * nd1p - 1 ) = f1_re ( 1 , nd1p ) + idr * ( f2_re ( 3 , nd1p ) - f2_re ( 3 , nd1p - 1 ) ) - f3_re ( 2 , nd1p ) this % buf ( 4 * nd1p ) = f1_im ( 1 , nd1p ) + idr * ( f2_im ( 3 , nd1p ) - f2_im ( 3 , nd1p - 1 ) ) - f3_im ( 2 , nd1p ) else call write_err ( 'Invalid input arguments!' ) endif call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine set_source_bperp_iter subroutine get_solution_bz ( this , mode ) implicit none class ( field_b ), intent ( inout ) :: this integer , intent ( in ) :: mode integer :: i , nd1p real , dimension (:,:), pointer :: f1_re => null (), f1_im => null () character ( len = 20 ), save :: sname = 'get_solution_bz' call write_dbg ( cls_name , sname , cls_level , 'starts' ) nd1p = this % rf_re ( mode )% get_ndp ( 1 ) f1_re => this % rf_re ( mode )% get_f1 () do i = 1 , nd1p f1_re ( 3 , i ) = this % buf_re ( i ) enddo if ( mode > 0 ) then f1_im => this % rf_im ( mode )% get_f1 () do i = 1 , nd1p f1_im ( 3 , i ) = this % buf_im ( i ) enddo endif call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine get_solution_bz subroutine get_solution_bperp ( this , mode ) implicit none class ( field_b ), intent ( inout ) :: this integer , intent ( in ) :: mode integer :: i , nd1p real , dimension (:,:), pointer :: f1_re => null (), f1_im => null () character ( len = 20 ), save :: sname = 'get_solution_bperp' call write_dbg ( cls_name , sname , cls_level , 'starts' ) nd1p = this % rf_re ( mode )% get_ndp ( 1 ) f1_re => this % rf_re ( mode )% get_f1 () do i = 1 , nd1p f1_re ( 1 , i ) = this % buf ( 4 * i - 3 ) f1_re ( 2 , i ) = this % buf ( 4 * i - 1 ) enddo if ( mode > 0 ) then f1_im => this % rf_im ( mode )% get_f1 () do i = 1 , nd1p f1_im ( 1 , i ) = this % buf ( 4 * i - 2 ) f1_im ( 2 , i ) = this % buf ( 4 * i ) enddo endif call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine get_solution_bperp subroutine get_solution_bperp_iter ( this , mode ) ! this is totally the same as get_solution_bperp() implicit none class ( field_b ), intent ( inout ) :: this integer , intent ( in ) :: mode integer :: i , nd1p real , dimension (:,:), pointer :: f1_re => null (), f1_im => null () character ( len = 20 ), save :: sname = 'get_solution_bperp_iter' call write_dbg ( cls_name , sname , cls_level , 'starts' ) nd1p = this % rf_re ( mode )% get_ndp ( 1 ) f1_re => this % rf_re ( mode )% get_f1 () do i = 1 , nd1p f1_re ( 1 , i ) = this % buf ( 4 * i - 3 ) f1_re ( 2 , i ) = this % buf ( 4 * i - 1 ) enddo if ( mode > 0 ) then f1_im => this % rf_im ( mode )% get_f1 () do i = 1 , nd1p f1_im ( 1 , i ) = this % buf ( 4 * i - 2 ) f1_im ( 2 , i ) = this % buf ( 4 * i ) enddo endif call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine get_solution_bperp_iter subroutine solve_field_bz ( this , jay ) implicit none class ( field_b ), intent ( inout ) :: this class ( field_jay ), intent ( in ) :: jay type ( ufield ), dimension (:), pointer :: jay_re => null (), jay_im => null () integer :: i character ( len = 20 ), save :: sname = 'solve_field_bz' call write_dbg ( cls_name , sname , cls_level , 'starts' ) jay_re => jay % get_rf_re () jay_im => jay % get_rf_im () do i = 0 , this % num_modes if ( i == 0 ) then call this % set_source_bz ( i , jay_re ( i ) ) call this % solver_bz ( i )% solve ( this % buf_re ) call this % get_solution_bz ( i ) cycle endif call this % set_source_bz ( i , jay_re ( i ), jay_im ( i ) ) call this % solver_bz ( i )% solve ( this % buf_re ) call this % solver_bz ( i )% solve ( this % buf_im ) call this % get_solution_bz ( i ) enddo call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine solve_field_bz subroutine solve_field_bperp ( this , rho ) implicit none class ( field_b ), intent ( inout ) :: this class ( field_rho ), intent ( in ) :: rho type ( ufield ), dimension (:), pointer :: rho_re => null (), rho_im => null () integer :: i character ( len = 20 ), save :: sname = 'solve_field_bperp' call write_dbg ( cls_name , sname , cls_level , 'starts' ) rho_re => rho % get_rf_re () rho_im => rho % get_rf_im () do i = 0 , this % num_modes if ( i == 0 ) then call this % set_source_bperp ( i , rho_re ( i ) ) call this % solver_bperp ( i )% solve ( this % buf ) call this % get_solution_bperp ( i ) cycle endif call this % set_source_bperp ( i , rho_re ( i ), rho_im ( i ) ) call this % solver_bperp ( i )% solve ( this % buf ) call this % get_solution_bperp ( i ) enddo call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine solve_field_bperp subroutine solve_field_bperp_iter ( this , djdxi , jay ) implicit none class ( field_b ), intent ( inout ) :: this class ( field_djdxi ), intent ( in ) :: djdxi class ( field_jay ), intent ( in ) :: jay type ( ufield ), dimension (:), pointer :: jay_re => null (), jay_im => null () type ( ufield ), dimension (:), pointer :: djdxi_re => null (), djdxi_im => null () integer :: i character ( len = 20 ), save :: sname = 'solve_field_bperp_iter' call write_dbg ( cls_name , sname , cls_level , 'starts' ) djdxi_re => djdxi % get_rf_re () djdxi_im => djdxi % get_rf_im () jay_re => jay % get_rf_re () jay_im => jay % get_rf_im () do i = 0 , this % num_modes if ( i == 0 ) then call this % set_source_bperp_iter ( i , djdxi_re ( i ), jay_re ( i ) ) call this % solver_bperp_iter ( i )% solve ( this % buf ) call this % get_solution_bperp_iter ( i ) cycle endif call this % set_source_bperp_iter ( i , djdxi_re ( i ), jay_re ( i ), djdxi_im ( i ), jay_im ( i ) ) call this % solver_bperp_iter ( i )% solve ( this % buf ) call this % get_solution_bperp_iter ( i ) enddo call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine solve_field_bperp_iter end module field_b_class","tags":"","loc":"sourcefile/field_b_class.f03.html"},{"title":"field_e_class.f03 – QuickPIC wit Azimuzal Decomposition","text":"This file depends on sourcefile~~field_e_class.f03~~EfferentGraph sourcefile~field_e_class.f03 field_e_class.f03 sourcefile~field_solver_class.f03 field_solver_class.f03 sourcefile~field_e_class.f03->sourcefile~field_solver_class.f03 sourcefile~param.f03 param.f03 sourcefile~field_e_class.f03->sourcefile~param.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~field_e_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~system.f03 system.f03 sourcefile~field_e_class.f03->sourcefile~system.f03 sourcefile~grid_class.f03 grid_class.f03 sourcefile~field_e_class.f03->sourcefile~grid_class.f03 sourcefile~field_src_class.f03 field_src_class.f03 sourcefile~field_e_class.f03->sourcefile~field_src_class.f03 sourcefile~field_b_class.f03 field_b_class.f03 sourcefile~field_e_class.f03->sourcefile~field_b_class.f03 sourcefile~ufield_class.f03 ufield_class.f03 sourcefile~field_e_class.f03->sourcefile~ufield_class.f03 sourcefile~field_class.f03 field_class.f03 sourcefile~field_e_class.f03->sourcefile~field_class.f03 sourcefile~field_psi_class.f03 field_psi_class.f03 sourcefile~field_e_class.f03->sourcefile~field_psi_class.f03 sourcefile~field_solver_class.f03->sourcefile~param.f03 sourcefile~field_solver_class.f03->sourcefile~system.f03 sourcefile~debug_tool.f03 debug_tool.f03 sourcefile~field_solver_class.f03->sourcefile~debug_tool.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~grid_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~grid_class.f03->sourcefile~system.f03 sourcefile~field_src_class.f03->sourcefile~param.f03 sourcefile~field_src_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_src_class.f03->sourcefile~system.f03 sourcefile~field_src_class.f03->sourcefile~grid_class.f03 sourcefile~field_src_class.f03->sourcefile~field_class.f03 sourcefile~field_b_class.f03->sourcefile~field_solver_class.f03 sourcefile~field_b_class.f03->sourcefile~param.f03 sourcefile~field_b_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_b_class.f03->sourcefile~system.f03 sourcefile~field_b_class.f03->sourcefile~grid_class.f03 sourcefile~field_b_class.f03->sourcefile~field_src_class.f03 sourcefile~field_b_class.f03->sourcefile~ufield_class.f03 sourcefile~field_b_class.f03->sourcefile~field_class.f03 sourcefile~field_b_class.f03->sourcefile~debug_tool.f03 sourcefile~ufield_class.f03->sourcefile~param.f03 sourcefile~ufield_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield_class.f03->sourcefile~system.f03 sourcefile~ufield_class.f03->sourcefile~grid_class.f03 sourcefile~field_class.f03->sourcefile~param.f03 sourcefile~field_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_class.f03->sourcefile~system.f03 sourcefile~field_class.f03->sourcefile~grid_class.f03 sourcefile~field_class.f03->sourcefile~ufield_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_solver_class.f03 sourcefile~field_psi_class.f03->sourcefile~param.f03 sourcefile~field_psi_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_psi_class.f03->sourcefile~system.f03 sourcefile~field_psi_class.f03->sourcefile~grid_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_src_class.f03 sourcefile~field_psi_class.f03->sourcefile~ufield_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_class.f03 var pansourcefilefield_e_classf03EfferentGraph = svgPanZoom('#sourcefilefield_e_classf03EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~field_e_class.f03~~AfferentGraph sourcefile~field_e_class.f03 field_e_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~field_e_class.f03 sourcefile~test_field_ez.f03 TEST_field_ez.f03 sourcefile~test_field_ez.f03->sourcefile~field_e_class.f03 sourcefile~test_field_eperp.f03 TEST_field_eperp.f03 sourcefile~test_field_eperp.f03->sourcefile~field_e_class.f03 sourcefile~test_field_eperp_beam.f03 TEST_field_eperp_beam.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_e_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules field_e_class Source Code field_e_class.f03 Source Code module field_e_class use parallel_pipe_class use grid_class use field_class use field_b_class use field_psi_class use field_src_class use field_solver_class use ufield_class use param use system implicit none private character ( len = 20 ), parameter :: cls_name = \"field_e\" integer , parameter :: cls_level = 1 public :: field_e type , extends ( field ) :: field_e ! private class ( field_solver ), dimension (:), pointer :: solver_ez => null () real , dimension (:), pointer :: buf_re => null (), buf_im => null () contains generic :: new => init_field_e procedure :: del => end_field_e ! generic :: read_input => read_input_field_e generic :: solve => solve_field_ez , solve_field_eperp , solve_field_eperp_beam procedure , private :: init_field_e procedure , private :: end_field_e procedure , private :: set_source_ez procedure , private :: get_solution_ez procedure , private :: solve_field_ez procedure , private :: solve_field_eperp procedure , private :: solve_field_eperp_beam end type field_e contains subroutine init_field_e ( this , pp , gp , dr , dxi , num_modes , part_shape , entity ) implicit none class ( field_e ), intent ( inout ) :: this class ( parallel_pipe ), intent ( in ), pointer :: pp class ( grid ), intent ( in ), pointer :: gp integer , intent ( in ) :: num_modes , part_shape , entity real , intent ( in ) :: dr , dxi integer , dimension ( 2 , 2 ) :: gc_num integer :: dim , i integer , dimension ( 2 ) :: ndp , noff , nd real :: tol character ( len = 20 ), save :: sname = \"init_field_e\" call write_dbg ( cls_name , sname , cls_level , 'starts' ) nd = gp % get_nd () ndp = gp % get_ndp () noff = gp % get_noff () tol = 1.0d-6 select case ( part_shape ) case ( p_ps_linear ) gc_num (:, 1 ) = ( / 0 , 1 / ) gc_num (:, 2 ) = ( / 0 , 1 / ) case ( p_ps_quadratic ) print * , \"Quadratic particle shape not implemented.\" stop case default print * , \"Invalid particle shape.\" stop end select dim = 3 ! call initialization routine of the parent class call this % field % new ( pp , gp , dim , dr , dxi , num_modes , gc_num , entity ) ! initialize solver select case ( entity ) case ( p_entity_plasma ) allocate ( this % solver_ez ( 0 : num_modes ) ) do i = 0 , num_modes call this % solver_ez ( i )% new ( nd , ndp , noff , p_fk_ez , i , dr , p_hypre_cycred , tol ) enddo case ( p_entity_beam ) ! do nothing case default call write_err ( 'Invalid field entity type.' ) end select call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine init_field_e subroutine end_field_e ( this ) implicit none class ( field_e ), intent ( inout ) :: this integer :: i character ( len = 20 ), save :: sname = 'end_field_e' call write_dbg ( cls_name , sname , cls_level , 'starts' ) if ( this % entity == p_entity_plasma ) then do i = 0 , this % num_modes call this % solver_ez ( i )% del () enddo deallocate ( this % solver_ez ) endif if ( associated ( this % buf_re ) ) deallocate ( this % buf_re ) if ( associated ( this % buf_im ) ) deallocate ( this % buf_im ) call this % field % del () call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine end_field_e subroutine set_source_ez ( this , mode , jay_re , jay_im ) implicit none class ( field_e ), intent ( inout ) :: this integer , intent ( in ) :: mode class ( ufield ), intent ( in ) :: jay_re class ( ufield ), intent ( in ), optional :: jay_im integer :: i , nd1p real , dimension (:,:), pointer :: f1_re => null (), f1_im => null () real :: idrh , idr , a1 , a2 , a3 , b character ( len = 20 ), save :: sname = 'set_source_ez' call write_dbg ( cls_name , sname , cls_level , 'starts' ) nd1p = jay_re % get_ndp ( 1 ) idr = 1.0 / this % dr idrh = 0.5 * idr f1_re => jay_re % get_f1 () if ( . not . associated ( this % buf_re ) ) then allocate ( this % buf_re ( nd1p ) ) elseif ( size ( this % buf_re ) < nd1p ) then deallocate ( this % buf_re ) allocate ( this % buf_re ( nd1p ) ) endif if ( present ( jay_im ) ) then f1_im => jay_im % get_f1 () if ( . not . associated ( this % buf_im ) ) then allocate ( this % buf_im ( nd1p ) ) elseif ( size ( this % buf_im ) < nd1p ) then deallocate ( this % buf_im ) allocate ( this % buf_im ( nd1p ) ) endif endif if ( mode == 0 ) then do i = 2 , nd1p - 1 a1 = - idrh * ( i - 1.0 ) / ( i - 0.5 ) a2 = idrh / ( i - 0.5 ) a3 = idrh * i / ( i - 0.5 ) this % buf_re ( i ) = a1 * f1_re ( 1 , i - 1 ) + a2 * f1_re ( 1 , i ) + a3 * f1_re ( 1 , i + 1 ) enddo ! calculate the derivatives at the boundary and axis this % buf_re ( 1 ) = idr * ( f1_re ( 1 , 1 ) + f1_re ( 1 , 2 ) ) a2 = idr * ( nd1p + 0.5 ) / ( nd1p - 0.5 ) this % buf_re ( nd1p ) = - idr * f1_re ( 1 , nd1p - 1 ) + a2 * f1_re ( 1 , nd1p ) elseif ( mode > 0 . and . present ( jay_im ) ) then do i = 2 , nd1p - 1 a1 = - idrh * ( i - 1.0 ) / ( i - 0.5 ) a2 = idrh / ( i - 0.5 ) a3 = idrh * i / ( i - 0.5 ) b = idr * real ( mode ) / ( i - 0.5 ) this % buf_re ( i ) = a1 * f1_re ( 1 , i - 1 ) + a2 * f1_re ( 1 , i ) + a3 * f1_re ( 1 , i + 1 ) - & b * f1_im ( 2 , i ) this % buf_im ( i ) = a1 * f1_im ( 1 , i - 1 ) + a2 * f1_im ( 1 , i ) + a3 * f1_im ( 1 , i + 1 ) + & b * f1_re ( 2 , i ) enddo ! calculate the derivatives at the boundary and axis???????????????????????????????????? this % buf_re ( 1 ) = idr * ( f1_re ( 2 , 1 ) + f1_re ( 2 , 2 ) - 2.0 * real ( mode ) * f1_im ( 1 , 1 ) ) this % buf_im ( 1 ) = idr * ( f1_im ( 2 , 1 ) + f1_im ( 2 , 2 ) + 2.0 * real ( mode ) * f1_re ( 1 , 1 ) ) a2 = idr * ( nd1p + 0.5 ) / ( nd1p - 0.5 ) b = idr * real ( mode ) / ( nd1p - 0.5 ) this % buf_re ( nd1p ) = - idr * f1_re ( 2 , nd1p - 1 ) + a2 * f1_re ( 2 , nd1p ) - b * f1_im ( 1 , nd1p ) this % buf_im ( nd1p ) = - idr * f1_im ( 2 , nd1p - 1 ) + a2 * f1_im ( 2 , nd1p ) + b * f1_re ( 1 , nd1p ) else call write_err ( 'Invalid input arguments!' ) endif call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine set_source_ez subroutine get_solution_ez ( this , mode ) implicit none class ( field_e ), intent ( inout ) :: this integer , intent ( in ) :: mode integer :: i , nd1p real , dimension (:,:), pointer :: f1_re => null (), f1_im => null () character ( len = 20 ), save :: sname = 'get_solution_ez' call write_dbg ( cls_name , sname , cls_level , 'starts' ) nd1p = this % rf_re ( mode )% get_ndp ( 1 ) f1_re => this % rf_re ( mode )% get_f1 () do i = 1 , nd1p f1_re ( 3 , i ) = this % buf_re ( i ) enddo if ( mode > 0 ) then f1_im => this % rf_im ( mode )% get_f1 () do i = 1 , nd1p f1_im ( 3 , i ) = this % buf_im ( i ) enddo endif call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine get_solution_ez subroutine solve_field_ez ( this , jay ) implicit none class ( field_e ), intent ( inout ) :: this class ( field_jay ), intent ( in ) :: jay type ( ufield ), dimension (:), pointer :: jay_re => null (), jay_im => null () integer :: i character ( len = 20 ), save :: sname = 'solve_field_ez' call write_dbg ( cls_name , sname , cls_level , 'starts' ) jay_re => jay % get_rf_re () jay_im => jay % get_rf_im () do i = 0 , this % num_modes if ( i == 0 ) then call this % set_source_ez ( i , jay_re ( i ) ) call this % solver_ez ( i )% solve ( this % buf_re ) call this % get_solution_ez ( i ) cycle endif call this % set_source_ez ( i , jay_re ( i ), jay_im ( i ) ) call this % solver_ez ( i )% solve ( this % buf_re ) call this % solver_ez ( i )% solve ( this % buf_im ) call this % get_solution_ez ( i ) enddo call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine solve_field_ez subroutine solve_field_eperp ( this , b , psi ) implicit none class ( field_e ), intent ( inout ) :: this class ( field_b ), intent ( in ) :: b class ( field_psi ), intent ( in ) :: psi type ( ufield ), dimension (:), pointer :: b_re => null (), b_im => null () type ( ufield ), dimension (:), pointer :: psi_re => null (), psi_im => null () real , dimension (:,:), pointer :: ub_re => null (), ub_im => null () real , dimension (:,:), pointer :: upsi_re => null (), upsi_im => null () real , dimension (:,:), pointer :: ue_re => null (), ue_im => null () integer :: mode , i , nd1p real :: idr , idrh , ir character ( len = 20 ), save :: sname = 'solve_field_eperp' call write_dbg ( cls_name , sname , cls_level , 'starts' ) idr = 1.0 / this % dr idrh = idr * 0.5 nd1p = this % rf_re ( 0 )% get_ndp ( 1 ) b_re => b % get_rf_re () b_im => b % get_rf_im () psi_re => psi % get_rf_re () psi_im => psi % get_rf_im () do mode = 0 , this % num_modes ub_re => b_re ( mode )% get_f1 () upsi_re => psi_re ( mode )% get_f1 () ue_re => this % rf_re ( mode )% get_f1 () if ( mode == 0 ) then do i = 2 , nd1p - 1 ue_re ( 1 , i ) = ub_re ( 2 , i ) - idrh * ( upsi_re ( 1 , i + 1 ) - upsi_re ( 1 , i - 1 ) ) ue_re ( 2 , i ) = - ub_re ( 1 , i ) enddo ue_re ( 1 , 1 ) = ub_re ( 2 , 1 ) - idr * ( upsi_re ( 1 , 2 ) - upsi_re ( 1 , 1 ) ) ue_re ( 2 , 1 ) = - ub_re ( 1 , 1 ) ue_re ( 1 , nd1p ) = ub_re ( 2 , nd1p ) - idr * ( upsi_re ( 1 , nd1p ) - upsi_re ( 1 , nd1p - 1 ) ) ue_re ( 2 , nd1p ) = - ub_re ( 1 , nd1p ) cycle endif ub_im => b_im ( mode )% get_f1 () upsi_im => psi_im ( mode )% get_f1 () ue_im => this % rf_im ( mode )% get_f1 () do i = 2 , nd1p - 1 ir = idr / ( i - 0.5 ) ue_re ( 1 , i ) = ub_re ( 2 , i ) - idrh * ( upsi_re ( 1 , i + 1 ) - upsi_re ( 1 , i - 1 ) ) ue_re ( 2 , i ) = - ub_re ( 1 , i ) + ir * mode * upsi_im ( 1 , i ) ue_im ( 1 , i ) = ub_im ( 2 , i ) - idrh * ( upsi_im ( 1 , i + 1 ) - upsi_im ( 1 , i - 1 ) ) ue_im ( 2 , i ) = - ub_im ( 1 , i ) - ir * mode * upsi_re ( 1 , i ) enddo ir = 2.0 * idr ue_re ( 1 , 1 ) = ub_re ( 2 , 1 ) - idr * ( upsi_re ( 1 , 2 ) - upsi_re ( 1 , 1 ) ) ue_re ( 2 , 1 ) = - ub_re ( 1 , 1 ) + ir * mode * upsi_im ( 1 , 1 ) ue_im ( 1 , 1 ) = ub_im ( 2 , 1 ) - idr * ( upsi_im ( 1 , 2 ) - upsi_im ( 1 , 1 ) ) ue_im ( 2 , 1 ) = - ub_im ( 1 , 1 ) - ir * mode * upsi_re ( 1 , 1 ) ir = idr / ( nd1p - 0.5 ) ue_re ( 1 , nd1p ) = ub_re ( 2 , nd1p ) - idr * ( upsi_re ( 1 , nd1p ) - upsi_re ( 1 , nd1p - 1 ) ) ue_re ( 2 , nd1p ) = - ub_re ( 1 , nd1p ) + ir * mode * upsi_im ( 1 , nd1p ) ue_im ( 1 , nd1p ) = ub_im ( 2 , nd1p ) - idr * ( upsi_im ( 1 , nd1p ) - upsi_im ( 1 , nd1p - 1 ) ) ue_im ( 2 , nd1p ) = - ub_im ( 1 , nd1p ) - ir * mode * upsi_re ( 1 , nd1p ) enddo end subroutine solve_field_eperp subroutine solve_field_eperp_beam ( this , b ) implicit none class ( field_e ), intent ( inout ) :: this class ( field_b ), intent ( in ) :: b type ( ufield ), dimension (:), pointer :: b_re => null (), b_im => null () real , dimension (:,:), pointer :: ub_re => null (), ub_im => null () real , dimension (:,:), pointer :: ue_re => null (), ue_im => null () integer :: mode , i , nd1p character ( len = 20 ), save :: sname = 'solve_field_eperp_beam' call write_dbg ( cls_name , sname , cls_level , 'starts' ) b_re => b % get_rf_re () b_im => b % get_rf_im () nd1p = this % rf_re ( 0 )% get_ndp ( 1 ) do mode = 0 , this % num_modes ub_re => b_re ( mode )% get_f1 () ue_re => this % rf_re ( mode )% get_f1 () do i = 1 , nd1p ue_re ( 1 , i ) = ub_re ( 2 , i ) ue_re ( 2 , i ) = - ub_re ( 1 , i ) enddo if ( mode == 0 ) cycle ub_im => b_im ( mode )% get_f1 () ue_im => this % rf_im ( mode )% get_f1 () do i = 1 , nd1p ue_im ( 1 , i ) = ub_im ( 2 , i ) ue_im ( 2 , i ) = - ub_im ( 1 , i ) enddo enddo end subroutine solve_field_eperp_beam end module field_e_class","tags":"","loc":"sourcefile/field_e_class.f03.html"},{"title":"param.f03 – QuickPIC wit Azimuzal Decomposition","text":"Files dependent on this one sourcefile~~param.f03~~AfferentGraph sourcefile~param.f03 param.f03 sourcefile~field_solver_class.f03 field_solver_class.f03 sourcefile~field_solver_class.f03->sourcefile~param.f03 sourcefile~field_e_class.f03 field_e_class.f03 sourcefile~field_e_class.f03->sourcefile~param.f03 sourcefile~field_e_class.f03->sourcefile~field_solver_class.f03 sourcefile~field_src_class.f03 field_src_class.f03 sourcefile~field_e_class.f03->sourcefile~field_src_class.f03 sourcefile~ufield_class.f03 ufield_class.f03 sourcefile~field_e_class.f03->sourcefile~ufield_class.f03 sourcefile~field_b_class.f03 field_b_class.f03 sourcefile~field_e_class.f03->sourcefile~field_b_class.f03 sourcefile~field_class.f03 field_class.f03 sourcefile~field_e_class.f03->sourcefile~field_class.f03 sourcefile~field_psi_class.f03 field_psi_class.f03 sourcefile~field_e_class.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_ez.f03 TEST_field_ez.f03 sourcefile~test_field_ez.f03->sourcefile~param.f03 sourcefile~test_field_ez.f03->sourcefile~field_e_class.f03 sourcefile~test_field_ez.f03->sourcefile~field_src_class.f03 sourcefile~test_field_ez.f03->sourcefile~ufield_class.f03 sourcefile~test_field_ez.f03->sourcefile~field_class.f03 sourcefile~test_field_bz.f03 TEST_field_bz.f03 sourcefile~test_field_bz.f03->sourcefile~param.f03 sourcefile~test_field_bz.f03->sourcefile~field_src_class.f03 sourcefile~test_field_bz.f03->sourcefile~ufield_class.f03 sourcefile~test_field_bz.f03->sourcefile~field_b_class.f03 sourcefile~test_field_bz.f03->sourcefile~field_class.f03 sourcefile~test_field_bperp.f03 TEST_field_bperp.f03 sourcefile~test_field_bperp.f03->sourcefile~param.f03 sourcefile~test_field_bperp.f03->sourcefile~field_src_class.f03 sourcefile~test_field_bperp.f03->sourcefile~ufield_class.f03 sourcefile~test_field_bperp.f03->sourcefile~field_b_class.f03 sourcefile~test_field_bperp.f03->sourcefile~field_class.f03 sourcefile~test_field_eperp.f03 TEST_field_eperp.f03 sourcefile~test_field_eperp.f03->sourcefile~param.f03 sourcefile~test_field_eperp.f03->sourcefile~field_e_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_src_class.f03 sourcefile~test_field_eperp.f03->sourcefile~ufield_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_b_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_bperp_iter.f03 TEST_field_bperp_iter.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~param.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_src_class.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~ufield_class.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_b_class.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_class.f03 sourcefile~field_src_class.f03->sourcefile~param.f03 sourcefile~field_src_class.f03->sourcefile~field_class.f03 sourcefile~ufield_class.f03->sourcefile~param.f03 sourcefile~field_b_class.f03->sourcefile~param.f03 sourcefile~field_b_class.f03->sourcefile~field_solver_class.f03 sourcefile~field_b_class.f03->sourcefile~field_src_class.f03 sourcefile~field_b_class.f03->sourcefile~ufield_class.f03 sourcefile~field_b_class.f03->sourcefile~field_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~param.f03 sourcefile~simulation_class.f03->sourcefile~field_e_class.f03 sourcefile~simulation_class.f03->sourcefile~field_src_class.f03 sourcefile~simulation_class.f03->sourcefile~field_b_class.f03 sourcefile~simulation_class.f03->sourcefile~field_psi_class.f03 sourcefile~field_class.f03->sourcefile~param.f03 sourcefile~field_class.f03->sourcefile~ufield_class.f03 sourcefile~field_psi_class.f03->sourcefile~param.f03 sourcefile~field_psi_class.f03->sourcefile~field_solver_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_src_class.f03 sourcefile~field_psi_class.f03->sourcefile~ufield_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_class.f03 sourcefile~test_field_psi.f03 TEST_field_psi.f03 sourcefile~test_field_psi.f03->sourcefile~param.f03 sourcefile~test_field_psi.f03->sourcefile~field_src_class.f03 sourcefile~test_field_psi.f03->sourcefile~ufield_class.f03 sourcefile~test_field_psi.f03->sourcefile~field_class.f03 sourcefile~test_field_psi.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_eperp_beam.f03 TEST_field_eperp_beam.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~param.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_e_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_src_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~ufield_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_b_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_class.f03 sourcefile~test_ufield.f03 TEST_ufield.f03 sourcefile~test_ufield.f03->sourcefile~ufield_class.f03 var pansourcefileparamf03AfferentGraph = svgPanZoom('#sourcefileparamf03AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules param Source Code param.f03 Source Code module param implicit none public ! ================================================================ ! mathematics ! ================================================================ real , parameter :: pi = 3.14159265359 integer , parameter :: p_real = 0 , p_imag = 1 ! ================================================================ ! dimension related ! ================================================================ integer , parameter :: p_max_xdim = 3 integer , parameter :: p_lower = 1 , p_upper = 2 ! ================================================================ ! particle shape ! ================================================================ integer , parameter :: p_ps_linear = 1 , p_ps_quadratic = 2 ! ================================================================ ! electromagnetic field solver ! ================================================================ ! field solver order integer , parameter :: p_fs_2order = 1 , p_fs_4order = 2 ! boundary condition integer , parameter :: p_bnd_axial = 0 , p_bnd_conduct = 1 ! field kind integer , parameter :: p_fk_psi = 0 , p_fk_ez = 1 , p_fk_bz = 2 , & p_fk_bperp = 3 , p_fk_br_iter = 4 , p_fk_bphi_iter = 5 , & p_fk_bperp_iter = 6 ! ================================================================ ! entity of electromagnetic field ! ================================================================ integer , parameter :: p_entity_none = 0 , p_entity_beam = 1 , p_entity_plasma = 2 ! ================================================================ ! HYPRE parameters ! ================================================================ integer , parameter :: HYPRE_TYPE = 8 , HYPRE_PARCSR = 5555 integer , parameter :: p_hypre_cycred = 1 , p_hypre_pcg = 2 , p_hypre_smg = 3 , & p_hypre_gmres = 4 , p_hypre_amg = 5 , p_hypre_parpcg = 6 ! ================================================================ ! copy field, used by ufield class ! ================================================================ integer , parameter :: p_copy_1to2 = 1 , p_copy_2to1 = - 1 end module param","tags":"","loc":"sourcefile/param.f03.html"},{"title":"field_class.f03 – QuickPIC wit Azimuzal Decomposition","text":"This file depends on sourcefile~~field_class.f03~~EfferentGraph sourcefile~field_class.f03 field_class.f03 sourcefile~param.f03 param.f03 sourcefile~field_class.f03->sourcefile~param.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~field_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~system.f03 system.f03 sourcefile~field_class.f03->sourcefile~system.f03 sourcefile~grid_class.f03 grid_class.f03 sourcefile~field_class.f03->sourcefile~grid_class.f03 sourcefile~ufield_class.f03 ufield_class.f03 sourcefile~field_class.f03->sourcefile~ufield_class.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~grid_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~grid_class.f03->sourcefile~system.f03 sourcefile~ufield_class.f03->sourcefile~param.f03 sourcefile~ufield_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield_class.f03->sourcefile~system.f03 sourcefile~ufield_class.f03->sourcefile~grid_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~field_class.f03~~AfferentGraph sourcefile~field_class.f03 field_class.f03 sourcefile~test_field_bperp.f03 TEST_field_bperp.f03 sourcefile~test_field_bperp.f03->sourcefile~field_class.f03 sourcefile~field_src_class.f03 field_src_class.f03 sourcefile~test_field_bperp.f03->sourcefile~field_src_class.f03 sourcefile~field_b_class.f03 field_b_class.f03 sourcefile~test_field_bperp.f03->sourcefile~field_b_class.f03 sourcefile~field_e_class.f03 field_e_class.f03 sourcefile~field_e_class.f03->sourcefile~field_class.f03 sourcefile~field_e_class.f03->sourcefile~field_src_class.f03 sourcefile~field_e_class.f03->sourcefile~field_b_class.f03 sourcefile~field_psi_class.f03 field_psi_class.f03 sourcefile~field_e_class.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_ez.f03 TEST_field_ez.f03 sourcefile~test_field_ez.f03->sourcefile~field_class.f03 sourcefile~test_field_ez.f03->sourcefile~field_e_class.f03 sourcefile~test_field_ez.f03->sourcefile~field_src_class.f03 sourcefile~test_field_bz.f03 TEST_field_bz.f03 sourcefile~test_field_bz.f03->sourcefile~field_class.f03 sourcefile~test_field_bz.f03->sourcefile~field_src_class.f03 sourcefile~test_field_bz.f03->sourcefile~field_b_class.f03 sourcefile~test_field_eperp.f03 TEST_field_eperp.f03 sourcefile~test_field_eperp.f03->sourcefile~field_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_e_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_src_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_b_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_bperp_iter.f03 TEST_field_bperp_iter.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_class.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_src_class.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_b_class.f03 sourcefile~field_src_class.f03->sourcefile~field_class.f03 sourcefile~field_b_class.f03->sourcefile~field_class.f03 sourcefile~field_b_class.f03->sourcefile~field_src_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_src_class.f03 sourcefile~test_field_psi.f03 TEST_field_psi.f03 sourcefile~test_field_psi.f03->sourcefile~field_class.f03 sourcefile~test_field_psi.f03->sourcefile~field_src_class.f03 sourcefile~test_field_psi.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_eperp_beam.f03 TEST_field_eperp_beam.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_e_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_src_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_b_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~field_e_class.f03 sourcefile~simulation_class.f03->sourcefile~field_src_class.f03 sourcefile~simulation_class.f03->sourcefile~field_b_class.f03 sourcefile~simulation_class.f03->sourcefile~field_psi_class.f03 var pansourcefilefield_classf03AfferentGraph = svgPanZoom('#sourcefilefield_classf03AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules field_class Source Code field_class.f03 Source Code module field_class use parallel_pipe_class use grid_class use ufield_class use param use system implicit none private public :: field character ( len = 20 ), parameter :: cls_name = \"field\" integer , parameter :: cls_level = 1 type :: field ! private class ( ufield ), dimension (:), pointer :: rf_re => null () class ( ufield ), dimension (:), pointer :: rf_im => null () ! class( emf_solver ) :: solver real :: dr , dxi integer :: num_modes integer :: entity contains generic :: new => init_field ! generic :: read_input => read_input_field procedure :: del => end_field generic :: get_rf_re => get_rf_re_all , get_rf_re_mode generic :: get_rf_im => get_rf_im_all , get_rf_im_mode ! generic :: solve => solve_field ! generic :: write_hdf5 ! generic :: smooth procedure :: get_dr , get_dxi , get_num_modes procedure , private :: init_field , end_field procedure , private :: get_rf_re_all , get_rf_re_mode , get_rf_im_all , get_rf_im_mode ! procedure :: read_input_field end type field contains ! ===================================================================== ! Class field implementation ! ===================================================================== subroutine init_field ( this , pp , gp , dim , dr , dxi , num_modes , gc_num , entity ) implicit none class ( field ), intent ( inout ) :: this class ( parallel_pipe ), intent ( in ), pointer :: pp class ( grid ), intent ( in ), pointer :: gp integer , intent ( in ) :: num_modes , dim real , intent ( in ) :: dr , dxi integer , intent ( in ), dimension ( 2 , 2 ) :: gc_num integer , intent ( in ), optional :: entity integer :: i character ( len = 20 ), save :: sname = \"init_field\" call write_dbg ( cls_name , sname , cls_level , 'starts' ) this % num_modes = num_modes this % dr = dr this % dxi = dxi if ( present ( entity ) ) then this % entity = entity else this % entity = p_entity_none endif allocate ( this % rf_re ( 0 : num_modes ) ) allocate ( this % rf_im ( num_modes ) ) call this % rf_re ( 0 )% new ( pp , gp , dim , gc_num , has_2d = . true . ) do i = 1 , this % num_modes call this % rf_re ( i )% new ( pp , gp , dim , gc_num , has_2d = . true . ) call this % rf_im ( i )% new ( pp , gp , dim , gc_num , has_2d = . true . ) enddo call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine init_field subroutine end_field ( this ) implicit none class ( field ), intent ( inout ) :: this integer :: i character ( len = 20 ), save :: sname = \"end_field\" call write_dbg ( cls_name , sname , cls_level , 'starts' ) call this % rf_re ( 0 )% del () do i = 1 , this % num_modes call this % rf_re ( i )% del () call this % rf_im ( i )% del () enddo deallocate ( this % rf_re , this % rf_im ) call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine end_field function get_dr ( this ) implicit none class ( field ), intent ( in ) :: this real :: get_dr get_dr = this % dr end function get_dr function get_dxi ( this ) implicit none class ( field ), intent ( in ) :: this real :: get_dxi get_dxi = this % dxi end function get_dxi function get_num_modes ( this ) implicit none class ( field ), intent ( in ) :: this integer :: get_num_modes get_num_modes = this % num_modes end function get_num_modes function get_rf_re_all ( this ) implicit none class ( field ), intent ( in ) :: this type ( ufield ), dimension (:), pointer :: get_rf_re_all get_rf_re_all => this % rf_re end function get_rf_re_all function get_rf_re_mode ( this , mode ) implicit none class ( field ), intent ( in ) :: this integer , intent ( in ) :: mode type ( ufield ), pointer :: get_rf_re_mode get_rf_re_mode => this % rf_re ( mode ) end function get_rf_re_mode function get_rf_im_all ( this ) implicit none class ( field ), intent ( in ) :: this type ( ufield ), dimension (:), pointer :: get_rf_im_all get_rf_im_all => this % rf_im end function get_rf_im_all function get_rf_im_mode ( this , mode ) implicit none class ( field ), intent ( in ) :: this integer , intent ( in ) :: mode type ( ufield ), pointer :: get_rf_im_mode get_rf_im_mode => this % rf_im ( mode ) end function get_rf_im_mode end module field_class","tags":"","loc":"sourcefile/field_class.f03.html"},{"title":"system.f03 – QuickPIC wit Azimuzal Decomposition","text":"Files dependent on this one sourcefile~~system.f03~~AfferentGraph sourcefile~system.f03 system.f03 sourcefile~field_solver_class.f03 field_solver_class.f03 sourcefile~field_solver_class.f03->sourcefile~system.f03 sourcefile~field_e_class.f03 field_e_class.f03 sourcefile~field_e_class.f03->sourcefile~system.f03 sourcefile~field_e_class.f03->sourcefile~field_solver_class.f03 sourcefile~grid_class.f03 grid_class.f03 sourcefile~field_e_class.f03->sourcefile~grid_class.f03 sourcefile~field_src_class.f03 field_src_class.f03 sourcefile~field_e_class.f03->sourcefile~field_src_class.f03 sourcefile~ufield_class.f03 ufield_class.f03 sourcefile~field_e_class.f03->sourcefile~ufield_class.f03 sourcefile~field_b_class.f03 field_b_class.f03 sourcefile~field_e_class.f03->sourcefile~field_b_class.f03 sourcefile~field_class.f03 field_class.f03 sourcefile~field_e_class.f03->sourcefile~field_class.f03 sourcefile~field_psi_class.f03 field_psi_class.f03 sourcefile~field_e_class.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_ez.f03 TEST_field_ez.f03 sourcefile~test_field_ez.f03->sourcefile~system.f03 sourcefile~test_field_ez.f03->sourcefile~field_e_class.f03 sourcefile~test_field_ez.f03->sourcefile~field_src_class.f03 sourcefile~test_field_ez.f03->sourcefile~ufield_class.f03 sourcefile~test_field_ez.f03->sourcefile~field_class.f03 sourcefile~test_field_bz.f03 TEST_field_bz.f03 sourcefile~test_field_bz.f03->sourcefile~system.f03 sourcefile~test_field_bz.f03->sourcefile~field_src_class.f03 sourcefile~test_field_bz.f03->sourcefile~ufield_class.f03 sourcefile~test_field_bz.f03->sourcefile~field_b_class.f03 sourcefile~test_field_bz.f03->sourcefile~field_class.f03 sourcefile~test_field_bperp.f03 TEST_field_bperp.f03 sourcefile~test_field_bperp.f03->sourcefile~system.f03 sourcefile~test_field_bperp.f03->sourcefile~field_src_class.f03 sourcefile~test_field_bperp.f03->sourcefile~ufield_class.f03 sourcefile~test_field_bperp.f03->sourcefile~field_b_class.f03 sourcefile~test_field_bperp.f03->sourcefile~field_class.f03 sourcefile~test_field_eperp.f03 TEST_field_eperp.f03 sourcefile~test_field_eperp.f03->sourcefile~system.f03 sourcefile~test_field_eperp.f03->sourcefile~field_e_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_src_class.f03 sourcefile~test_field_eperp.f03->sourcefile~ufield_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_b_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_psi_class.f03 sourcefile~grid_class.f03->sourcefile~system.f03 sourcefile~test_field_bperp_iter.f03 TEST_field_bperp_iter.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~system.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_src_class.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~ufield_class.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_b_class.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_class.f03 sourcefile~field_src_class.f03->sourcefile~system.f03 sourcefile~field_src_class.f03->sourcefile~grid_class.f03 sourcefile~field_src_class.f03->sourcefile~field_class.f03 sourcefile~ufield_class.f03->sourcefile~system.f03 sourcefile~ufield_class.f03->sourcefile~grid_class.f03 sourcefile~field_b_class.f03->sourcefile~system.f03 sourcefile~field_b_class.f03->sourcefile~field_solver_class.f03 sourcefile~field_b_class.f03->sourcefile~grid_class.f03 sourcefile~field_b_class.f03->sourcefile~field_src_class.f03 sourcefile~field_b_class.f03->sourcefile~ufield_class.f03 sourcefile~field_b_class.f03->sourcefile~field_class.f03 sourcefile~input_class.f03 input_class.f03 sourcefile~input_class.f03->sourcefile~system.f03 sourcefile~input_class.f03->sourcefile~grid_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~system.f03 sourcefile~simulation_class.f03->sourcefile~field_e_class.f03 sourcefile~simulation_class.f03->sourcefile~grid_class.f03 sourcefile~simulation_class.f03->sourcefile~field_src_class.f03 sourcefile~simulation_class.f03->sourcefile~field_b_class.f03 sourcefile~simulation_class.f03->sourcefile~input_class.f03 sourcefile~simulation_class.f03->sourcefile~field_psi_class.f03 sourcefile~field_class.f03->sourcefile~system.f03 sourcefile~field_class.f03->sourcefile~grid_class.f03 sourcefile~field_class.f03->sourcefile~ufield_class.f03 sourcefile~field_psi_class.f03->sourcefile~system.f03 sourcefile~field_psi_class.f03->sourcefile~field_solver_class.f03 sourcefile~field_psi_class.f03->sourcefile~grid_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_src_class.f03 sourcefile~field_psi_class.f03->sourcefile~ufield_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_class.f03 sourcefile~test_field_psi.f03 TEST_field_psi.f03 sourcefile~test_field_psi.f03->sourcefile~system.f03 sourcefile~test_field_psi.f03->sourcefile~field_src_class.f03 sourcefile~test_field_psi.f03->sourcefile~ufield_class.f03 sourcefile~test_field_psi.f03->sourcefile~field_class.f03 sourcefile~test_field_psi.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_eperp_beam.f03 TEST_field_eperp_beam.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~system.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_e_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_src_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~ufield_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_b_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_class.f03 sourcefile~test_ufield.f03 TEST_ufield.f03 sourcefile~test_ufield.f03->sourcefile~ufield_class.f03 var pansourcefilesystemf03AfferentGraph = svgPanZoom('#sourcefilesystemf03AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules system Source Code system.f03 Source Code module system implicit none private public :: init_errors , end_errors , write_err , write_wrn , write_dbg integer , save :: class_monitor = 0 integer , save :: fid integer , dimension ( 4 ), save :: itime double precision , save :: dtime interface init_errors module procedure init_errors end interface interface end_errors module procedure end_errors end interface interface write_err module procedure write_err end interface interface write_wrn module procedure write_wrn end interface interface write_dbg module procedure write_dbg end interface contains subroutine init_errors ( eunit , monitor ) implicit none ! class( parallel ), intent(in), pointer :: prl integer , intent ( in ) :: eunit , monitor fid = eunit class_monitor = monitor call system ( 'mkdir ./ELOG' ) open ( unit = fid , file = './ELOG/elog-000' , form = 'formatted' , status = 'replace' ) call dtimer ( dtime , itime , - 1 ) end subroutine init_errors subroutine end_errors () implicit none close ( unit = fid ) end subroutine subroutine write_err ( estr ) implicit none character ( len =* ), intent ( in ) :: estr call dtimer ( dtime , itime , 1 ) write ( fid , '(A, F12.3, A12, A)' ) 't = ' , dtime , ', [ERROR] ' , trim ( adjustl ( estr )) stop end subroutine write_err subroutine write_wrn ( wstr ) implicit none character ( len =* ), intent ( in ) :: wstr call dtimer ( dtime , itime , 1 ) write ( fid , '(A, F12.3, A12, A)' ) 't = ' , dtime , ', [WARNING] ' , trim ( adjustl ( wstr )) end subroutine write_wrn subroutine write_dbg ( clsname , sname , level , msg ) implicit none character ( len =* ), intent ( in ) :: clsname , sname integer , intent ( in ) :: level character ( len =* ), intent ( in ), optional :: msg character ( len = 32 ) , save :: prefix character ( len = 128 ), save :: str integer :: i call dtimer ( dtime , itime , 1 ) if ( level <= class_monitor ) then if ( level >= 1 ) then i = 1 prefix = '' do while ( i < ( level - 1 ) * 3 ) prefix ( i : i + 2 ) = '|  ' i = i + 3 enddo prefix ( i : i + 2 ) = '|--' else prefix = '' endif str = '' write ( str , '(A, F12.3, A12, A, A, A, A)' ) & 't = ' , dtime , ', [DEBUG] ' , trim ( prefix ), trim ( clsname ), ' -> ' , trim ( sname ) if ( present ( msg ) ) then write ( fid , * ) trim ( str ) // ': ' // trim ( msg ) else write ( fid , * ) trim ( str ) endif flush ( fid ) endif end subroutine write_dbg end module system","tags":"","loc":"sourcefile/system.f03.html"},{"title":"debug_tool.f03 – QuickPIC wit Azimuzal Decomposition","text":"Files dependent on this one sourcefile~~debug_tool.f03~~AfferentGraph sourcefile~debug_tool.f03 debug_tool.f03 sourcefile~field_solver_class.f03 field_solver_class.f03 sourcefile~field_solver_class.f03->sourcefile~debug_tool.f03 sourcefile~test_field_bz.f03 TEST_field_bz.f03 sourcefile~test_field_bz.f03->sourcefile~debug_tool.f03 sourcefile~field_b_class.f03 field_b_class.f03 sourcefile~test_field_bz.f03->sourcefile~field_b_class.f03 sourcefile~test_field_ez.f03 TEST_field_ez.f03 sourcefile~test_field_ez.f03->sourcefile~debug_tool.f03 sourcefile~field_e_class.f03 field_e_class.f03 sourcefile~test_field_ez.f03->sourcefile~field_e_class.f03 sourcefile~test_field_bperp.f03 TEST_field_bperp.f03 sourcefile~test_field_bperp.f03->sourcefile~debug_tool.f03 sourcefile~test_field_bperp.f03->sourcefile~field_b_class.f03 sourcefile~test_field_eperp.f03 TEST_field_eperp.f03 sourcefile~test_field_eperp.f03->sourcefile~debug_tool.f03 sourcefile~test_field_eperp.f03->sourcefile~field_b_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_e_class.f03 sourcefile~field_psi_class.f03 field_psi_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_bperp_iter.f03 TEST_field_bperp_iter.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~debug_tool.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_b_class.f03 sourcefile~field_b_class.f03->sourcefile~debug_tool.f03 sourcefile~field_b_class.f03->sourcefile~field_solver_class.f03 sourcefile~test_field_psi.f03 TEST_field_psi.f03 sourcefile~test_field_psi.f03->sourcefile~debug_tool.f03 sourcefile~test_field_psi.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_eperp_beam.f03 TEST_field_eperp_beam.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~debug_tool.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_b_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_e_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~field_b_class.f03 sourcefile~simulation_class.f03->sourcefile~field_e_class.f03 sourcefile~simulation_class.f03->sourcefile~field_psi_class.f03 sourcefile~field_e_class.f03->sourcefile~field_solver_class.f03 sourcefile~field_e_class.f03->sourcefile~field_b_class.f03 sourcefile~field_e_class.f03->sourcefile~field_psi_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_solver_class.f03 var pansourcefiledebug_toolf03AfferentGraph = svgPanZoom('#sourcefiledebug_toolf03AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules debug_tool Source Code debug_tool.f03 Source Code module debug_tool implicit none public interface write_data module procedure write_data1d module procedure write_data2d module procedure write_array end interface write_data public :: write_data contains subroutine write_array ( f , fname ) implicit none real , intent ( in ), dimension (:), pointer :: f character ( len =* ), intent ( in ) :: fname ! integer :: i1, i2, i integer :: unit = 99 character ( len = 128 ) :: fmtstr , num2str ! i1 = lbound(f,2) ! i2 = ubound(f,2) write ( num2str , * ) size ( f ) write ( fmtstr , * ) '(' // trim ( num2str ) // 'f20.8)' open ( unit , file = trim ( fname ) ) ! do i = i1, i2 write ( unit , trim ( fmtstr ) ) f (:) ! enddo close ( unit ) end subroutine write_array subroutine write_data1d ( f , fname , dim ) implicit none real , intent ( in ), dimension (:,:), pointer :: f character ( len =* ), intent ( in ) :: fname integer , intent ( in ) :: dim ! integer :: i1, i2, i integer :: unit = 99 character ( len = 128 ) :: fmtstr , num2str ! i1 = lbound(f,2) ! i2 = ubound(f,2) write ( num2str , * ) size ( f , 2 ) write ( fmtstr , * ) '(' // trim ( num2str ) // 'f20.8)' open ( unit , file = trim ( fname ) ) ! do i = i1, i2 write ( unit , trim ( fmtstr ) ) f ( dim ,:) ! enddo close ( unit ) end subroutine write_data1d subroutine write_data2d ( f , fname , dim ) implicit none real , intent ( in ), dimension (:,:,:), pointer :: f character ( len =* ), intent ( in ) :: fname integer , intent ( in ) :: dim integer :: i1 , i2 , i integer :: unit = 2 character ( len = 128 ) :: fmtstr , num2str i1 = lbound ( f , 2 ) i2 = ubound ( f , 2 ) write ( num2str , * ) size ( f , 3 ) write ( fmtstr , * ) '(' // trim ( num2str ) // 'f20.8)' open ( unit , file = trim ( fname ) ) do i = i1 , i2 write ( unit , trim ( fmtstr ) ) f ( dim , i ,:) enddo close ( unit ) end subroutine write_data2d end module debug_tool","tags":"","loc":"sourcefile/debug_tool.f03.html"},{"title":"parallel_class.f03 – QuickPIC wit Azimuzal Decomposition","text":"Files dependent on this one sourcefile~~parallel_class.f03~~AfferentGraph sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~parallel_class.f03 sourcefile~input_class.f03 input_class.f03 sourcefile~simulation_class.f03->sourcefile~input_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~simulation_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_e_class.f03 field_e_class.f03 sourcefile~simulation_class.f03->sourcefile~field_e_class.f03 sourcefile~grid_class.f03 grid_class.f03 sourcefile~simulation_class.f03->sourcefile~grid_class.f03 sourcefile~field_src_class.f03 field_src_class.f03 sourcefile~simulation_class.f03->sourcefile~field_src_class.f03 sourcefile~field_b_class.f03 field_b_class.f03 sourcefile~simulation_class.f03->sourcefile~field_b_class.f03 sourcefile~field_psi_class.f03 field_psi_class.f03 sourcefile~simulation_class.f03->sourcefile~field_psi_class.f03 sourcefile~input_class.f03->sourcefile~parallel_class.f03 sourcefile~input_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~input_class.f03->sourcefile~grid_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~field_e_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_e_class.f03->sourcefile~grid_class.f03 sourcefile~field_e_class.f03->sourcefile~field_src_class.f03 sourcefile~ufield_class.f03 ufield_class.f03 sourcefile~field_e_class.f03->sourcefile~ufield_class.f03 sourcefile~field_e_class.f03->sourcefile~field_b_class.f03 sourcefile~field_class.f03 field_class.f03 sourcefile~field_e_class.f03->sourcefile~field_class.f03 sourcefile~field_e_class.f03->sourcefile~field_psi_class.f03 sourcefile~grid_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_src_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_src_class.f03->sourcefile~grid_class.f03 sourcefile~field_src_class.f03->sourcefile~field_class.f03 sourcefile~ufield_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield_class.f03->sourcefile~grid_class.f03 sourcefile~field_b_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_b_class.f03->sourcefile~grid_class.f03 sourcefile~field_b_class.f03->sourcefile~field_src_class.f03 sourcefile~field_b_class.f03->sourcefile~ufield_class.f03 sourcefile~field_b_class.f03->sourcefile~field_class.f03 sourcefile~field_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_class.f03->sourcefile~grid_class.f03 sourcefile~field_class.f03->sourcefile~ufield_class.f03 sourcefile~field_psi_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_psi_class.f03->sourcefile~grid_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_src_class.f03 sourcefile~field_psi_class.f03->sourcefile~ufield_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_class.f03 sourcefile~test_field_bperp.f03 TEST_field_bperp.f03 sourcefile~test_field_bperp.f03->sourcefile~field_src_class.f03 sourcefile~test_field_bperp.f03->sourcefile~ufield_class.f03 sourcefile~test_field_bperp.f03->sourcefile~field_b_class.f03 sourcefile~test_field_bperp.f03->sourcefile~field_class.f03 sourcefile~test_field_ez.f03 TEST_field_ez.f03 sourcefile~test_field_ez.f03->sourcefile~field_e_class.f03 sourcefile~test_field_ez.f03->sourcefile~field_src_class.f03 sourcefile~test_field_ez.f03->sourcefile~ufield_class.f03 sourcefile~test_field_ez.f03->sourcefile~field_class.f03 sourcefile~test_field_bz.f03 TEST_field_bz.f03 sourcefile~test_field_bz.f03->sourcefile~field_src_class.f03 sourcefile~test_field_bz.f03->sourcefile~ufield_class.f03 sourcefile~test_field_bz.f03->sourcefile~field_b_class.f03 sourcefile~test_field_bz.f03->sourcefile~field_class.f03 sourcefile~test_ufield.f03 TEST_ufield.f03 sourcefile~test_ufield.f03->sourcefile~ufield_class.f03 sourcefile~test_field_eperp.f03 TEST_field_eperp.f03 sourcefile~test_field_eperp.f03->sourcefile~field_e_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_src_class.f03 sourcefile~test_field_eperp.f03->sourcefile~ufield_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_b_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_bperp_iter.f03 TEST_field_bperp_iter.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_src_class.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~ufield_class.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_b_class.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_class.f03 sourcefile~test_field_psi.f03 TEST_field_psi.f03 sourcefile~test_field_psi.f03->sourcefile~field_src_class.f03 sourcefile~test_field_psi.f03->sourcefile~ufield_class.f03 sourcefile~test_field_psi.f03->sourcefile~field_class.f03 sourcefile~test_field_psi.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_eperp_beam.f03 TEST_field_eperp_beam.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_e_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_src_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~ufield_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_b_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_class.f03 var pansourcefileparallel_classf03AfferentGraph = svgPanZoom('#sourcefileparallel_classf03AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules parallel_class Source Code parallel_class.f03 Source Code module parallel_class use mpi use omp_lib implicit none private public :: parallel type parallel private ! nvp: number of MPI nodes ! idproc: processor id ! kstrt: idproc+1 ! mreal = default datatype for reals ! mint = default datatype for integers ! mcplx = default datatype for complex type ! mdouble = default double precision type ! lworld = MPI_COMM_WORLD communicator integer :: nvp integer :: idproc integer :: kstrt integer :: mreal , mint , mcplx , mdouble , mchar , lworld contains generic :: new => init_parallel generic :: del => end_parallel procedure :: getnvp procedure :: getidproc procedure :: getkstrt procedure :: getlworld procedure :: getmreal procedure :: getmint procedure :: getmdouble procedure :: getmcplx procedure :: getmchar procedure , private :: init_parallel procedure , private :: end_parallel end type parallel contains ! function getnvp ( this ) implicit none class ( parallel ), intent ( in ) :: this integer :: getnvp getnvp = this % nvp end function getnvp ! function getidproc ( this ) implicit none class ( parallel ), intent ( in ) :: this integer :: getidproc getidproc = this % idproc end function getidproc ! function getkstrt ( this ) implicit none class ( parallel ), intent ( in ) :: this integer :: getkstrt getkstrt = this % kstrt end function getkstrt ! function getlworld ( this ) implicit none class ( parallel ), intent ( in ) :: this integer :: getlworld getlworld = this % lworld end function getlworld ! function getmint ( this ) implicit none class ( parallel ), intent ( in ) :: this integer :: getmint getmint = this % mint end function getmint ! function getmreal ( this ) implicit none class ( parallel ), intent ( in ) :: this integer :: getmreal getmreal = this % mreal end function getmreal ! function getmdouble ( this ) implicit none class ( parallel ), intent ( in ) :: this integer :: getmdouble getmdouble = this % mdouble end function getmdouble ! function getmcplx ( this ) implicit none class ( parallel ), intent ( in ) :: this integer :: getmcplx getmcplx = this % mcplx end function getmcplx ! function getmchar ( this ) implicit none class ( parallel ), intent ( in ) :: this integer :: getmchar getmchar = this % mchar end function getmchar ! subroutine init_parallel ( this ) implicit none class ( parallel ), intent ( inout ) :: this ! nvpp = number of shared memory threads (0=default) integer :: nvpp = 0 ! initialize for shared memory parallel processing using openmp call init_omp ( nvpp ) ! initialize for distributed memory parallel processing using mpi call ppinit2 ( this % idproc , this % nvp , this % lworld ,& & this % mint , this % mreal , this % mdouble , this % mcplx , this % mchar ) this % kstrt = this % idproc + 1 end subroutine init_parallel ! subroutine ppinit2 ( idproc , nvp , lworld , mint , mreal , mdouble , mcplx , mchar ) ! this subroutine initializes parallel processing using mpi implicit none integer , intent ( inout ) :: idproc , nvp integer , intent ( inout ) :: lworld , mint , mreal , mdouble , mcplx , mchar ! nproc = number of real or virtual processors obtained ! mreal = default datatype for reals ! mint = default datatype for integers ! mcplx = default datatype for complex type ! mdouble = default double precision type ! mchar = default datatype for character type ! lworld = MPI_COMM_WORLD communicator ! local data integer :: ierror , ndprec , idprec integer :: iprec logical :: flag real :: prec integer :: nproc ! ndprec = (0,1) = (no,yes) use (normal,autodouble) precision if ( digits ( prec ) > 24 ) then ndprec = 1 else ndprec = 0 endif ! idprec = (0,1) = (no,yes) use (normal,autodouble) integer precision if ( digits ( iprec ) > 31 ) then idprec = 1 else idprec = 0 endif ! this segment is used for mpi computers ! indicate whether MPI_INIT has been called call MPI_INITIALIZED ( flag , ierror ) if (. not . flag ) then ! initialize the MPI execution environment call MPI_INIT ( ierror ) if ( ierror /= 0 ) stop endif lworld = MPI_COMM_WORLD ! determine the rank of the calling process in the communicator call MPI_COMM_RANK ( lworld , idproc , ierror ) ! determine the size of the group associated with a communicator call MPI_COMM_SIZE ( lworld , nproc , ierror ) ! set default datatypes mint = MPI_INTEGER mdouble = MPI_DOUBLE_PRECISION mchar = MPI_CHARACTER ! single precision real if ( ndprec == 0 ) then mreal = MPI_REAL mcplx = MPI_COMPLEX ! double precision real else mreal = MPI_DOUBLE_PRECISION mcplx = MPI_DOUBLE_COMPLEX endif ! single precision integer !     if (idprec==0) then !        mint = MPI_INTEGER ! double precision integer !     else !        mint = MPI_INTEGER8 !     endif ! operators nvp = nproc end subroutine ppinit2 ! subroutine init_omp ( nth ) ! initialize openmp library ! use nth threads if nth > 0; otherwise, use the number found implicit none integer , intent ( in ) :: nth ! local data integer :: ncpus , nthreads , tid ! determine how many processors are available ncpus = omp_get_num_procs () nthreads = omp_get_max_threads () if ( nth > 0 ) nthreads = nth call omp_set_num_threads ( nthreads ) !$OMP PARALLEL PRIVATE(tid) tid = OMP_GET_THREAD_NUM () !$OMP END PARALLEL end subroutine init_omp ! subroutine end_parallel ( this ) ! this subroutine terminates parallel processing implicit none class ( parallel ), intent ( inout ) :: this ! lworld = MPI_COMM_WORLD communicator ! local data integer :: ierror logical :: flag ! indicate whether MPI_INIT has been called call MPI_INITIALIZED ( flag , ierror ) if ( flag ) then ! synchronize processes call MPI_BARRIER ( this % getlworld (), ierror ) ! terminate MPI execution environment call MPI_FINALIZE ( ierror ) endif end subroutine end_parallel ! end module parallel_class","tags":"","loc":"sourcefile/parallel_class.f03.html"},{"title":"field_src_class.f03 – QuickPIC wit Azimuzal Decomposition","text":"This file depends on sourcefile~~field_src_class.f03~~EfferentGraph sourcefile~field_src_class.f03 field_src_class.f03 sourcefile~param.f03 param.f03 sourcefile~field_src_class.f03->sourcefile~param.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~field_src_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~system.f03 system.f03 sourcefile~field_src_class.f03->sourcefile~system.f03 sourcefile~grid_class.f03 grid_class.f03 sourcefile~field_src_class.f03->sourcefile~grid_class.f03 sourcefile~field_class.f03 field_class.f03 sourcefile~field_src_class.f03->sourcefile~field_class.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~grid_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~grid_class.f03->sourcefile~system.f03 sourcefile~field_class.f03->sourcefile~param.f03 sourcefile~field_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_class.f03->sourcefile~system.f03 sourcefile~field_class.f03->sourcefile~grid_class.f03 sourcefile~ufield_class.f03 ufield_class.f03 sourcefile~field_class.f03->sourcefile~ufield_class.f03 sourcefile~ufield_class.f03->sourcefile~param.f03 sourcefile~ufield_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield_class.f03->sourcefile~system.f03 sourcefile~ufield_class.f03->sourcefile~grid_class.f03 var pansourcefilefield_src_classf03EfferentGraph = svgPanZoom('#sourcefilefield_src_classf03EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~field_src_class.f03~~AfferentGraph sourcefile~field_src_class.f03 field_src_class.f03 sourcefile~test_field_bperp.f03 TEST_field_bperp.f03 sourcefile~test_field_bperp.f03->sourcefile~field_src_class.f03 sourcefile~field_b_class.f03 field_b_class.f03 sourcefile~test_field_bperp.f03->sourcefile~field_b_class.f03 sourcefile~field_e_class.f03 field_e_class.f03 sourcefile~field_e_class.f03->sourcefile~field_src_class.f03 sourcefile~field_e_class.f03->sourcefile~field_b_class.f03 sourcefile~field_psi_class.f03 field_psi_class.f03 sourcefile~field_e_class.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_ez.f03 TEST_field_ez.f03 sourcefile~test_field_ez.f03->sourcefile~field_src_class.f03 sourcefile~test_field_ez.f03->sourcefile~field_e_class.f03 sourcefile~test_field_bz.f03 TEST_field_bz.f03 sourcefile~test_field_bz.f03->sourcefile~field_src_class.f03 sourcefile~test_field_bz.f03->sourcefile~field_b_class.f03 sourcefile~test_field_eperp.f03 TEST_field_eperp.f03 sourcefile~test_field_eperp.f03->sourcefile~field_src_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_e_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_b_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_bperp_iter.f03 TEST_field_bperp_iter.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_src_class.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_b_class.f03 sourcefile~field_b_class.f03->sourcefile~field_src_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~field_src_class.f03 sourcefile~simulation_class.f03->sourcefile~field_e_class.f03 sourcefile~simulation_class.f03->sourcefile~field_b_class.f03 sourcefile~simulation_class.f03->sourcefile~field_psi_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_src_class.f03 sourcefile~test_field_psi.f03 TEST_field_psi.f03 sourcefile~test_field_psi.f03->sourcefile~field_src_class.f03 sourcefile~test_field_psi.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_eperp_beam.f03 TEST_field_eperp_beam.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_src_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_e_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_b_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules field_src_class Source Code field_src_class.f03 Source Code module field_src_class use field_class use parallel_pipe_class use grid_class use param use system implicit none private character ( len = 20 ), parameter :: cls_name = \"field_src\" integer , parameter :: cls_level = 1 public :: field_rho , field_jay , field_djdxi type , extends ( field ) :: field_rho contains generic :: new => init_field_rho procedure , private :: init_field_rho end type field_rho type , extends ( field ) :: field_jay contains generic :: new => init_field_jay procedure , private :: init_field_jay end type field_jay type , extends ( field ) :: field_djdxi contains generic :: new => init_field_djdxi procedure , private :: init_field_djdxi end type field_djdxi contains subroutine init_field_rho ( this , pp , gp , dr , dxi , num_modes , part_shape ) implicit none class ( field_rho ), intent ( inout ) :: this class ( parallel_pipe ), intent ( in ), pointer :: pp class ( grid ), intent ( in ), pointer :: gp integer , intent ( in ) :: num_modes , part_shape real , intent ( in ) :: dr , dxi integer , dimension ( 2 , 2 ) :: gc_num integer :: dim , i character ( len = 20 ), save :: sname = \"init_field_rho\" call write_dbg ( cls_name , sname , cls_level , 'starts' ) select case ( part_shape ) case ( p_ps_linear ) gc_num (:, 1 ) = ( / 0 , 1 / ) gc_num (:, 2 ) = ( / 0 , 1 / ) case ( p_ps_quadratic ) call write_err ( \"Quadratic particle shape not implemented.\" ) case default call write_err ( \"Invalid particle shape.\" ) end select dim = 1 ! call initialization routine of the parent class call this % field % new ( pp , gp , dim , dr , dxi , num_modes , gc_num ) call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine init_field_rho subroutine init_field_jay ( this , pp , gp , dr , dxi , num_modes , part_shape ) implicit none class ( field_jay ), intent ( inout ) :: this class ( parallel_pipe ), intent ( in ), pointer :: pp class ( grid ), intent ( in ), pointer :: gp integer , intent ( in ) :: num_modes , part_shape real , intent ( in ) :: dr , dxi integer , dimension ( 2 , 2 ) :: gc_num integer :: dim , i character ( len = 20 ), save :: sname = \"init_field_jay\" call write_dbg ( cls_name , sname , cls_level , 'starts' ) select case ( part_shape ) case ( p_ps_linear ) gc_num (:, 1 ) = ( / 0 , 1 / ) gc_num (:, 2 ) = ( / 0 , 1 / ) case ( p_ps_quadratic ) call write_err ( \"Quadratic particle shape not implemented.\" ) case default call write_err ( \"Invalid particle shape.\" ) end select dim = 3 ! call initialization routine of the parent class call this % field % new ( pp , gp , dim , dr , dxi , num_modes , gc_num ) call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine init_field_jay subroutine init_field_djdxi ( this , pp , gp , dr , dxi , num_modes , part_shape ) implicit none class ( field_djdxi ), intent ( inout ) :: this class ( parallel_pipe ), intent ( in ), pointer :: pp class ( grid ), intent ( in ), pointer :: gp integer , intent ( in ) :: num_modes , part_shape real , intent ( in ) :: dr , dxi integer , dimension ( 2 , 2 ) :: gc_num integer :: dim , i character ( len = 20 ), save :: sname = \"init_field_djdxi\" call write_dbg ( cls_name , sname , cls_level , 'starts' ) select case ( part_shape ) case ( p_ps_linear ) gc_num (:, 1 ) = ( / 0 , 1 / ) gc_num (:, 2 ) = ( / 0 , 1 / ) case ( p_ps_quadratic ) call write_err ( \"Quadratic particle shape not implemented.\" ) case default call write_err ( \"Invalid particle shape.\" ) end select dim = 2 ! call initialization routine of the parent class call this % field % new ( pp , gp , dim , dr , dxi , num_modes , gc_num ) call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine init_field_djdxi end module field_src_class","tags":"","loc":"sourcefile/field_src_class.f03.html"},{"title":"field_solver_class.f03 – QuickPIC wit Azimuzal Decomposition","text":"This file depends on sourcefile~~field_solver_class.f03~~EfferentGraph sourcefile~field_solver_class.f03 field_solver_class.f03 sourcefile~debug_tool.f03 debug_tool.f03 sourcefile~field_solver_class.f03->sourcefile~debug_tool.f03 sourcefile~system.f03 system.f03 sourcefile~field_solver_class.f03->sourcefile~system.f03 sourcefile~param.f03 param.f03 sourcefile~field_solver_class.f03->sourcefile~param.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~field_solver_class.f03~~AfferentGraph sourcefile~field_solver_class.f03 field_solver_class.f03 sourcefile~field_b_class.f03 field_b_class.f03 sourcefile~field_b_class.f03->sourcefile~field_solver_class.f03 sourcefile~field_e_class.f03 field_e_class.f03 sourcefile~field_e_class.f03->sourcefile~field_solver_class.f03 sourcefile~field_e_class.f03->sourcefile~field_b_class.f03 sourcefile~field_psi_class.f03 field_psi_class.f03 sourcefile~field_e_class.f03->sourcefile~field_psi_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_solver_class.f03 sourcefile~test_field_bperp.f03 TEST_field_bperp.f03 sourcefile~test_field_bperp.f03->sourcefile~field_b_class.f03 sourcefile~test_field_bz.f03 TEST_field_bz.f03 sourcefile~test_field_bz.f03->sourcefile~field_b_class.f03 sourcefile~test_field_ez.f03 TEST_field_ez.f03 sourcefile~test_field_ez.f03->sourcefile~field_e_class.f03 sourcefile~test_field_eperp.f03 TEST_field_eperp.f03 sourcefile~test_field_eperp.f03->sourcefile~field_b_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_e_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_bperp_iter.f03 TEST_field_bperp_iter.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_b_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~field_b_class.f03 sourcefile~simulation_class.f03->sourcefile~field_e_class.f03 sourcefile~simulation_class.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_psi.f03 TEST_field_psi.f03 sourcefile~test_field_psi.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_eperp_beam.f03 TEST_field_eperp_beam.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_b_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_e_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules field_solver_class Source Code field_solver_class.f03 Source Code module field_solver_class use mpi use param use system use debug_tool implicit none private public :: field_solver public :: HYPRE_BUF character ( len = 20 ), parameter :: cls_name = \"field_solver\" integer , parameter :: cls_level = 2 integer , dimension ( 4 ), save :: itime double precision , save :: dtime real , dimension (:), pointer :: HYPRE_BUF => null () type :: field_solver ! class for HYPRE solver ! HYPRE parameters integer , dimension (:), pointer :: offsets => null () integer , dimension (:), pointer :: stencil_idx => null () integer :: num_stencil integer :: solver_type integer :: kind integer :: mode real :: tol integer ( HYPRE_TYPE ) :: A , b , x , grid , stencil , solver , precond integer ( HYPRE_TYPE ) :: par_A , par_b , par_x integer :: iupper , ilower ! real, dimension(:), pointer :: hypre_buf => null() contains generic :: new => init_field_solver generic :: solve => solve_equation generic :: del => end_field_solver procedure , private :: init_field_solver , end_field_solver procedure , private :: set_struct_solver procedure , private :: solve_equation procedure , private :: set_struct_grid procedure , private :: set_struct_stencil procedure , private :: set_struct_matrix procedure , private :: set_ij_matrix procedure , private :: set_ij_solver end type field_solver contains ! ===================================================================== ! Class field_solver implementation ! ===================================================================== subroutine init_field_solver ( this , nd , ndp , noff , kind , mode , dr , solver_type , tol ) implicit none class ( field_solver ), intent ( inout ) :: this integer , intent ( in ), dimension ( 2 ) :: nd , ndp , noff integer , intent ( in ) :: kind , solver_type , mode real , intent ( in ) :: dr , tol integer :: i , j , ierr , comm character ( len = 20 ), save :: sname = \"init_field_solver\" call write_dbg ( cls_name , sname , cls_level , 'starts' ) this % solver_type = solver_type this % tol = tol this % mode = mode this % kind = kind ! setup HYPRE grid comm = MPI_COMM_WORLD select case ( this % kind ) case ( p_fk_psi , p_fk_ez , p_fk_bz ) call this % set_struct_grid ( comm , ndp , noff ) call this % set_struct_stencil () call this % set_struct_matrix ( comm , nd , dr ) call HYPRE_StructVectorCreate ( comm , this % grid , this % b , ierr ) call HYPRE_StructVectorInitialize ( this % b , ierr ) call HYPRE_StructVectorCreate ( comm , this % grid , this % x , ierr ) call HYPRE_StructVectorInitialize ( this % x , ierr ) call this % set_struct_solver ( comm ) case ( p_fk_bperp , p_fk_bperp_iter ) call this % set_ij_matrix ( comm , nd , ndp , noff , dr ) call HYPRE_IJVectorCreate ( comm , this % ilower , this % iupper , this % b , ierr ) call HYPRE_IJVectorSetObjectType ( this % b , HYPRE_PARCSR , ierr ) call HYPRE_IJVectorInitialize ( this % b , ierr ) call HYPRE_IJVectorCreate ( comm , this % ilower , this % iupper , this % x , ierr ) call HYPRE_IJVectorSetObjectType ( this % x , HYPRE_PARCSR , ierr ) call HYPRE_IJVectorInitialize ( this % x , ierr ) call this % set_ij_solver ( comm ) end select call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine init_field_solver subroutine end_field_solver ( this ) implicit none class ( field_solver ), intent ( inout ) :: this integer :: ierr character ( len = 20 ), save :: sname = \"end_field_solver\" call write_dbg ( cls_name , sname , cls_level , 'starts' ) if ( associated ( HYPRE_BUF ) ) deallocate ( HYPRE_BUF ) select case ( this % kind ) case ( p_fk_psi , p_fk_bz , p_fk_ez ) call HYPRE_StructGridDestroy ( this % grid , ierr ) call HYPRE_StructStencilDestroy ( this % stencil , ierr ) call HYPRE_StructVectorDestroy ( this % b , ierr ) call HYPRE_StructVectorDestroy ( this % x , ierr ) call HYPRE_StructMatrixDestroy ( this % A , ierr ) case ( p_fk_bperp_iter , p_fk_bperp ) call HYPRE_IJMatrixDestroy ( this % A , ierr ) call HYPRE_IJVectorDestroy ( this % b , ierr ) call HYPRE_IJVectorDestroy ( this % x , ierr ) end select select case ( this % solver_type ) case ( p_hypre_cycred ) call HYPRE_StructCycRedDestroy ( this % solver , ierr ) case ( p_hypre_smg ) call HYPRE_StructSMGDestroy ( this % solver , ierr ) case ( p_hypre_pcg ) call HYPRE_StructPCGDestroy ( this % solver , ierr ) call HYPRE_StructSMGDestroy ( this % precond , ierr ) case ( p_hypre_gmres ) call HYPRE_StructGMRESDestroy ( this % solver , ierr ) call HYPRE_StructJacobiDestroy ( this % precond , ierr ) case ( p_hypre_amg ) call HYPRE_BoomerAMGDestroy ( this % solver , ierr ) end select call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine end_field_solver subroutine set_struct_solver ( this , comm ) implicit none class ( field_solver ), intent ( inout ) :: this integer , intent ( in ) :: comm integer :: n_post = 1 , n_pre = 1 , maxiter = 1000 , maxiter_pre = 10 integer :: i , ierr , precond_id character ( len = 20 ), save :: sname = \"set_struct_solver\" call write_dbg ( cls_name , sname , cls_level , 'starts' ) select case ( this % solver_type ) case ( p_hypre_cycred ) print * , \"Using Cyclic Reduction solver\" call HYPRE_StructCycRedCreate ( comm , this % solver , ierr ) call HYPRE_StructCycRedSetup ( this % solver , this % A , this % b , this % x , ierr ) case ( p_hypre_smg ) print * , 'Using SMG solver' call HYPRE_StructSMGCreate ( comm , this % solver , ierr ) call HYPRE_StructSMGSetMemoryUse ( this % solver , 0 , ierr ) call HYPRE_StructSMGSetMaxIter ( this % solver , maxiter , ierr ) call HYPRE_StructSMGSetTol ( this % solver , this % tol , ierr ) call HYPRE_StructSMGSetPrintLevel ( this % solver , 1 , ierr ) call HYPRE_StructSMGSetRelChange ( this % solver , 0 , ierr ) call HYPRE_StructSMGSetNumPreRelax ( this % solver , n_pre , ierr ) call HYPRE_StructSMGSetNumPostRelax ( this % solver , n_post , ierr ) call HYPRE_StructSMGSetLogging ( this % solver , 1 , ierr ) call HYPRE_StructSMGSetup ( this % solver , this % A , this % b , this % x , ierr ) case ( p_hypre_pcg ) print * , 'Using PCG solver' call HYPRE_StructPCGCreate ( comm , this % solver , ierr ) call HYPRE_StructPCGSetMaxIter ( this % solver , maxiter , ierr ) call HYPRE_StructPCGSetTol ( this % solver , this % tol , ierr ) call HYPRE_StructPCGSetPrintLevel ( this % solver , 2 , ierr ) call HYPRE_StructPCGSetTwoNorm ( this % solver , 1 , ierr ) call HYPRE_StructPCGSetRelChange ( this % solver , 0 , ierr ) call HYPRE_StructPCGSetLogging ( this % solver , 1 , ierr ) ! set up preconditioner precond_id = 7 call HYPRE_StructJacobiCreate ( comm , this % precond , ierr ) ! call HYPRE_StructSMGSetMemoryUse( this%precond, 0, ierr ) call HYPRE_StructJacobiSetMaxIter ( this % precond , 20 , ierr ) call HYPRE_StructJacobiSetTol ( this % precond , this % tol , ierr ) ! call HYPRE_StructSMGSetNumPreRelax( this%precond, n_pre, ierr ) ! call HYPRE_StructSMGSetNumPostRelax( this%precond, n_post, ierr ) ! call HYPRE_StructSMGSetLogging( this%precond, 0, ierr ) call HYPRE_StructPCGSetPrecond ( this % solver , precond_id , this % precond , ierr ) call HYPRE_StructPCGSetup ( this % solver , this % A , this % b , this % x , ierr ) case ( p_hypre_gmres ) print * , 'Using GMRES solver' call HYPRE_StructGMRESCreate ( comm , this % solver , ierr ) call HYPRE_StructGMRESSetMaxIter ( this % solver , maxiter , ierr ) call HYPRE_StructGMRESSetTol ( this % solver , this % tol , ierr ) call HYPRE_StructGMRESSetPrintLevel ( this % solver , 2 , ierr ) call HYPRE_StructGMRESSetLogging ( this % solver , 1 , ierr ) call HYPRE_StructJacobiCreate ( comm , this % precond , ierr ) call HYPRE_StructJacobiSetMaxIter ( this % precond , 20 , ierr ) call HYPRE_StructJacobiSetTol ( this % precond , 0.0 , ierr ) call HYPRE_StructJacobiSetZeroGuess ( this % precond , ierr ) precond_id = 7 call HYPRE_StructGMRESSetPrecond ( this % solver , precond_id , this % precond , ierr ) call HYPRE_StructGMRESSetup ( this % solver , this % A , this % b , this % x , ierr ) end select call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine set_struct_solver subroutine solve_equation ( this , src_sol ) implicit none class ( field_solver ), intent ( inout ) :: this real , intent ( inout ), dimension (:), pointer :: src_sol integer :: local_size , i , ierr integer , dimension (:), pointer , save :: rows => null () character ( len = 20 ), save :: sname = \"solve_equation\" call write_dbg ( cls_name , sname , cls_level , 'starts' ) select case ( this % kind ) case ( p_fk_psi , p_fk_ez , p_fk_bz ) call HYPRE_StructVectorSetBoxValues ( this % b , this % ilower , this % iupper , src_sol , ierr ) call HYPRE_StructVectorAssemble ( this % b , ierr ) case ( p_fk_bperp , p_fk_bperp_iter ) local_size = this % iupper - this % ilower + 1 if ( . not . associated ( rows ) ) then allocate ( rows ( local_size ) ) do i = this % ilower , this % iupper rows ( i ) = i enddo endif call HYPRE_IJVectorSetValues ( this % b , local_size , rows , src_sol , ierr ) call HYPRE_IJVectorAssemble ( this % b , ierr ) call HYPRE_IJVectorGetObject ( this % b , this % par_b , ierr ) call HYPRE_IJVectorGetObject ( this % x , this % par_x , ierr ) end select select case ( this % solver_type ) case ( p_hypre_cycred ) call HYPRE_StructCycRedSolve ( this % solver , this % A , this % b , this % x , ierr ) case ( p_hypre_smg ) call HYPRE_StructSMGSolve ( this % solver , this % A , this % b , this % x , ierr ) case ( p_hypre_pcg ) call HYPRE_StructPCGSolve ( this % solver , this % A , this % b , this % x , ierr ) case ( p_hypre_gmres ) call HYPRE_StructGMRESSolve ( this % solver , this % A , this % b , this % x , ierr ) case ( p_hypre_amg ) ! call dtimer( dtime, itime, -1 ) call HYPRE_BoomerAMGSolve ( this % solver , this % par_A , this % par_b , this % par_x , ierr ) ! call dtimer( dtime, itime, 1 ) ! print *, \"time = \", dtime end select select case ( this % kind ) case ( p_fk_psi , p_fk_ez , p_fk_bz ) call HYPRE_StructVectorGetBoxValues ( this % x , this % ilower , this % iupper , src_sol , ierr ) case ( p_fk_bperp , p_fk_bperp_iter ) call HYPRE_IJVectorGetValues ( this % x , local_size , rows , src_sol , ierr ) end select call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine solve_equation subroutine set_struct_grid ( this , comm , ndp , noff ) implicit none class ( field_solver ), intent ( inout ) :: this integer , intent ( in ) :: comm integer , intent ( in ), dimension ( 2 ) :: noff , ndp integer :: ierr , dim = 1 character ( len = 20 ), save :: sname = \"set_struct_grid\" call write_dbg ( cls_name , sname , cls_level , 'starts' ) this % ilower = noff ( 1 ) + 1 this % iupper = noff ( 1 ) + ndp ( 1 ) ! select case ( this%kind ) ! case ( p_fk_psi, p_fk_ez, p_fk_bz ) call HYPRE_StructGridCreate ( comm , 1 , this % grid , ierr ) call HYPRE_StructGridSetExtents ( this % grid , this % ilower , this % iupper , ierr ) ! case ( p_fk_bperp, p_fk_bperp_iter ) !   call HYPRE_StructGridCreate( comm, 2, this%grid, ierr ) !   call HYPRE_StructGridSetExtents( this%grid, (/this%ilower,1/), (/this%iupper,4/), ierr ) ! case default !   print *, \"Invalid field kind for solver.\" !   stop ! end select call HYPRE_StructGridAssemble ( this % grid , ierr ) call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine set_struct_grid subroutine set_struct_stencil ( this ) implicit none class ( field_solver ), intent ( inout ) :: this integer :: i , ierr character ( len = 20 ), save :: sname = \"set_struct_stencil\" call write_dbg ( cls_name , sname , cls_level , 'starts' ) ! select case ( this%kind ) ! case ( p_fk_psi, p_fk_ez, p_fk_bz ) this % num_stencil = 3 if ( . not . associated ( this % offsets ) ) then allocate ( this % offsets ( this % num_stencil ) ) endif if ( . not . associated ( this % stencil_idx ) ) then allocate ( this % stencil_idx ( this % num_stencil ) ) do i = 1 , this % num_stencil this % stencil_idx ( i ) = i - 1 enddo endif this % offsets = ( /- 1 , 0 , 1 / ) call HYPRE_StructStencilCreate ( 1 , this % num_stencil , this % stencil , ierr ) do i = 1 , this % num_stencil call HYPRE_StructStencilSetElement ( this % stencil , i - 1 , this % offsets ( i ), ierr ) enddo ! case ( p_fk_bperp, p_fk_bperp_iter ) !   this%num_stencil = 5 !   if ( .not. associated( this%offsets2 ) ) then !     allocate( this%offsets2( 2, this%num_stencil ) ) !   endif !   if ( .not. associated( this%stencil_idx ) ) then !     allocate( this%stencil_idx( this%num_stencil ) ) !     do i = 1, this%num_stencil !       this%stencil_idx(i) = i-1 !     enddo !   endif !   this%offsets2(:,1) = (/ 0, 0/) !   this%offsets2(:,2) = (/-1, 0/) !   this%offsets2(:,3) = (/ 1, 0/) !   this%offsets2(:,4) = (/ 0,-1/) !   this%offsets2(:,5) = (/ 0, 1/) !   call HYPRE_StructStencilCreate( 2, this%num_stencil, this%stencil, ierr ) !   do i = 1, this%num_stencil !     call HYPRE_StructStencilSetElement( this%stencil, i-1, this%offsets2(1,i), ierr ) !   enddo ! case default !   print *, \"Invalid field kind for solver.\" !   stop ! end select call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine set_struct_stencil subroutine set_struct_matrix ( this , comm , nd , dr ) implicit none class ( field_solver ), intent ( inout ) :: this integer , intent ( in ) :: comm integer , intent ( in ), dimension (:) :: nd real , intent ( in ) :: dr integer :: i , j , ierr , local_vol , nr real :: idr2 , m , m2 , k1 , k2 , k0 character ( len = 20 ), save :: sname = \"set_struct_matrix\" call write_dbg ( cls_name , sname , cls_level , 'starts' ) idr2 = 1.0 / ( dr * dr ) m = this % mode m2 = m * m nr = this % iupper - this % ilower + 1 local_vol = nr * this % num_stencil if ( . not . associated ( HYPRE_BUF ) ) then allocate ( HYPRE_BUF ( local_vol ) ) elseif ( size ( HYPRE_BUF ) < local_vol ) then deallocate ( HYPRE_BUF ) allocate ( HYPRE_BUF ( local_vol ) ) endif call HYPRE_StructMatrixCreate ( comm , this % grid , this % stencil , this % A , ierr ) call HYPRE_StructMatrixInitialize ( this % A , ierr ) k0 = - 0.5 do i = 1 , local_vol , this % num_stencil k0 = k0 + 1.0 k1 = k0 - 0.5 k2 = k0 + 0.5 HYPRE_BUF ( i ) = k1 / k0 * idr2 HYPRE_BUF ( i + 1 ) = - 1.0 * ( 2.0 + m2 / k0 ** 2 ) * idr2 HYPRE_BUF ( i + 2 ) = k2 / k0 * idr2 enddo ! lower boundary if ( this % ilower == 1 ) HYPRE_BUF ( 1 ) = 0.0 ! upper boundary ! if ( this%kind == p_fk_ez .or. & !   ( this%mode > 0 .and. this%kind == p_fk_psi ) ) then !   HYPRE_BUF(local_vol) = 0.0 ! endif ! if ( this%kind == p_fk_bz .or. & !   ( this%mode == 0 .and. this%kind == p_fk_psi ) ) then !   HYPRE_BUF(local_vol) = 0.0 !   HYPRE_BUF(local_vol-1) = 0.0 ! this is for eliminating the ambiguity of pure Neumann boundary !   HYPRE_BUF(local_vol-2) = 2.0 * idr2 ! endif if ( this % iupper == nd ( 1 ) ) HYPRE_BUF ( local_vol ) = 0.0 call HYPRE_StructMatrixSetBoxValues ( this % A , this % ilower , this % iupper , this % num_stencil , & this % stencil_idx , HYPRE_BUF , ierr ) ! case ( p_fk_br_iter, p_fk_bphi_iter ) !   do i = 1, local_vol, this%num_stencil !     k = k + 1 !     k1 = k - 0.5 !     k2 = k - 1.0 !     HYPRE_BUF(i) = k2 / k1 * idr2 !     HYPRE_BUF(i+1) = -1.0 * (2.0 + (m2+1.0) / k1**2) * idr2 - 1.0 !     HYPRE_BUF(i+2) = k / k1 * idr2 !   enddo !   HYPRE_BUF(1) = 0.0 !   HYPRE_BUF(local_vol) = 0.0 !   if ( this%kind == p_fk_bphi_iter ) then !     HYPRE_BUF(local_vol-2) = 2.0 * idr2 !   endif ! case ( p_fk_bperp ) !   do i = 1, local_vol, this%num_stencil*4 !     k = k + 1 !     k1 = k - 0.5 !     k2 = k - 1.0 !     ! stencil for Re(Br) !     HYPRE_BUF(i)    = k2 / k1 * idr2 !     HYPRE_BUF(i+1)  = 0.0 !     HYPRE_BUF(i+2)  = 0.0 !     HYPRE_BUF(i+3)  = -idr2 * (2.0 + (m2+1.0) / k1**2) !     HYPRE_BUF(i+4)  = 0.0 !     HYPRE_BUF(i+5)  = 2.0*m / k1**2 * idr2 !     HYPRE_BUF(i+6)  = k / k1 * idr2 !     ! stencil for Im(Br) !     HYPRE_BUF(i+7)   = k2 / k1 * idr2 !     HYPRE_BUF(i+8)   = 0.0 !     HYPRE_BUF(i+9)   = 0.0 !     HYPRE_BUF(i+10)  = -idr2 * (2.0 + (m2+1.0) / k1**2) !     HYPRE_BUF(i+11)  = -2.0*m / k1**2 * idr2 !     HYPRE_BUF(i+12)  = 0.0 !     HYPRE_BUF(i+13)  = k / k1 * idr2 !     ! stencil for Re(Bphi) !     HYPRE_BUF(i+14)  = k2 / k1 * idr2 !     HYPRE_BUF(i+15)  = 0.0 !     HYPRE_BUF(i+16)  = -2.0*m / k1**2 * idr2 !     HYPRE_BUF(i+17)  = -idr2 * (2.0 + (m2+1.0) / k1**2) !     HYPRE_BUF(i+18)  = 0.0 !     HYPRE_BUF(i+19)  = 0.0 !     HYPRE_BUF(i+20)  = k / k1 * idr2 !     ! stencil for Im(Bphi) !     HYPRE_BUF(i+21)  = k2 / k1 * idr2 !     HYPRE_BUF(i+22)  = 2.0*m / k1**2 * idr2 !     HYPRE_BUF(i+23)  = 0.0 !     HYPRE_BUF(i+24)  = -idr2 * (2.0 + (m2+1.0) / k1**2) !     HYPRE_BUF(i+25)  = 0.0 !     HYPRE_BUF(i+26)  = 0.0 !     HYPRE_BUF(i+27)  = k / k1 * idr2 !   enddo !   ! boundary condition to be set ! case ( p_fk_bperp_iter ) !   j = 0 !   do i = this%ilower, this%iupper !     k0 = i - 0.5 !     k1 = k0 - 0.5 !     k2 = k0 + 0.5 !     j = j + 1 !     ! stencil for Re(Br) !     HYPRE_BUF(5*j-4) = -1.0 - idr2 * (2.0 + (m2+1.0) / k0**2) !     HYPRE_BUF(5*j-3) = k1 / k0 * idr2 !     HYPRE_BUF(5*j-2) = k2 / k0 * idr2 !     HYPRE_BUF(5*j-1) = 0.0 !     HYPRE_BUF(5*j  ) = 2.0*m / k0**2 * idr2 !     ! stencil for Im(Bphi) !     HYPRE_BUF(5*(j+nr)-4) = -1.0 - idr2 * (2.0 + (m2+1.0) / k0**2) !     HYPRE_BUF(5*(j+nr)-3) = k1 / k0 * idr2 !     HYPRE_BUF(5*(j+nr)-2) = k2 / k0 * idr2 !     HYPRE_BUF(5*(j+nr)-1) = 2.0*m / k0**2 * idr2 !     HYPRE_BUF(5*(j+nr)  ) = 0.0 !     ! stencil for Im(Br) !     HYPRE_BUF(5*(j+2*nr)-4) = -1.0 - idr2 * (2.0 + (m2+1.0) / k0**2) !     HYPRE_BUF(5*(j+2*nr)-3) = k1 / k0 * idr2 !     HYPRE_BUF(5*(j+2*nr)-2) = k2 / k0 * idr2 !     HYPRE_BUF(5*(j+2*nr)-1) = 0.0 !     HYPRE_BUF(5*(j+2*nr)  ) = -2.0*m / k0**2 * idr2 !     ! stencil for Re(Bphi) !     HYPRE_BUF(5*(j+3*nr)-4) = -1.0 - idr2 * (2.0 + (m2+1.0) / k0**2) !     HYPRE_BUF(5*(j+3*nr)-3) = k1 / k0 * idr2 !     HYPRE_BUF(5*(j+3*nr)-2) = k2 / k0 * idr2 !     HYPRE_BUF(5*(j+3*nr)-1) = -2.0*m / k0**2 * idr2 !     HYPRE_BUF(5*(j+3*nr)  ) = 0.0 ! HYPRE_BUF(i)    = k2 / k1 * idr2 ! HYPRE_BUF(i+1)  = 0.0 ! HYPRE_BUF(i+2)  = 0.0 ! HYPRE_BUF(i+3)  = -1.0 - idr2 * (2.0 + (m2+1.0) / k1**2) ! HYPRE_BUF(i+4)  = 0.0 ! HYPRE_BUF(i+5)  = 2.0*m / k1**2 * idr2 ! HYPRE_BUF(i+6)  = k / k1 * idr2 ! ! stencil for Im(Br) ! HYPRE_BUF(i+7)   = k2 / k1 * idr2 ! HYPRE_BUF(i+8)   = 0.0 ! HYPRE_BUF(i+9)   = 0.0 ! HYPRE_BUF(i+10)  = -1.0 - idr2 * (2.0 + (m2+1.0) / k1**2) ! HYPRE_BUF(i+11)  = -2.0*m / k1**2 * idr2 ! HYPRE_BUF(i+12)  = 0.0 ! HYPRE_BUF(i+13)  = k / k1 * idr2 ! ! stencil for Re(Bphi) ! HYPRE_BUF(i+14)  = k2 / k1 * idr2 ! HYPRE_BUF(i+15)  = 0.0 ! HYPRE_BUF(i+16)  = -2.0*m / k1**2 * idr2 ! HYPRE_BUF(i+17)  = -1.0 - idr2 * (2.0 + (m2+1.0) / k1**2) ! HYPRE_BUF(i+18)  = 0.0 ! HYPRE_BUF(i+19)  = 0.0 ! HYPRE_BUF(i+20)  = k / k1 * idr2 ! ! stencil for Im(Bphi) ! HYPRE_BUF(i+21)  = k2 / k1 * idr2 ! HYPRE_BUF(i+22)  = 2.0*m / k1**2 * idr2 ! HYPRE_BUF(i+23)  = 0.0 ! HYPRE_BUF(i+24)  = -1.0 - idr2 * (2.0 + (m2+1.0) / k1**2) ! HYPRE_BUF(i+25)  = 0.0 ! HYPRE_BUF(i+26)  = 0.0 ! HYPRE_BUF(i+27)  = k / k1 * idr2 ! enddo ! HYPRE_BUF(1) = 0.0 ! HYPRE_BUF(8) = 0.0 ! HYPRE_BUF(15) = 0.0 ! HYPRE_BUF(22) = 0.0 ! HYPRE_BUF(local_vol-21) = 0.0 ! HYPRE_BUF(local_vol-14) = 0.0 ! HYPRE_BUF(local_vol-7) = 0.0 ! HYPRE_BUF(local_vol) = 0.0 ! lower boundary ! HYPRE_BUF(2      ) = 0.0 ! HYPRE_BUF(2+5 *nr) = 0.0 ! HYPRE_BUF(2+10*nr) = 0.0 ! HYPRE_BUF(2+15*nr) = 0.0 ! upper boundary ! HYPRE_BUF(5 *nr-2) = 0.0 ! HYPRE_BUF(10*nr-2) = 0.0 ! HYPRE_BUF(15*nr-2) = 0.0 ! HYPRE_BUF(20*nr-2) = 0.0 ! if ( this%mode == 0 ) then !   call write_data( HYPRE_BUF, 'HYPRE_BUF-0.txt' ) ! endif ! call HYPRE_StructMatrixSetBoxValues( this%A, (/this%ilower,1/), (/this%iupper,4/), & !   this%num_stencil, this%stencil_idx, HYPRE_BUF, ierr ) ! end select call HYPRE_StructMatrixAssemble ( this % A , ierr ) ! if ( this%kind == p_fk_bperp_iter .and. this%mode == 0 ) then !   HYPRE_BUF = 0.0 !   call HYPRE_StructMatrixGetBoxValues( this%A, (/this%ilower,1/), (/this%iupper,4/), this%num_stencil, & !     this%stencil_idx, HYPRE_BUF, ierr ) !   call write_data( HYPRE_BUF, 'HYPRE_matrix-0.txt' ) ! endif call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine set_struct_matrix subroutine set_ij_solver ( this , comm ) implicit none class ( field_solver ), intent ( inout ) :: this integer , intent ( in ) :: comm integer :: n_post = 1 , n_pre = 1 , maxiter = 1000 , maxiter_pre = 10 integer :: i , ierr , precond_id character ( len = 20 ), save :: sname = \"set_ij_solver\" call write_dbg ( cls_name , sname , cls_level , 'starts' ) select case ( this % solver_type ) case ( p_hypre_amg ) print * , \"Using Boomer AMG solver\" call HYPRE_BoomerAMGCreate ( this % solver , ierr ) call HYPRE_BoomerAMGSetMaxLevels ( this % solver , 20 , ierr ) call HYPRE_BoomerAMGSetMaxIter ( this % solver , 100 , ierr ) call HYPRE_BoomerAMGSetTol ( this % solver , this % tol , ierr ) ! call HYPRE_BoomerAMGSetPrintLevel( this%solver, 3, ierr ) ! call HYPRE_BoomerAMGSetOldDefault( this%solver, ierr ) call HYPRE_BoomerAMGSetRelaxType ( this % solver , 6 , ierr ) call HYPRE_BoomerAMGSetRelaxOrder ( this % solver , 1 , ierr ) call HYPRE_BoomerAMGSetNumSweeps ( this % solver , 10 , ierr ) ! call HYPRE_BoomerAMGSetCycleNumSweeps( this%solver, 10, 3, ierr ) ! call HYPRE_BoomerAMGSetMaxCoarseSize( this%solver, 20 ) ! call HYPRE_BoomerAMGSetMinCoarseSize( this%solver, 5 ) call HYPRE_BoomerAMGSetup ( this % solver , this % par_A , this % par_b , this % par_x , ierr ) case ( p_hypre_smg ) print * , 'Using SMG solver' call HYPRE_StructSMGCreate ( comm , this % solver , ierr ) call HYPRE_StructSMGSetMemoryUse ( this % solver , 0 , ierr ) call HYPRE_StructSMGSetMaxIter ( this % solver , maxiter , ierr ) call HYPRE_StructSMGSetTol ( this % solver , this % tol , ierr ) call HYPRE_StructSMGSetPrintLevel ( this % solver , 1 , ierr ) call HYPRE_StructSMGSetRelChange ( this % solver , 0 , ierr ) call HYPRE_StructSMGSetNumPreRelax ( this % solver , n_pre , ierr ) call HYPRE_StructSMGSetNumPostRelax ( this % solver , n_post , ierr ) call HYPRE_StructSMGSetLogging ( this % solver , 1 , ierr ) call HYPRE_StructSMGSetup ( this % solver , this % A , this % b , this % x , ierr ) case ( p_hypre_parpcg ) print * , 'Using ParCSR PCG solver' call HYPRE_ParCSRPCGCreate ( comm , this % solver , ierr ) call HYPRE_ParCSRPCGSetMaxIter ( this % solver , maxiter , ierr ) call HYPRE_ParCSRPCGSetTol ( this % solver , this % tol , ierr ) call HYPRE_ParCSRPCGSetTwoNorm ( this % solver , 1 , ierr ) ! call HYPRE_ParCSRPCGSetPrintLevel(this%solver, 2, ierr) ! call HYPRE_ParCSRPCGSetLogging(this%solver, 1, ierr) call HYPRE_BoomerAMGCreate ( this % precond , ierr ) ! call HYPRE_BoomerAMGSetPrintLevel(this%precond, 1, ierr) call HYPRE_BoomerAMGSetCoarsenType ( this % precond , 6 , ierr ) ! call HYPRE_BoomerAMGSetRelaxType(this%precond, 6, ierr) ! call HYPRE_BoomerAMGSetNumSweeps(this%precond, 1, ierr) call HYPRE_BoomerAMGSetTol ( this % precond , 0.0d0 , ierr ) call HYPRE_BoomerAMGSetMaxIter ( this % precond , 1 , ierr ) precond_id = 2 call HYPRE_ParCSRPCGSetPrecond ( this % solver , precond_id , this % precond , ierr ) call HYPRE_ParCSRPCGSetup ( this % solver , this % par_A , this % par_b , this % par_x , ierr ) end select call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine set_ij_solver subroutine set_ij_matrix ( this , comm , nd , ndp , noff , dr ) implicit none class ( field_solver ), intent ( inout ) :: this integer , intent ( in ) :: comm integer , intent ( in ), dimension (:) :: nd , ndp , noff real , intent ( in ) :: dr integer :: local_size , ierr , m , m2 , i integer , dimension (:), pointer :: cols real :: idr2 , k0 , k_minus , k_plus character ( len = 20 ), save :: sname = \"set_struct_matrix\" call write_dbg ( cls_name , sname , cls_level , 'starts' ) this % ilower = 4 * noff ( 1 ) + 1 this % iupper = 4 * noff ( 1 ) + 4 * ndp ( 1 ) local_size = this % iupper - this % ilower + 1 call HYPRE_IJMatrixCreate ( comm , this % ilower , this % iupper , & this % ilower , this % iupper , this % A , ierr ) call HYPRE_IJMatrixSetObjectType ( this % A , HYPRE_PARCSR , ierr ) call HYPRE_IJMatrixInitialize ( this % A , ierr ) if ( . not . associated ( HYPRE_BUF ) ) then allocate ( HYPRE_BUF ( 4 ) ) elseif ( size ( HYPRE_BUF ) < 4 ) then deallocate ( HYPRE_BUF ) allocate ( HYPRE_BUF ( 4 ) ) endif allocate ( cols ( 4 ) ) m = this % mode m2 = m * m idr2 = 1.0 / dr ** 2 HYPRE_BUF = 0.0 do i = this % ilower , this % iupper , 4 k0 = i / 4 + 0.5 k_minus = k0 - 0.5 k_plus = k0 + 0.5 ! set Re(Br) cols = ( / i - 4 , i , i + 3 , i + 4 / ) HYPRE_BUF ( 1 ) = k_minus / k0 * idr2 HYPRE_BUF ( 2 ) = - idr2 * ( 2.0 + ( m2 + 1.0 ) / k0 ** 2 ) HYPRE_BUF ( 3 ) = 2.0 * m / k0 ** 2 * idr2 HYPRE_BUF ( 4 ) = k_plus / k0 * idr2 if ( this % kind == p_fk_bperp_iter ) HYPRE_BUF ( 2 ) = HYPRE_BUF ( 2 ) - 1.0 if ( i == 1 ) then call HYPRE_IJMatrixSetValues ( this % A , 1 , 3 , i , cols ( 2 ), HYPRE_BUF ( 2 ), ierr ) elseif ( i == 4 * nd ( 1 ) - 3 ) then call HYPRE_IJMatrixSetValues ( this % A , 1 , 3 , i , cols , HYPRE_BUF , ierr ) else call HYPRE_IJMatrixSetValues ( this % A , 1 , 4 , i , cols , HYPRE_BUF , ierr ) endif ! set Im(Br) cols = ( / i - 3 , i + 1 , i + 2 , i + 5 / ) HYPRE_BUF ( 1 ) = k_minus / k0 * idr2 HYPRE_BUF ( 2 ) = - idr2 * ( 2.0 + ( m2 + 1.0 ) / k0 ** 2 ) HYPRE_BUF ( 3 ) = - 2.0 * m / k0 ** 2 * idr2 HYPRE_BUF ( 4 ) = k_plus / k0 * idr2 if ( this % kind == p_fk_bperp_iter ) HYPRE_BUF ( 2 ) = HYPRE_BUF ( 2 ) - 1.0 if ( i == 1 ) then call HYPRE_IJMatrixSetValues ( this % A , 1 , 3 , i + 1 , cols ( 2 ), HYPRE_BUF ( 2 ), ierr ) elseif ( i == 4 * nd ( 1 ) - 3 ) then call HYPRE_IJMatrixSetValues ( this % A , 1 , 3 , i + 1 , cols , HYPRE_BUF , ierr ) else call HYPRE_IJMatrixSetValues ( this % A , 1 , 4 , i + 1 , cols , HYPRE_BUF , ierr ) endif ! set Re(Bphi) cols = ( / i - 2 , i + 1 , i + 2 , i + 6 / ) HYPRE_BUF ( 1 ) = k_minus / k0 * idr2 HYPRE_BUF ( 2 ) = - 2.0 * m / k0 ** 2 * idr2 HYPRE_BUF ( 3 ) = - idr2 * ( 2.0 + ( m2 + 1.0 ) / k0 ** 2 ) HYPRE_BUF ( 4 ) = k_plus / k0 * idr2 if ( this % kind == p_fk_bperp_iter ) HYPRE_BUF ( 3 ) = HYPRE_BUF ( 3 ) - 1.0 if ( i == 1 ) then call HYPRE_IJMatrixSetValues ( this % A , 1 , 3 , i + 2 , cols ( 2 ), HYPRE_BUF ( 2 ), ierr ) elseif ( i == 4 * nd ( 1 ) - 3 ) then call HYPRE_IJMatrixSetValues ( this % A , 1 , 3 , i + 2 , cols , HYPRE_BUF , ierr ) else call HYPRE_IJMatrixSetValues ( this % A , 1 , 4 , i + 2 , cols , HYPRE_BUF , ierr ) endif ! set Im(Bphi) cols = ( / i - 1 , i , i + 3 , i + 7 / ) HYPRE_BUF ( 1 ) = k_minus / k0 * idr2 HYPRE_BUF ( 2 ) = 2.0 * m / k0 ** 2 * idr2 HYPRE_BUF ( 3 ) = - idr2 * ( 2.0 + ( m2 + 1.0 ) / k0 ** 2 ) HYPRE_BUF ( 4 ) = k_plus / k0 * idr2 if ( this % kind == p_fk_bperp_iter ) HYPRE_BUF ( 3 ) = HYPRE_BUF ( 3 ) - 1.0 if ( i == 1 ) then call HYPRE_IJMatrixSetValues ( this % A , 1 , 3 , i + 3 , cols ( 2 ), HYPRE_BUF ( 2 ), ierr ) elseif ( i == 4 * nd ( 1 ) - 3 ) then call HYPRE_IJMatrixSetValues ( this % A , 1 , 3 , i + 3 , cols , HYPRE_BUF , ierr ) else call HYPRE_IJMatrixSetValues ( this % A , 1 , 4 , i + 3 , cols , HYPRE_BUF , ierr ) endif enddo call HYPRE_IJMatrixAssemble ( this % A , ierr ) call HYPRE_IJMatrixGetObject ( this % A , this % par_A , ierr ) ! if ( m == 1 ) then !   call HYPRE_IJMatrixPrint( this%A, 'A.out', ierr ) ! endif deallocate ( cols ) call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine set_ij_matrix end module field_solver_class","tags":"","loc":"sourcefile/field_solver_class.f03.html"},{"title":"parallel_pipe_class.f03 – QuickPIC wit Azimuzal Decomposition","text":"This file depends on sourcefile~~parallel_pipe_class.f03~~EfferentGraph sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~parallel_pipe_class.f03~~AfferentGraph sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~field_e_class.f03 field_e_class.f03 sourcefile~field_e_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~grid_class.f03 grid_class.f03 sourcefile~field_e_class.f03->sourcefile~grid_class.f03 sourcefile~field_src_class.f03 field_src_class.f03 sourcefile~field_e_class.f03->sourcefile~field_src_class.f03 sourcefile~ufield_class.f03 ufield_class.f03 sourcefile~field_e_class.f03->sourcefile~ufield_class.f03 sourcefile~field_b_class.f03 field_b_class.f03 sourcefile~field_e_class.f03->sourcefile~field_b_class.f03 sourcefile~field_class.f03 field_class.f03 sourcefile~field_e_class.f03->sourcefile~field_class.f03 sourcefile~field_psi_class.f03 field_psi_class.f03 sourcefile~field_e_class.f03->sourcefile~field_psi_class.f03 sourcefile~grid_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_src_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_src_class.f03->sourcefile~grid_class.f03 sourcefile~field_src_class.f03->sourcefile~field_class.f03 sourcefile~ufield_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield_class.f03->sourcefile~grid_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~simulation_class.f03->sourcefile~field_e_class.f03 sourcefile~simulation_class.f03->sourcefile~grid_class.f03 sourcefile~simulation_class.f03->sourcefile~field_src_class.f03 sourcefile~input_class.f03 input_class.f03 sourcefile~simulation_class.f03->sourcefile~input_class.f03 sourcefile~simulation_class.f03->sourcefile~field_b_class.f03 sourcefile~simulation_class.f03->sourcefile~field_psi_class.f03 sourcefile~input_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~input_class.f03->sourcefile~grid_class.f03 sourcefile~field_b_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_b_class.f03->sourcefile~grid_class.f03 sourcefile~field_b_class.f03->sourcefile~field_src_class.f03 sourcefile~field_b_class.f03->sourcefile~ufield_class.f03 sourcefile~field_b_class.f03->sourcefile~field_class.f03 sourcefile~field_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_class.f03->sourcefile~grid_class.f03 sourcefile~field_class.f03->sourcefile~ufield_class.f03 sourcefile~field_psi_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_psi_class.f03->sourcefile~grid_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_src_class.f03 sourcefile~field_psi_class.f03->sourcefile~ufield_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_class.f03 sourcefile~test_field_bperp.f03 TEST_field_bperp.f03 sourcefile~test_field_bperp.f03->sourcefile~field_src_class.f03 sourcefile~test_field_bperp.f03->sourcefile~ufield_class.f03 sourcefile~test_field_bperp.f03->sourcefile~field_b_class.f03 sourcefile~test_field_bperp.f03->sourcefile~field_class.f03 sourcefile~test_field_ez.f03 TEST_field_ez.f03 sourcefile~test_field_ez.f03->sourcefile~field_e_class.f03 sourcefile~test_field_ez.f03->sourcefile~field_src_class.f03 sourcefile~test_field_ez.f03->sourcefile~ufield_class.f03 sourcefile~test_field_ez.f03->sourcefile~field_class.f03 sourcefile~test_field_bz.f03 TEST_field_bz.f03 sourcefile~test_field_bz.f03->sourcefile~field_src_class.f03 sourcefile~test_field_bz.f03->sourcefile~ufield_class.f03 sourcefile~test_field_bz.f03->sourcefile~field_b_class.f03 sourcefile~test_field_bz.f03->sourcefile~field_class.f03 sourcefile~test_ufield.f03 TEST_ufield.f03 sourcefile~test_ufield.f03->sourcefile~ufield_class.f03 sourcefile~test_field_eperp.f03 TEST_field_eperp.f03 sourcefile~test_field_eperp.f03->sourcefile~field_e_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_src_class.f03 sourcefile~test_field_eperp.f03->sourcefile~ufield_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_b_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_bperp_iter.f03 TEST_field_bperp_iter.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_src_class.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~ufield_class.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_b_class.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_class.f03 sourcefile~test_field_psi.f03 TEST_field_psi.f03 sourcefile~test_field_psi.f03->sourcefile~field_src_class.f03 sourcefile~test_field_psi.f03->sourcefile~ufield_class.f03 sourcefile~test_field_psi.f03->sourcefile~field_class.f03 sourcefile~test_field_psi.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_eperp_beam.f03 TEST_field_eperp_beam.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_e_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_src_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~ufield_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_b_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_class.f03 var pansourcefileparallel_pipe_classf03AfferentGraph = svgPanZoom('#sourcefileparallel_pipe_classf03AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules parallel_pipe_class Source Code parallel_pipe_class.f03 Source Code module parallel_pipe_class use mpi use parallel_class implicit none private public :: parallel_pipe type , extends ( parallel ) :: parallel_pipe private ! nstage: number of pipeline stages ! stageid: pipeline stage id ! lidproc: local processor id ! lkstrt: idproc+1 ! lgrp = local pipeline stage communicator ! lnvp = number of MPI nodes in the local pipeline stage integer :: nstage = 1 integer :: stageid = 0 integer :: lidproc integer :: lkstrt integer :: lgrp integer :: lnvp contains procedure :: getnstage procedure :: getstageid procedure :: getlidproc procedure :: getlkstrt procedure :: getlgrp procedure :: getlnvp procedure , private :: init_parallel_pipe generic :: new => init_parallel_pipe end type parallel_pipe contains ! function getlidproc ( this ) implicit none class ( parallel_pipe ), intent ( in ) :: this integer :: getlidproc getlidproc = this % lidproc end function getlidproc ! function getlkstrt ( this ) implicit none class ( parallel_pipe ), intent ( in ) :: this integer :: getlkstrt getlkstrt = this % lkstrt end function getlkstrt ! function getlgrp ( this ) implicit none class ( parallel_pipe ), intent ( in ) :: this integer :: getlgrp getlgrp = this % lgrp end function getlgrp ! function getlnvp ( this ) implicit none class ( parallel_pipe ), intent ( in ) :: this integer :: getlnvp getlnvp = this % lnvp end function getlnvp ! function getnstage ( this ) implicit none class ( parallel_pipe ), intent ( in ) :: this integer :: getnstage getnstage = this % nstage end function getnstage ! function getstageid ( this ) implicit none class ( parallel_pipe ), intent ( in ) :: this integer :: getstageid getstageid = this % stageid end function getstageid ! subroutine init_parallel_pipe ( this , nst ) implicit none class ( parallel_pipe ), intent ( inout ) :: this integer , intent ( in ) :: nst ! local data integer :: ierror integer :: idproc , llworld , nvp integer :: lnvp , stageid , lidproc , llgrp call this % parallel % new idproc = this % getidproc () llworld = this % getlworld () nvp = this % getnvp () lnvp = nvp / nst this % nstage = nst lidproc = mod ( idproc , lnvp ) stageid = int ( idproc / lnvp ) call MPI_COMM_SPLIT ( llworld , stageid , lidproc , llgrp , ierror ) call MPI_COMM_RANK ( llgrp , this % lidproc , ierror ) call MPI_COMM_SIZE ( llgrp , this % lnvp , ierror ) this % stageid = stageid this % lgrp = llgrp this % lkstrt = this % lidproc + 1 end subroutine init_parallel_pipe ! end module parallel_pipe_class","tags":"","loc":"sourcefile/parallel_pipe_class.f03.html"},{"title":"ufield_class.f03 – QuickPIC wit Azimuzal Decomposition","text":"This file depends on sourcefile~~ufield_class.f03~~EfferentGraph sourcefile~ufield_class.f03 ufield_class.f03 sourcefile~system.f03 system.f03 sourcefile~ufield_class.f03->sourcefile~system.f03 sourcefile~param.f03 param.f03 sourcefile~ufield_class.f03->sourcefile~param.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~ufield_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~grid_class.f03 grid_class.f03 sourcefile~ufield_class.f03->sourcefile~grid_class.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~grid_class.f03->sourcefile~system.f03 sourcefile~grid_class.f03->sourcefile~parallel_pipe_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~ufield_class.f03~~AfferentGraph sourcefile~ufield_class.f03 ufield_class.f03 sourcefile~test_field_bperp.f03 TEST_field_bperp.f03 sourcefile~test_field_bperp.f03->sourcefile~ufield_class.f03 sourcefile~field_b_class.f03 field_b_class.f03 sourcefile~test_field_bperp.f03->sourcefile~field_b_class.f03 sourcefile~field_class.f03 field_class.f03 sourcefile~test_field_bperp.f03->sourcefile~field_class.f03 sourcefile~field_src_class.f03 field_src_class.f03 sourcefile~test_field_bperp.f03->sourcefile~field_src_class.f03 sourcefile~field_e_class.f03 field_e_class.f03 sourcefile~field_e_class.f03->sourcefile~ufield_class.f03 sourcefile~field_e_class.f03->sourcefile~field_b_class.f03 sourcefile~field_e_class.f03->sourcefile~field_class.f03 sourcefile~field_psi_class.f03 field_psi_class.f03 sourcefile~field_e_class.f03->sourcefile~field_psi_class.f03 sourcefile~field_e_class.f03->sourcefile~field_src_class.f03 sourcefile~test_field_ez.f03 TEST_field_ez.f03 sourcefile~test_field_ez.f03->sourcefile~ufield_class.f03 sourcefile~test_field_ez.f03->sourcefile~field_e_class.f03 sourcefile~test_field_ez.f03->sourcefile~field_class.f03 sourcefile~test_field_ez.f03->sourcefile~field_src_class.f03 sourcefile~test_field_bz.f03 TEST_field_bz.f03 sourcefile~test_field_bz.f03->sourcefile~ufield_class.f03 sourcefile~test_field_bz.f03->sourcefile~field_b_class.f03 sourcefile~test_field_bz.f03->sourcefile~field_class.f03 sourcefile~test_field_bz.f03->sourcefile~field_src_class.f03 sourcefile~test_ufield.f03 TEST_ufield.f03 sourcefile~test_ufield.f03->sourcefile~ufield_class.f03 sourcefile~test_field_eperp.f03 TEST_field_eperp.f03 sourcefile~test_field_eperp.f03->sourcefile~ufield_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_e_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_b_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_src_class.f03 sourcefile~test_field_bperp_iter.f03 TEST_field_bperp_iter.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~ufield_class.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_b_class.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_class.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_src_class.f03 sourcefile~field_b_class.f03->sourcefile~ufield_class.f03 sourcefile~field_b_class.f03->sourcefile~field_class.f03 sourcefile~field_b_class.f03->sourcefile~field_src_class.f03 sourcefile~field_class.f03->sourcefile~ufield_class.f03 sourcefile~field_psi_class.f03->sourcefile~ufield_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_src_class.f03 sourcefile~test_field_psi.f03 TEST_field_psi.f03 sourcefile~test_field_psi.f03->sourcefile~ufield_class.f03 sourcefile~test_field_psi.f03->sourcefile~field_class.f03 sourcefile~test_field_psi.f03->sourcefile~field_psi_class.f03 sourcefile~test_field_psi.f03->sourcefile~field_src_class.f03 sourcefile~test_field_eperp_beam.f03 TEST_field_eperp_beam.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~ufield_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_e_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_b_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_src_class.f03 sourcefile~field_src_class.f03->sourcefile~field_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~field_e_class.f03 sourcefile~simulation_class.f03->sourcefile~field_b_class.f03 sourcefile~simulation_class.f03->sourcefile~field_psi_class.f03 sourcefile~simulation_class.f03->sourcefile~field_src_class.f03 var pansourcefileufield_classf03AfferentGraph = svgPanZoom('#sourcefileufield_classf03AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules ufield_class Source Code ufield_class.f03 Source Code module ufield_class use parallel_pipe_class use grid_class use param use system implicit none private character ( len = 20 ), parameter :: cls_name = \"ufield\" integer , parameter :: cls_level = 2 public :: ufield type :: ufield private real , dimension (:,:), pointer , public :: f1 => null () real , dimension (:,:,:), pointer :: f2 => null () integer , dimension ( 2 ) :: nd ! number of global grid points integer , dimension ( 2 ) :: ndp ! number of local grid points integer , dimension ( 2 ) :: nvp integer :: dim ! dimension of array (guard cell excluded) integer , dimension ( 2 ) :: noff integer , dimension ( 2 , 2 ) :: gc_num ! number of guard cells logical :: has_2d real , dimension (:), pointer :: buf => null () ! data buffer used for MPI contains generic :: new => init_ufield , init_ufield_cp generic :: del => end_ufield ! generic :: write_hdf5 generic :: get_nd => get_nd_all , get_nd_dim generic :: get_ndp => get_ndp_all , get_ndp_dim generic :: get_gc_num => get_gc_num_all , get_gc_num_dim generic :: get_nvp => get_nvp_all , get_nvp_dim generic :: get_noff => get_noff_all , get_noff_dim procedure :: get_dim procedure :: copy_slice procedure :: get_f1 procedure :: get_f2 generic :: assignment ( = ) => assign_array generic :: operator ( + ) => add_array , add_scalar1 , add_scalar2 generic :: operator ( - ) => sub_array , sub_scalar1 , sub_scalar2 generic :: operator ( * ) => dot_array , dot_scalar1 , dot_scalar2 procedure , private :: init_ufield , init_ufield_cp , end_ufield procedure , private :: get_nd_all , get_nd_dim procedure , private :: get_ndp_all , get_ndp_dim procedure , private :: get_gc_num_all , get_gc_num_dim procedure , private :: get_nvp_all , get_nvp_dim procedure , private :: get_noff_all , get_noff_dim procedure , private , pass ( a1 ) :: add_array , add_scalar1 , add_scalar2 procedure , private , pass ( a1 ) :: dot_array , dot_scalar1 , dot_scalar2 procedure , private , pass ( a1 ) :: sub_array , sub_scalar1 , sub_scalar2 procedure , private :: assign_array end type ufield contains subroutine init_ufield ( this , pp , gp , dim , gc_num , has_2d ) implicit none class ( ufield ), intent ( inout ) :: this class ( parallel_pipe ), intent ( in ), pointer :: pp class ( grid ), intent ( in ), pointer :: gp integer , intent ( in ) :: dim integer , intent ( in ), dimension ( 2 , 2 ) :: gc_num logical , intent ( in ), optional :: has_2d character ( len = 20 ), save :: sname = \"init_ufield\" call write_dbg ( cls_name , sname , cls_level , 'starts' ) this % nd = gp % get_nd () this % nvp = gp % get_nvp () this % dim = dim this % ndp = gp % get_ndp () this % noff = gp % get_noff () this % gc_num = gc_num allocate ( this % f1 ( dim , 1 - this % gc_num ( p_lower , 1 ): this % ndp ( 1 ) + this % gc_num ( p_upper , 1 ) ) ) this % f1 = 0.0 if ( present ( has_2d ) ) then this % has_2d = has_2d allocate ( this % f2 ( dim , & 1 - this % gc_num ( p_lower , 1 ): this % ndp ( 1 ) + this % gc_num ( p_upper , 1 ), & 1 - this % gc_num ( p_lower , 2 ): this % ndp ( 2 ) + this % gc_num ( p_upper , 2 ) ) ) this % f2 = 0.0 else this % has_2d = . false . endif call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine init_ufield subroutine init_ufield_cp ( this , that , has_2d ) implicit none class ( ufield ), intent ( inout ) :: this class ( ufield ), intent ( in ) :: that logical , intent ( in ), optional :: has_2d character ( len = 20 ), save :: sname = \"init_ufield_cp\" call write_dbg ( cls_name , sname , cls_level , 'starts' ) this % nd = that % get_nd () this % nvp = that % get_nvp () this % dim = that % dim this % ndp = that % get_ndp () this % noff = that % get_noff () this % gc_num = that % get_gc_num () allocate ( this % f1 ( this % dim , 1 - this % gc_num ( p_lower , 1 ): this % ndp ( 1 ) + this % gc_num ( p_upper , 1 ) ) ) this % f1 = 0.0 if ( present ( has_2d ) ) then this % has_2d = has_2d allocate ( this % f2 ( this % dim , & 1 - this % gc_num ( p_lower , 1 ): this % ndp ( 1 ) + this % gc_num ( p_upper , 1 ), & 1 - this % gc_num ( p_lower , 2 ): this % ndp ( 2 ) + this % gc_num ( p_upper , 2 ) ) ) this % f2 = 0.0 else this % has_2d = . false . endif call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine init_ufield_cp subroutine end_ufield ( this ) implicit none class ( ufield ), intent ( inout ) :: this character ( len = 20 ), save :: sname = \"end_ufield\" call write_dbg ( cls_name , sname , cls_level , 'starts' ) if ( associated ( this % f1 ) ) deallocate ( this % f1 ) if ( associated ( this % f2 ) ) deallocate ( this % f2 ) call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine end_ufield subroutine copy_slice ( this , idx , dir ) implicit none class ( ufield ), intent ( inout ) :: this integer , intent ( in ) :: idx , dir integer :: i , j , lb , ub character ( len = 20 ), save :: sname = \"copy_slice\" call write_dbg ( cls_name , sname , cls_level , 'starts' ) lb = 1 - this % gc_num ( p_lower , 1 ) ub = this % ndp ( 1 ) + this % gc_num ( p_upper , 1 ) if ( . not . this % has_2d ) then print * , \"The field has no 2D layout.\" stop endif select case ( dir ) case ( p_copy_1to2 ) do j = lb , ub do i = 1 , this % dim this % f2 ( i , j , idx ) = this % f1 ( i , j ) enddo enddo case ( p_copy_2to1 ) do j = lb , ub do i = 1 , this % dim this % f1 ( i , j ) = this % f2 ( i , j , idx ) enddo enddo end select call write_dbg ( cls_name , sname , cls_level , 'ends' ) end subroutine copy_slice subroutine assign_array ( this , that ) implicit none class ( ufield ), intent ( inout ) :: this class ( * ), intent ( in ) :: that integer :: i , j select type ( that ) type is ( real ) do j = 1 , this % ndp ( 1 ) do i = 1 , this % dim this % f1 ( i , j ) = that enddo enddo class is ( ufield ) do j = 1 , this % ndp ( 1 ) do i = 1 , this % dim this % f1 ( i , j ) = that % f1 ( i , j ) enddo enddo class default print * , \"invalid assignment type!\" stop end select end subroutine assign_array function add_array ( a1 , a2 ) result ( a3 ) implicit none class ( ufield ), intent ( in ) :: a1 class ( ufield ), intent ( in ) :: a2 class ( ufield ), allocatable :: a3 integer :: i , j allocate ( a3 ) ! call a3%new( a1%dim, a1%get_nd(), a1%get_nvp(), a1%get_gc_num() ) call a3 % new ( a1 ) do j = 1 , a1 % ndp ( 1 ) do i = 1 , a1 % dim a3 % f1 ( i , j ) = a1 % f1 ( i , j ) + a2 % f1 ( i , j ) enddo enddo end function add_array function add_scalar1 ( a1 , a2 ) result ( a3 ) implicit none class ( ufield ), intent ( in ) :: a1 real , intent ( in ) :: a2 class ( ufield ), allocatable :: a3 integer :: i , j allocate ( a3 ) ! note that buffer has no 2D array ! call a3%new( a1%dim, a1%get_nd(), a1%get_nvp(), a1%get_gc_num() ) call a3 % new ( a1 ) do j = 1 , a1 % ndp ( 1 ) do i = 1 , a1 % dim a3 % f1 ( i , j ) = a1 % f1 ( i , j ) + a2 enddo enddo end function add_scalar1 function add_scalar2 ( a2 , a1 ) result ( a3 ) implicit none real , intent ( in ) :: a2 class ( ufield ), intent ( in ) :: a1 class ( ufield ), allocatable :: a3 integer :: i , j allocate ( a3 ) ! note that buffer has no 2D array ! call a3%new( a1%dim, a1%get_nd(), a1%get_nvp(), a1%get_gc_num() ) call a3 % new ( a1 ) do j = 1 , a1 % ndp ( 1 ) do i = 1 , a1 % dim a3 % f1 ( i , j ) = a1 % f1 ( i , j ) + a2 enddo enddo end function add_scalar2 function sub_array ( a1 , a2 ) result ( a3 ) implicit none class ( ufield ), intent ( in ) :: a1 class ( ufield ), intent ( in ) :: a2 class ( ufield ), allocatable :: a3 integer :: i , j allocate ( a3 ) ! call a3%new( a1%dim, a1%get_nd(), a1%get_nvp(), a1%get_gc_num() ) call a3 % new ( a1 ) do j = 1 , a1 % ndp ( 1 ) do i = 1 , a1 % dim a3 % f1 ( i , j ) = a1 % f1 ( i , j ) - a2 % f1 ( i , j ) enddo enddo end function sub_array function sub_scalar1 ( a1 , a2 ) result ( a3 ) implicit none class ( ufield ), intent ( in ) :: a1 real , intent ( in ) :: a2 class ( ufield ), allocatable :: a3 integer :: i , j allocate ( a3 ) ! note that buffer has no 2D array ! call a3%new( a1%dim, a1%get_nd(), a1%get_nvp(), a1%get_gc_num() ) call a3 % new ( a1 ) do j = 1 , a1 % ndp ( 1 ) do i = 1 , a1 % dim a3 % f1 ( i , j ) = a1 % f1 ( i , j ) - a2 enddo enddo end function sub_scalar1 function sub_scalar2 ( a2 , a1 ) result ( a3 ) implicit none real , intent ( in ) :: a2 class ( ufield ), intent ( in ) :: a1 class ( ufield ), allocatable :: a3 integer :: i , j allocate ( a3 ) ! note that buffer has no 2D array ! call a3%new( a1%dim, a1%get_nd(), a1%get_nvp(), a1%get_gc_num() ) call a3 % new ( a1 ) do j = 1 , a1 % ndp ( 1 ) do i = 1 , a1 % dim a3 % f1 ( i , j ) = a2 - a1 % f1 ( i , j ) enddo enddo end function sub_scalar2 function dot_array ( a1 , a2 ) result ( a3 ) implicit none class ( ufield ), intent ( in ) :: a1 class ( ufield ), intent ( in ) :: a2 class ( ufield ), allocatable :: a3 integer :: i , j allocate ( a3 ) ! call a3%new( a1%dim, a1%get_nd(), a1%get_nvp(), a1%get_gc_num() ) call a3 % new ( a1 ) do j = 1 , a1 % ndp ( 1 ) do i = 1 , a1 % dim a3 % f1 ( i , j ) = a1 % f1 ( i , j ) * a2 % f1 ( i , j ) enddo enddo end function dot_array function dot_scalar1 ( a1 , a2 ) result ( a3 ) implicit none class ( ufield ), intent ( in ) :: a1 real , intent ( in ) :: a2 class ( ufield ), allocatable :: a3 integer :: i , j allocate ( a3 ) ! note that buffer has no 2D array ! call a3%new( a1%dim, a1%get_nd(), a1%get_nvp(), a1%get_gc_num() ) call a3 % new ( a1 ) do j = 1 , a1 % ndp ( 1 ) do i = 1 , a1 % dim a3 % f1 ( i , j ) = a1 % f1 ( i , j ) * a2 enddo enddo end function dot_scalar1 function dot_scalar2 ( a2 , a1 ) result ( a3 ) implicit none real , intent ( in ) :: a2 class ( ufield ), intent ( in ) :: a1 class ( ufield ), allocatable :: a3 integer :: i , j allocate ( a3 ) ! note that buffer has no 2D array ! call a3%new( a1%dim, a1%get_nd(), a1%get_nvp(), a1%get_gc_num() ) call a3 % new ( a1 ) do j = 1 , a1 % ndp ( 1 ) do i = 1 , a1 % dim a3 % f1 ( i , j ) = a1 % f1 ( i , j ) * a2 enddo enddo end function dot_scalar2 function get_dim ( this ) implicit none class ( ufield ), intent ( in ) :: this integer :: get_dim get_dim = this % dim end function get_dim function get_nd_all ( this ) implicit none class ( ufield ), intent ( in ) :: this integer , dimension ( 2 ) :: get_nd_all get_nd_all = this % nd end function get_nd_all function get_nd_dim ( this , dim ) implicit none class ( ufield ), intent ( in ) :: this integer , intent ( in ) :: dim integer :: get_nd_dim get_nd_dim = this % nd ( dim ) end function get_nd_dim function get_ndp_all ( this ) implicit none class ( ufield ), intent ( in ) :: this integer , dimension ( 2 ) :: get_ndp_all get_ndp_all = this % ndp end function get_ndp_all function get_ndp_dim ( this , dim ) implicit none class ( ufield ), intent ( in ) :: this integer , intent ( in ) :: dim integer :: get_ndp_dim get_ndp_dim = this % ndp ( dim ) end function get_ndp_dim function get_gc_num_all ( this ) implicit none class ( ufield ), intent ( in ) :: this integer , dimension ( 2 , 2 ) :: get_gc_num_all get_gc_num_all = this % gc_num end function get_gc_num_all function get_gc_num_dim ( this , dim ) implicit none class ( ufield ), intent ( in ) :: this integer , intent ( in ) :: dim integer , dimension ( 2 ) :: get_gc_num_dim get_gc_num_dim = this % gc_num (:, dim ) end function get_gc_num_dim function get_nvp_all ( this ) implicit none class ( ufield ), intent ( in ) :: this integer , dimension ( 2 ) :: get_nvp_all get_nvp_all = this % nvp end function get_nvp_all function get_nvp_dim ( this , dim ) implicit none class ( ufield ), intent ( in ) :: this integer , intent ( in ) :: dim integer :: get_nvp_dim get_nvp_dim = this % nvp ( dim ) end function get_nvp_dim function get_noff_all ( this ) implicit none class ( ufield ), intent ( in ) :: this integer , dimension ( 2 ) :: get_noff_all get_noff_all = this % noff end function get_noff_all function get_noff_dim ( this , dim ) implicit none class ( ufield ), intent ( in ) :: this integer , intent ( in ) :: dim integer :: get_noff_dim get_noff_dim = this % noff ( dim ) end function get_noff_dim function get_f1 ( this ) implicit none class ( ufield ), intent ( in ) :: this real , dimension (:,:), pointer :: get_f1 get_f1 => this % f1 end function get_f1 function get_f2 ( this ) implicit none class ( ufield ), intent ( in ) :: this real , dimension (:,:,:), pointer :: get_f2 get_f2 => this % f2 end function get_f2 end module ufield_class","tags":"","loc":"sourcefile/ufield_class.f03.html"},{"title":"TEST_field_bz.f03 – QuickPIC wit Azimuzal Decomposition","text":"This file depends on sourcefile~~test_field_bz.f03~~EfferentGraph sourcefile~test_field_bz.f03 TEST_field_bz.f03 sourcefile~param.f03 param.f03 sourcefile~test_field_bz.f03->sourcefile~param.f03 sourcefile~debug_tool.f03 debug_tool.f03 sourcefile~test_field_bz.f03->sourcefile~debug_tool.f03 sourcefile~system.f03 system.f03 sourcefile~test_field_bz.f03->sourcefile~system.f03 sourcefile~field_src_class.f03 field_src_class.f03 sourcefile~test_field_bz.f03->sourcefile~field_src_class.f03 sourcefile~field_b_class.f03 field_b_class.f03 sourcefile~test_field_bz.f03->sourcefile~field_b_class.f03 sourcefile~ufield_class.f03 ufield_class.f03 sourcefile~test_field_bz.f03->sourcefile~ufield_class.f03 sourcefile~field_class.f03 field_class.f03 sourcefile~test_field_bz.f03->sourcefile~field_class.f03 sourcefile~field_src_class.f03->sourcefile~param.f03 sourcefile~field_src_class.f03->sourcefile~system.f03 sourcefile~field_src_class.f03->sourcefile~field_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~field_src_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~grid_class.f03 grid_class.f03 sourcefile~field_src_class.f03->sourcefile~grid_class.f03 sourcefile~field_b_class.f03->sourcefile~param.f03 sourcefile~field_b_class.f03->sourcefile~debug_tool.f03 sourcefile~field_b_class.f03->sourcefile~system.f03 sourcefile~field_b_class.f03->sourcefile~field_src_class.f03 sourcefile~field_b_class.f03->sourcefile~ufield_class.f03 sourcefile~field_b_class.f03->sourcefile~field_class.f03 sourcefile~field_solver_class.f03 field_solver_class.f03 sourcefile~field_b_class.f03->sourcefile~field_solver_class.f03 sourcefile~field_b_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_b_class.f03->sourcefile~grid_class.f03 sourcefile~ufield_class.f03->sourcefile~param.f03 sourcefile~ufield_class.f03->sourcefile~system.f03 sourcefile~ufield_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield_class.f03->sourcefile~grid_class.f03 sourcefile~field_class.f03->sourcefile~param.f03 sourcefile~field_class.f03->sourcefile~system.f03 sourcefile~field_class.f03->sourcefile~ufield_class.f03 sourcefile~field_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_class.f03->sourcefile~grid_class.f03 sourcefile~field_solver_class.f03->sourcefile~param.f03 sourcefile~field_solver_class.f03->sourcefile~debug_tool.f03 sourcefile~field_solver_class.f03->sourcefile~system.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~grid_class.f03->sourcefile~system.f03 sourcefile~grid_class.f03->sourcefile~parallel_pipe_class.f03 var pansourcefiletest_field_bzf03EfferentGraph = svgPanZoom('#sourcefiletest_field_bzf03EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_field_bz Source Code TEST_field_bz.f03 Source Code program test_field_bz use field_b_class use field_class use field_src_class use system use param use mpi use ufield_class use debug_tool implicit none type ( field_b ) :: b type ( field_jay ) :: jay integer :: num_modes = 2 , dim = 3 , order = p_fs_2order , part_shape = p_ps_linear integer , dimension ( 2 ) :: nd = ( / 128 , 1 / ), nvp = ( / 1 , 1 / ) integer , dimension ( 2 , 2 ) :: gc_num real :: dr , dxi , r type ( ufield ), dimension (:), pointer :: ujay_re => null (), ujay_im => null () type ( ufield ), dimension (:), pointer :: ub_re => null (), ub_im => null () real , dimension (:,:), pointer :: p integer :: ierr , i , mode call MPI_INIT ( ierr ) call init_errors ( 2 , 3 ) call write_dbg ( 'main' , 'test_field_bz' , 0 , 'starts' ) dr = 1.0 / ( nd ( 1 ) - 0.5 ) dxi = 1.0 gc_num (:, 1 ) = ( / 0 , 0 / ) gc_num (:, 2 ) = ( / 0 , 0 / ) call jay % new ( num_modes , dr , dxi , nd , nvp , part_shape ) call b % new ( num_modes , dr , dxi , nd , nvp , part_shape , p_entity_plasma ) ujay_re => jay % get_rf_re () ujay_im => jay % get_rf_im () ! set the charge do mode = 0 , num_modes do i = 1 , nd ( 1 ) r = ( i - 0.5 ) * dr ujay_re ( mode )% f1 ( 1 , i ) = exp ( - (( r - 0.5 ) / 0.05 ) ** 2 ) ujay_re ( mode )% f1 ( 2 , i ) = exp ( - (( r - 0.5 ) / 0.05 ) ** 2 ) ujay_re ( mode )% f1 ( 3 , i ) = exp ( - (( r - 0.5 ) / 0.05 ) ** 2 ) enddo if ( mode == 0 ) cycle do i = 1 , nd ( 1 ) r = ( i - 0.5 ) * dr ujay_im ( mode )% f1 ( 1 , i ) = exp ( - (( r - 0.5 ) / 0.05 ) ** 2 ) ujay_im ( mode )% f1 ( 2 , i ) = exp ( - (( r - 0.5 ) / 0.05 ) ** 2 ) ujay_im ( mode )% f1 ( 3 , i ) = exp ( - (( r - 0.5 ) / 0.05 ) ** 2 ) enddo enddo ! call HYPRE_StructMatrixGetBoxValues( psi%solver(0)%A, 1, nd(1), 3, & !   psi%solver(0)%stencil_idx, values, ierr ) ! print *, \"A = \", values(1:nd(1)*3) ! call HYPRE_StructVectorGetBoxValues( psi%solver(0)%b ) call b % solve ( jay ) ub_re => b % get_rf_re () ub_im => b % get_rf_im () p => ub_re ( 0 )% get_f1 () call write_data ( p , 'bz-re-0.txt' , 3 ) p => ub_re ( 1 )% get_f1 () call write_data ( p , 'bz-re-1.txt' , 3 ) p => ub_re ( 2 )% get_f1 () call write_data ( p , 'bz-re-2.txt' , 3 ) p => ub_im ( 1 )% get_f1 () call write_data ( p , 'bz-im-1.txt' , 3 ) p => ub_im ( 2 )% get_f1 () call write_data ( p , 'bz-im-2.txt' , 3 ) call jay % del () call b % del () call write_dbg ( 'main' , 'test_field_bz' , 0 , 'ends' ) call end_errors () call MPI_FINALIZE ( ierr ) end program test_field_bz","tags":"","loc":"sourcefile/test_field_bz.f03.html"},{"title":"TEST_field_ez.f03 – QuickPIC wit Azimuzal Decomposition","text":"This file depends on sourcefile~~test_field_ez.f03~~EfferentGraph sourcefile~test_field_ez.f03 TEST_field_ez.f03 sourcefile~field_e_class.f03 field_e_class.f03 sourcefile~test_field_ez.f03->sourcefile~field_e_class.f03 sourcefile~param.f03 param.f03 sourcefile~test_field_ez.f03->sourcefile~param.f03 sourcefile~debug_tool.f03 debug_tool.f03 sourcefile~test_field_ez.f03->sourcefile~debug_tool.f03 sourcefile~system.f03 system.f03 sourcefile~test_field_ez.f03->sourcefile~system.f03 sourcefile~field_src_class.f03 field_src_class.f03 sourcefile~test_field_ez.f03->sourcefile~field_src_class.f03 sourcefile~ufield_class.f03 ufield_class.f03 sourcefile~test_field_ez.f03->sourcefile~ufield_class.f03 sourcefile~field_class.f03 field_class.f03 sourcefile~test_field_ez.f03->sourcefile~field_class.f03 sourcefile~field_e_class.f03->sourcefile~param.f03 sourcefile~field_e_class.f03->sourcefile~system.f03 sourcefile~field_e_class.f03->sourcefile~field_src_class.f03 sourcefile~field_e_class.f03->sourcefile~ufield_class.f03 sourcefile~field_e_class.f03->sourcefile~field_class.f03 sourcefile~field_solver_class.f03 field_solver_class.f03 sourcefile~field_e_class.f03->sourcefile~field_solver_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~field_e_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~grid_class.f03 grid_class.f03 sourcefile~field_e_class.f03->sourcefile~grid_class.f03 sourcefile~field_b_class.f03 field_b_class.f03 sourcefile~field_e_class.f03->sourcefile~field_b_class.f03 sourcefile~field_psi_class.f03 field_psi_class.f03 sourcefile~field_e_class.f03->sourcefile~field_psi_class.f03 sourcefile~field_src_class.f03->sourcefile~param.f03 sourcefile~field_src_class.f03->sourcefile~system.f03 sourcefile~field_src_class.f03->sourcefile~field_class.f03 sourcefile~field_src_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_src_class.f03->sourcefile~grid_class.f03 sourcefile~ufield_class.f03->sourcefile~param.f03 sourcefile~ufield_class.f03->sourcefile~system.f03 sourcefile~ufield_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield_class.f03->sourcefile~grid_class.f03 sourcefile~field_class.f03->sourcefile~param.f03 sourcefile~field_class.f03->sourcefile~system.f03 sourcefile~field_class.f03->sourcefile~ufield_class.f03 sourcefile~field_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_class.f03->sourcefile~grid_class.f03 sourcefile~field_solver_class.f03->sourcefile~param.f03 sourcefile~field_solver_class.f03->sourcefile~debug_tool.f03 sourcefile~field_solver_class.f03->sourcefile~system.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~grid_class.f03->sourcefile~system.f03 sourcefile~grid_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_b_class.f03->sourcefile~param.f03 sourcefile~field_b_class.f03->sourcefile~debug_tool.f03 sourcefile~field_b_class.f03->sourcefile~system.f03 sourcefile~field_b_class.f03->sourcefile~field_src_class.f03 sourcefile~field_b_class.f03->sourcefile~ufield_class.f03 sourcefile~field_b_class.f03->sourcefile~field_class.f03 sourcefile~field_b_class.f03->sourcefile~field_solver_class.f03 sourcefile~field_b_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_b_class.f03->sourcefile~grid_class.f03 sourcefile~field_psi_class.f03->sourcefile~param.f03 sourcefile~field_psi_class.f03->sourcefile~system.f03 sourcefile~field_psi_class.f03->sourcefile~field_src_class.f03 sourcefile~field_psi_class.f03->sourcefile~ufield_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_solver_class.f03 sourcefile~field_psi_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_psi_class.f03->sourcefile~grid_class.f03 var pansourcefiletest_field_ezf03EfferentGraph = svgPanZoom('#sourcefiletest_field_ezf03EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_field_ez Source Code TEST_field_ez.f03 Source Code program test_field_ez use field_e_class use field_class use field_src_class use system use param use mpi use ufield_class use debug_tool implicit none type ( field_e ) :: e type ( field_jay ) :: jay integer :: num_modes = 2 , dim = 3 , order = p_fs_2order , part_shape = p_ps_linear integer , dimension ( 2 ) :: nd = ( / 128 , 1 / ), nvp = ( / 1 , 1 / ) integer , dimension ( 2 , 2 ) :: gc_num real :: dr , dxi , r type ( ufield ), dimension (:), pointer :: ujay_re => null (), ujay_im => null () type ( ufield ), dimension (:), pointer :: ue_re => null (), ue_im => null () real , dimension (:,:), pointer :: p integer :: ierr , i , mode call MPI_INIT ( ierr ) call init_errors ( 2 , 3 ) call write_dbg ( 'main' , 'test_field_ez' , 0 , 'starts' ) dr = 1.0 / ( nd ( 1 ) - 0.5 ) dxi = 1.0 gc_num (:, 1 ) = ( / 0 , 0 / ) gc_num (:, 2 ) = ( / 0 , 0 / ) call jay % new ( num_modes , dr , dxi , nd , nvp , part_shape ) call e % new ( num_modes , dr , dxi , nd , nvp , part_shape , p_entity_plasma ) ujay_re => jay % get_rf_re () ujay_im => jay % get_rf_im () ! set the charge do mode = 0 , num_modes do i = 1 , nd ( 1 ) r = ( i - 0.5 ) * dr ujay_re ( mode )% f1 ( 1 , i ) = exp ( - (( r - 0.5 ) / 0.05 ) ** 2 ) ujay_re ( mode )% f1 ( 2 , i ) = exp ( - (( r - 0.5 ) / 0.05 ) ** 2 ) ujay_re ( mode )% f1 ( 3 , i ) = exp ( - (( r - 0.5 ) / 0.05 ) ** 2 ) enddo if ( mode == 0 ) cycle do i = 1 , nd ( 1 ) r = ( i - 0.5 ) * dr ujay_im ( mode )% f1 ( 1 , i ) = exp ( - (( r - 0.5 ) / 0.05 ) ** 2 ) ujay_im ( mode )% f1 ( 2 , i ) = exp ( - (( r - 0.5 ) / 0.05 ) ** 2 ) ujay_im ( mode )% f1 ( 3 , i ) = exp ( - (( r - 0.5 ) / 0.05 ) ** 2 ) enddo enddo ! call HYPRE_StructMatrixGetBoxValues( psi%solver(0)%A, 1, nd(1), 3, & !   psi%solver(0)%stencil_idx, values, ierr ) ! print *, \"A = \", values(1:nd(1)*3) ! call HYPRE_StructVectorGetBoxValues( psi%solver(0)%b ) call e % solve ( jay ) ue_re => e % get_rf_re () ue_im => e % get_rf_im () p => ue_re ( 0 )% get_f1 () call write_data ( p , 'ez-re-0.txt' , 3 ) p => ue_re ( 1 )% get_f1 () call write_data ( p , 'ez-re-1.txt' , 3 ) p => ue_re ( 2 )% get_f1 () call write_data ( p , 'ez-re-2.txt' , 3 ) p => ue_im ( 1 )% get_f1 () call write_data ( p , 'ez-im-1.txt' , 3 ) p => ue_im ( 2 )% get_f1 () call write_data ( p , 'ez-im-2.txt' , 3 ) call jay % del () call e % del () call write_dbg ( 'main' , 'test_field_ez' , 0 , 'ends' ) call end_errors () call MPI_FINALIZE ( ierr ) end program test_field_ez","tags":"","loc":"sourcefile/test_field_ez.f03.html"},{"title":"TEST_field_eperp.f03 – QuickPIC wit Azimuzal Decomposition","text":"This file depends on sourcefile~~test_field_eperp.f03~~EfferentGraph sourcefile~test_field_eperp.f03 TEST_field_eperp.f03 sourcefile~field_e_class.f03 field_e_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_e_class.f03 sourcefile~param.f03 param.f03 sourcefile~test_field_eperp.f03->sourcefile~param.f03 sourcefile~debug_tool.f03 debug_tool.f03 sourcefile~test_field_eperp.f03->sourcefile~debug_tool.f03 sourcefile~system.f03 system.f03 sourcefile~test_field_eperp.f03->sourcefile~system.f03 sourcefile~field_src_class.f03 field_src_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_src_class.f03 sourcefile~field_b_class.f03 field_b_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_b_class.f03 sourcefile~ufield_class.f03 ufield_class.f03 sourcefile~test_field_eperp.f03->sourcefile~ufield_class.f03 sourcefile~field_class.f03 field_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_class.f03 sourcefile~field_psi_class.f03 field_psi_class.f03 sourcefile~test_field_eperp.f03->sourcefile~field_psi_class.f03 sourcefile~field_e_class.f03->sourcefile~param.f03 sourcefile~field_e_class.f03->sourcefile~system.f03 sourcefile~field_e_class.f03->sourcefile~field_src_class.f03 sourcefile~field_e_class.f03->sourcefile~field_b_class.f03 sourcefile~field_e_class.f03->sourcefile~ufield_class.f03 sourcefile~field_e_class.f03->sourcefile~field_class.f03 sourcefile~field_e_class.f03->sourcefile~field_psi_class.f03 sourcefile~field_solver_class.f03 field_solver_class.f03 sourcefile~field_e_class.f03->sourcefile~field_solver_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~field_e_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~grid_class.f03 grid_class.f03 sourcefile~field_e_class.f03->sourcefile~grid_class.f03 sourcefile~field_src_class.f03->sourcefile~param.f03 sourcefile~field_src_class.f03->sourcefile~system.f03 sourcefile~field_src_class.f03->sourcefile~field_class.f03 sourcefile~field_src_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_src_class.f03->sourcefile~grid_class.f03 sourcefile~field_b_class.f03->sourcefile~param.f03 sourcefile~field_b_class.f03->sourcefile~debug_tool.f03 sourcefile~field_b_class.f03->sourcefile~system.f03 sourcefile~field_b_class.f03->sourcefile~field_src_class.f03 sourcefile~field_b_class.f03->sourcefile~ufield_class.f03 sourcefile~field_b_class.f03->sourcefile~field_class.f03 sourcefile~field_b_class.f03->sourcefile~field_solver_class.f03 sourcefile~field_b_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_b_class.f03->sourcefile~grid_class.f03 sourcefile~ufield_class.f03->sourcefile~param.f03 sourcefile~ufield_class.f03->sourcefile~system.f03 sourcefile~ufield_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield_class.f03->sourcefile~grid_class.f03 sourcefile~field_class.f03->sourcefile~param.f03 sourcefile~field_class.f03->sourcefile~system.f03 sourcefile~field_class.f03->sourcefile~ufield_class.f03 sourcefile~field_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_class.f03->sourcefile~grid_class.f03 sourcefile~field_psi_class.f03->sourcefile~param.f03 sourcefile~field_psi_class.f03->sourcefile~system.f03 sourcefile~field_psi_class.f03->sourcefile~field_src_class.f03 sourcefile~field_psi_class.f03->sourcefile~ufield_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_solver_class.f03 sourcefile~field_psi_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_psi_class.f03->sourcefile~grid_class.f03 sourcefile~field_solver_class.f03->sourcefile~param.f03 sourcefile~field_solver_class.f03->sourcefile~debug_tool.f03 sourcefile~field_solver_class.f03->sourcefile~system.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~grid_class.f03->sourcefile~system.f03 sourcefile~grid_class.f03->sourcefile~parallel_pipe_class.f03 var pansourcefiletest_field_eperpf03EfferentGraph = svgPanZoom('#sourcefiletest_field_eperpf03EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_field_eperp Source Code TEST_field_eperp.f03 Source Code program test_field_eperp use field_b_class use field_e_class use field_psi_class use field_class use field_src_class use system use param use mpi use ufield_class use debug_tool implicit none type ( field_b ) :: b type ( field_e ) :: e type ( field_psi ) :: psi type ( field_rho ) :: rho type ( field_jay ) :: jay type ( field_djdxi ) :: djdxi integer :: num_modes = 3 , dim = 3 , order = p_fs_2order , part_shape = p_ps_linear integer , dimension ( 2 ) :: nd = ( / 128 , 1 / ), nvp = ( / 1 , 1 / ) integer , dimension ( 2 , 2 ) :: gc_num real :: dr , dxi , r type ( ufield ), dimension (:), pointer :: uq_re => null (), uq_im => null () type ( ufield ), dimension (:), pointer :: ue_re => null (), ue_im => null () type ( ufield ), dimension (:), pointer :: ujay_re => null (), ujay_im => null () type ( ufield ), dimension (:), pointer :: udjdxi_re => null (), udjdxi_im => null () type ( ufield ), dimension (:), pointer :: ub_re => null (), ub_im => null () type ( ufield ), dimension (:), pointer :: upsi_re => null (), upsi_im => null () real , dimension (:,:), pointer :: p integer :: ierr , i , mode call MPI_INIT ( ierr ) call init_errors ( 2 , 3 ) call write_dbg ( 'main' , 'test_field_eperp' , 0 , 'starts' ) dr = 1.0 / ( nd ( 1 ) - 0.5 ) dxi = 1.0 gc_num (:, 1 ) = ( / 0 , 0 / ) gc_num (:, 2 ) = ( / 0 , 0 / ) call rho % new ( num_modes , dr , dxi , nd , nvp , part_shape ) call b % new ( num_modes , dr , dxi , nd , nvp , part_shape , p_entity_plasma ) call e % new ( num_modes , dr , dxi , nd , nvp , part_shape , p_entity_plasma ) call psi % new ( num_modes , dr , dxi , nd , nvp , part_shape ) call jay % new ( num_modes , dr , dxi , nd , nvp , part_shape ) call djdxi % new ( num_modes , dr , dxi , nd , nvp , part_shape ) ! solve psi uq_re => rho % get_rf_re () uq_im => rho % get_rf_im () do mode = 0 , num_modes do i = 1 , nd ( 1 ) r = ( i - 0.5 ) * dr uq_re ( mode )% f1 ( 1 , i ) = 0.5 * exp ( - (( r - 0.4 ) / 0.05 ) ** 2 ) enddo if ( mode == 0 ) cycle do i = 1 , nd ( 1 ) r = ( i - 0.5 ) * dr uq_im ( mode )% f1 ( 1 , i ) = 0.5 * exp ( - (( r - 0.4 ) / 0.05 ) ** 2 ) enddo enddo call psi % solve ( rho ) ! solve b ujay_re => jay % get_rf_re () ujay_im => jay % get_rf_im () udjdxi_re => djdxi % get_rf_re () udjdxi_im => djdxi % get_rf_im () do mode = 0 , num_modes do i = 1 , nd ( 1 ) r = ( i - 0.5 ) * dr ujay_re ( mode )% f1 ( 1 , i ) = 0.0 ujay_re ( mode )% f1 ( 2 , i ) = 0.0 ujay_re ( mode )% f1 ( 3 , i ) = 0.0 udjdxi_re ( mode )% f1 ( 1 , i ) = 0.5 * exp ( - (( r - 0.4 ) / 0.05 ) ** 2 ) udjdxi_re ( mode )% f1 ( 2 , i ) = 0.5 * exp ( - (( r - 0.4 ) / 0.05 ) ** 2 ) udjdxi_re ( mode )% f1 ( 3 , i ) = 0.5 * exp ( - (( r - 0.4 ) / 0.05 ) ** 2 ) enddo if ( mode == 0 ) cycle do i = 1 , nd ( 1 ) r = ( i - 0.5 ) * dr ujay_im ( mode )% f1 ( 1 , i ) = 0.0 ujay_im ( mode )% f1 ( 2 , i ) = 0.0 ujay_im ( mode )% f1 ( 3 , i ) = 0.0 udjdxi_im ( mode )% f1 ( 1 , i ) = 0.5 * exp ( - (( r - 0.4 ) / 0.05 ) ** 2 ) udjdxi_im ( mode )% f1 ( 2 , i ) = 0.5 * exp ( - (( r - 0.4 ) / 0.05 ) ** 2 ) udjdxi_im ( mode )% f1 ( 3 , i ) = 0.5 * exp ( - (( r - 0.4 ) / 0.05 ) ** 2 ) enddo enddo call b % solve ( djdxi , jay ) ! solve electric field call e % solve ( b , psi ) ue_re => e % get_rf_re () ue_im => e % get_rf_im () ub_re => b % get_rf_re () ub_im => b % get_rf_im () upsi_re => psi % get_rf_re () upsi_im => psi % get_rf_im () p => ue_re ( 0 )% get_f1 () call write_data ( p , 'er-re-0.txt' , 1 ) call write_data ( p , 'ephi-re-0.txt' , 2 ) p => ue_re ( 1 )% get_f1 () call write_data ( p , 'er-re-1.txt' , 1 ) call write_data ( p , 'ephi-re-1.txt' , 2 ) p => ue_re ( 2 )% get_f1 () call write_data ( p , 'er-re-2.txt' , 1 ) call write_data ( p , 'ephi-re-2.txt' , 2 ) p => ue_im ( 1 )% get_f1 () call write_data ( p , 'er-im-1.txt' , 1 ) call write_data ( p , 'ephi-im-1.txt' , 2 ) p => ue_im ( 2 )% get_f1 () call write_data ( p , 'er-im-2.txt' , 1 ) call write_data ( p , 'ephi-im-2.txt' , 2 ) p => ub_re ( 0 )% get_f1 () call write_data ( p , 'br-re-0.txt' , 1 ) call write_data ( p , 'bphi-re-0.txt' , 2 ) p => ub_re ( 1 )% get_f1 () call write_data ( p , 'br-re-1.txt' , 1 ) call write_data ( p , 'bphi-re-1.txt' , 2 ) p => ub_re ( 2 )% get_f1 () call write_data ( p , 'br-re-2.txt' , 1 ) call write_data ( p , 'bphi-re-2.txt' , 2 ) p => ub_im ( 1 )% get_f1 () call write_data ( p , 'br-im-1.txt' , 1 ) call write_data ( p , 'bphi-im-1.txt' , 2 ) p => ub_im ( 2 )% get_f1 () call write_data ( p , 'br-im-2.txt' , 1 ) call write_data ( p , 'bphi-im-2.txt' , 2 ) p => upsi_re ( 0 )% get_f1 () call write_data ( p , 'psi-re-0.txt' , 1 ) p => upsi_re ( 1 )% get_f1 () call write_data ( p , 'psi-re-1.txt' , 1 ) p => upsi_re ( 2 )% get_f1 () call write_data ( p , 'psi-re-2.txt' , 1 ) p => upsi_im ( 1 )% get_f1 () call write_data ( p , 'psi-im-1.txt' , 1 ) p => upsi_im ( 2 )% get_f1 () call write_data ( p , 'psi-im-2.txt' , 1 ) call rho % del () call psi % del () call jay % del () call djdxi % del () call b % del () call e % del () call write_dbg ( 'main' , 'test_field_eperp' , 0 , 'ends' ) call end_errors () call MPI_FINALIZE ( ierr ) end program test_field_eperp","tags":"","loc":"sourcefile/test_field_eperp.f03.html"},{"title":"TEST_field_psi.f03 – QuickPIC wit Azimuzal Decomposition","text":"This file depends on sourcefile~~test_field_psi.f03~~EfferentGraph sourcefile~test_field_psi.f03 TEST_field_psi.f03 sourcefile~param.f03 param.f03 sourcefile~test_field_psi.f03->sourcefile~param.f03 sourcefile~debug_tool.f03 debug_tool.f03 sourcefile~test_field_psi.f03->sourcefile~debug_tool.f03 sourcefile~system.f03 system.f03 sourcefile~test_field_psi.f03->sourcefile~system.f03 sourcefile~field_src_class.f03 field_src_class.f03 sourcefile~test_field_psi.f03->sourcefile~field_src_class.f03 sourcefile~ufield_class.f03 ufield_class.f03 sourcefile~test_field_psi.f03->sourcefile~ufield_class.f03 sourcefile~field_class.f03 field_class.f03 sourcefile~test_field_psi.f03->sourcefile~field_class.f03 sourcefile~field_psi_class.f03 field_psi_class.f03 sourcefile~test_field_psi.f03->sourcefile~field_psi_class.f03 sourcefile~field_src_class.f03->sourcefile~param.f03 sourcefile~field_src_class.f03->sourcefile~system.f03 sourcefile~field_src_class.f03->sourcefile~field_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~field_src_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~grid_class.f03 grid_class.f03 sourcefile~field_src_class.f03->sourcefile~grid_class.f03 sourcefile~ufield_class.f03->sourcefile~param.f03 sourcefile~ufield_class.f03->sourcefile~system.f03 sourcefile~ufield_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield_class.f03->sourcefile~grid_class.f03 sourcefile~field_class.f03->sourcefile~param.f03 sourcefile~field_class.f03->sourcefile~system.f03 sourcefile~field_class.f03->sourcefile~ufield_class.f03 sourcefile~field_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_class.f03->sourcefile~grid_class.f03 sourcefile~field_psi_class.f03->sourcefile~param.f03 sourcefile~field_psi_class.f03->sourcefile~system.f03 sourcefile~field_psi_class.f03->sourcefile~field_src_class.f03 sourcefile~field_psi_class.f03->sourcefile~ufield_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_class.f03 sourcefile~field_solver_class.f03 field_solver_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_solver_class.f03 sourcefile~field_psi_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_psi_class.f03->sourcefile~grid_class.f03 sourcefile~field_solver_class.f03->sourcefile~param.f03 sourcefile~field_solver_class.f03->sourcefile~debug_tool.f03 sourcefile~field_solver_class.f03->sourcefile~system.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~grid_class.f03->sourcefile~system.f03 sourcefile~grid_class.f03->sourcefile~parallel_pipe_class.f03 var pansourcefiletest_field_psif03EfferentGraph = svgPanZoom('#sourcefiletest_field_psif03EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_field_psi Source Code TEST_field_psi.f03 Source Code program test_field_psi use field_psi_class use field_class use field_src_class use system use param use mpi use ufield_class use debug_tool implicit none type ( field_psi ) :: psi type ( field_rho ) :: q integer :: num_modes = 2 , dim = 1 , order = p_fs_2order , part_shape = p_ps_linear integer , dimension ( 2 ) :: nd = ( / 128 , 1 / ), nvp = ( / 1 , 1 / ) integer , dimension ( 2 , 2 ) :: gc_num real :: dr , dxi , r type ( ufield ), dimension (:), pointer :: uq_re => null (), uq_im => null () type ( ufield ), dimension (:), pointer :: upsi_re => null (), upsi_im => null () real , dimension (:,:), pointer :: p integer :: ierr , i , mode real , dimension ( 1024 ) :: values = 0.0 call MPI_INIT ( ierr ) call init_errors ( 2 , 3 ) call write_dbg ( 'main' , 'test_field_psi' , 0 , 'starts' ) dr = 1.0 / ( nd ( 1 ) - 0.5 ) dxi = 1.0 gc_num (:, 1 ) = ( / 0 , 0 / ) gc_num (:, 2 ) = ( / 0 , 0 / ) call q % new ( num_modes , dr , dxi , nd , nvp , part_shape ) call psi % new ( num_modes , dr , dxi , nd , nvp , part_shape ) uq_re => q % get_rf_re () uq_im => q % get_rf_im () ! set the charge do mode = 0 , num_modes do i = 1 , nd ( 1 ) r = ( i - 0.5 ) * dr uq_re ( mode )% f1 ( 1 , i ) = 0.5 * exp ( - (( r - 0.4 ) / 0.05 ) ** 2 ) enddo if ( mode == 0 ) cycle do i = 1 , nd ( 1 ) r = ( i - 0.5 ) * dr uq_im ( mode )% f1 ( 1 , i ) = 0.5 * exp ( - (( r - 0.4 ) / 0.05 ) ** 2 ) enddo enddo ! call HYPRE_StructMatrixGetBoxValues( psi%solver(0)%A, 1, nd(1), 3, & !   psi%solver(0)%stencil_idx, values, ierr ) ! print *, \"A = \", values(1:nd(1)*3) ! call HYPRE_StructVectorGetBoxValues( psi%solver(0)%b ) call psi % solve ( q ) upsi_re => psi % get_rf_re () upsi_im => psi % get_rf_im () p => upsi_re ( 0 )% get_f1 () call write_data ( p , 'psi-re-0.txt' , 1 ) p => upsi_re ( 1 )% get_f1 () call write_data ( p , 'psi-re-1.txt' , 1 ) p => upsi_re ( 2 )% get_f1 () call write_data ( p , 'psi-re-2.txt' , 1 ) p => upsi_im ( 1 )% get_f1 () call write_data ( p , 'psi-im-1.txt' , 1 ) p => upsi_im ( 2 )% get_f1 () call write_data ( p , 'psi-im-2.txt' , 1 ) call q % del () call psi % del () call write_dbg ( 'main' , 'test_field_psi' , 0 , 'ends' ) call end_errors () call MPI_FINALIZE ( ierr ) end program test_field_psi","tags":"","loc":"sourcefile/test_field_psi.f03.html"},{"title":"TEST_field_eperp_beam.f03 – QuickPIC wit Azimuzal Decomposition","text":"This file depends on sourcefile~~test_field_eperp_beam.f03~~EfferentGraph sourcefile~test_field_eperp_beam.f03 TEST_field_eperp_beam.f03 sourcefile~field_e_class.f03 field_e_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_e_class.f03 sourcefile~param.f03 param.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~param.f03 sourcefile~debug_tool.f03 debug_tool.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~debug_tool.f03 sourcefile~system.f03 system.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~system.f03 sourcefile~field_src_class.f03 field_src_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_src_class.f03 sourcefile~field_b_class.f03 field_b_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_b_class.f03 sourcefile~ufield_class.f03 ufield_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~ufield_class.f03 sourcefile~field_class.f03 field_class.f03 sourcefile~test_field_eperp_beam.f03->sourcefile~field_class.f03 sourcefile~field_e_class.f03->sourcefile~param.f03 sourcefile~field_e_class.f03->sourcefile~system.f03 sourcefile~field_e_class.f03->sourcefile~field_src_class.f03 sourcefile~field_e_class.f03->sourcefile~field_b_class.f03 sourcefile~field_e_class.f03->sourcefile~ufield_class.f03 sourcefile~field_e_class.f03->sourcefile~field_class.f03 sourcefile~field_solver_class.f03 field_solver_class.f03 sourcefile~field_e_class.f03->sourcefile~field_solver_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~field_e_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~grid_class.f03 grid_class.f03 sourcefile~field_e_class.f03->sourcefile~grid_class.f03 sourcefile~field_psi_class.f03 field_psi_class.f03 sourcefile~field_e_class.f03->sourcefile~field_psi_class.f03 sourcefile~field_src_class.f03->sourcefile~param.f03 sourcefile~field_src_class.f03->sourcefile~system.f03 sourcefile~field_src_class.f03->sourcefile~field_class.f03 sourcefile~field_src_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_src_class.f03->sourcefile~grid_class.f03 sourcefile~field_b_class.f03->sourcefile~param.f03 sourcefile~field_b_class.f03->sourcefile~debug_tool.f03 sourcefile~field_b_class.f03->sourcefile~system.f03 sourcefile~field_b_class.f03->sourcefile~field_src_class.f03 sourcefile~field_b_class.f03->sourcefile~ufield_class.f03 sourcefile~field_b_class.f03->sourcefile~field_class.f03 sourcefile~field_b_class.f03->sourcefile~field_solver_class.f03 sourcefile~field_b_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_b_class.f03->sourcefile~grid_class.f03 sourcefile~ufield_class.f03->sourcefile~param.f03 sourcefile~ufield_class.f03->sourcefile~system.f03 sourcefile~ufield_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield_class.f03->sourcefile~grid_class.f03 sourcefile~field_class.f03->sourcefile~param.f03 sourcefile~field_class.f03->sourcefile~system.f03 sourcefile~field_class.f03->sourcefile~ufield_class.f03 sourcefile~field_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_class.f03->sourcefile~grid_class.f03 sourcefile~field_solver_class.f03->sourcefile~param.f03 sourcefile~field_solver_class.f03->sourcefile~debug_tool.f03 sourcefile~field_solver_class.f03->sourcefile~system.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~grid_class.f03->sourcefile~system.f03 sourcefile~grid_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_psi_class.f03->sourcefile~param.f03 sourcefile~field_psi_class.f03->sourcefile~system.f03 sourcefile~field_psi_class.f03->sourcefile~field_src_class.f03 sourcefile~field_psi_class.f03->sourcefile~ufield_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_class.f03 sourcefile~field_psi_class.f03->sourcefile~field_solver_class.f03 sourcefile~field_psi_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_psi_class.f03->sourcefile~grid_class.f03 var pansourcefiletest_field_eperp_beamf03EfferentGraph = svgPanZoom('#sourcefiletest_field_eperp_beamf03EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_field_eperp Source Code TEST_field_eperp_beam.f03 Source Code program test_field_eperp use field_b_class use field_e_class use field_class use field_src_class use system use param use mpi use ufield_class use debug_tool implicit none type ( field_b ) :: b type ( field_e ) :: e type ( field_rho ) :: rho integer :: num_modes = 3 , dim = 3 , order = p_fs_2order , part_shape = p_ps_linear integer , dimension ( 2 ) :: nd = ( / 128 , 1 / ), nvp = ( / 1 , 1 / ) integer , dimension ( 2 , 2 ) :: gc_num real :: dr , dxi , r type ( ufield ), dimension (:), pointer :: uq_re => null (), uq_im => null () type ( ufield ), dimension (:), pointer :: ue_re => null (), ue_im => null () real , dimension (:,:), pointer :: p integer :: ierr , i , mode call MPI_INIT ( ierr ) call init_errors ( 2 , 3 ) call write_dbg ( 'main' , 'test_field_eperp' , 0 , 'starts' ) dr = 1.0 / ( nd ( 1 ) - 0.5 ) dxi = 1.0 gc_num (:, 1 ) = ( / 0 , 0 / ) gc_num (:, 2 ) = ( / 0 , 0 / ) ! Test beam field call rho % new ( num_modes , dr , dxi , nd , nvp , part_shape ) call b % new ( num_modes , dr , dxi , nd , nvp , part_shape , p_entity_beam ) call e % new ( num_modes , dr , dxi , nd , nvp , part_shape , p_entity_beam ) uq_re => rho % get_rf_re () uq_im => rho % get_rf_im () ! set the charge do mode = 0 , num_modes do i = 1 , nd ( 1 ) r = ( i - 0.5 ) * dr uq_re ( mode )% f1 ( 1 , i ) = exp ( - (( r - 0.5 ) / 0.05 ) ** 2 ) enddo if ( mode == 0 ) cycle do i = 1 , nd ( 1 ) r = ( i - 0.5 ) * dr uq_im ( mode )% f1 ( 1 , i ) = exp ( - (( r - 0.5 ) / 0.05 ) ** 2 ) enddo enddo call b % solve ( rho ) call e % solve ( b ) ue_re => e % get_rf_re () ue_im => e % get_rf_im () p => ue_re ( 0 )% get_f1 () call write_data ( p , 'er-re-beam-0.txt' , 1 ) call write_data ( p , 'ephi-re-beam-0.txt' , 2 ) p => ue_re ( 1 )% get_f1 () call write_data ( p , 'er-re-beam-1.txt' , 1 ) call write_data ( p , 'ephi-re-beam-1.txt' , 2 ) p => ue_re ( 2 )% get_f1 () call write_data ( p , 'er-re-beam-2.txt' , 1 ) call write_data ( p , 'ephi-re-beam-2.txt' , 2 ) p => ue_im ( 1 )% get_f1 () call write_data ( p , 'er-im-beam-1.txt' , 1 ) call write_data ( p , 'ephi-im-beam-1.txt' , 2 ) p => ue_im ( 2 )% get_f1 () call write_data ( p , 'er-im-beam-2.txt' , 1 ) call write_data ( p , 'ephi-im-beam-2.txt' , 2 ) call rho % del () call b % del () call e % del () call write_dbg ( 'main' , 'test_field_eperp' , 0 , 'ends' ) call end_errors () call MPI_FINALIZE ( ierr ) end program test_field_eperp","tags":"","loc":"sourcefile/test_field_eperp_beam.f03.html"},{"title":"TEST_field_bperp_iter.f03 – QuickPIC wit Azimuzal Decomposition","text":"This file depends on sourcefile~~test_field_bperp_iter.f03~~EfferentGraph sourcefile~test_field_bperp_iter.f03 TEST_field_bperp_iter.f03 sourcefile~param.f03 param.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~param.f03 sourcefile~debug_tool.f03 debug_tool.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~debug_tool.f03 sourcefile~system.f03 system.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~system.f03 sourcefile~field_src_class.f03 field_src_class.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_src_class.f03 sourcefile~field_b_class.f03 field_b_class.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_b_class.f03 sourcefile~ufield_class.f03 ufield_class.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~ufield_class.f03 sourcefile~field_class.f03 field_class.f03 sourcefile~test_field_bperp_iter.f03->sourcefile~field_class.f03 sourcefile~field_src_class.f03->sourcefile~param.f03 sourcefile~field_src_class.f03->sourcefile~system.f03 sourcefile~field_src_class.f03->sourcefile~field_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~field_src_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~grid_class.f03 grid_class.f03 sourcefile~field_src_class.f03->sourcefile~grid_class.f03 sourcefile~field_b_class.f03->sourcefile~param.f03 sourcefile~field_b_class.f03->sourcefile~debug_tool.f03 sourcefile~field_b_class.f03->sourcefile~system.f03 sourcefile~field_b_class.f03->sourcefile~field_src_class.f03 sourcefile~field_b_class.f03->sourcefile~ufield_class.f03 sourcefile~field_b_class.f03->sourcefile~field_class.f03 sourcefile~field_solver_class.f03 field_solver_class.f03 sourcefile~field_b_class.f03->sourcefile~field_solver_class.f03 sourcefile~field_b_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_b_class.f03->sourcefile~grid_class.f03 sourcefile~ufield_class.f03->sourcefile~param.f03 sourcefile~ufield_class.f03->sourcefile~system.f03 sourcefile~ufield_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield_class.f03->sourcefile~grid_class.f03 sourcefile~field_class.f03->sourcefile~param.f03 sourcefile~field_class.f03->sourcefile~system.f03 sourcefile~field_class.f03->sourcefile~ufield_class.f03 sourcefile~field_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_class.f03->sourcefile~grid_class.f03 sourcefile~field_solver_class.f03->sourcefile~param.f03 sourcefile~field_solver_class.f03->sourcefile~debug_tool.f03 sourcefile~field_solver_class.f03->sourcefile~system.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~grid_class.f03->sourcefile~system.f03 sourcefile~grid_class.f03->sourcefile~parallel_pipe_class.f03 var pansourcefiletest_field_bperp_iterf03EfferentGraph = svgPanZoom('#sourcefiletest_field_bperp_iterf03EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_field_bperp_iter Source Code TEST_field_bperp_iter.f03 Source Code program test_field_bperp_iter use field_b_class use field_class use field_src_class use system use param use mpi use ufield_class use debug_tool implicit none type ( field_b ) :: b type ( field_jay ) :: jay type ( field_djdxi ) :: djdxi integer :: num_modes = 2 , dim = 3 , part_shape = p_ps_linear integer , dimension ( 2 ) :: nd = ( / 128 , 1 / ), nvp = ( / 1 , 1 / ) integer , dimension ( 2 , 2 ) :: gc_num real :: dr , dxi , r type ( ufield ), dimension (:), pointer :: ujay_re => null (), ujay_im => null () type ( ufield ), dimension (:), pointer :: udjdxi_re => null (), udjdxi_im => null () type ( ufield ), dimension (:), pointer :: ub_re_new => null (), ub_im_new => null () type ( ufield ), dimension (:), pointer :: ub_re_old => null (), ub_im_old => null () type ( ufield ) :: ub_res real , dimension (:,:), pointer :: p integer :: ierr , i , mode , iter integer :: num_iter = 10 real , dimension (:,:), pointer :: res => null () call MPI_INIT ( ierr ) call init_errors ( 2 , 3 ) call write_dbg ( 'main' , 'test_field_bperp_iter' , 0 , 'starts' ) dr = 1.0 / ( nd ( 1 ) - 0.5 ) dxi = 1.0 gc_num (:, 1 ) = ( / 0 , 0 / ) gc_num (:, 2 ) = ( / 0 , 0 / ) call jay % new ( num_modes , dr , dxi , nd , nvp , part_shape ) call djdxi % new ( num_modes , dr , dxi , nd , nvp , part_shape ) call b % new ( num_modes , dr , dxi , nd , nvp , part_shape , p_entity_plasma ) ujay_re => jay % get_rf_re () ujay_im => jay % get_rf_im () udjdxi_re => djdxi % get_rf_re () udjdxi_im => djdxi % get_rf_im () ! set the charge do mode = 0 , num_modes do i = 1 , nd ( 1 ) r = ( i - 0.5 ) * dr ujay_re ( mode )% f1 ( 1 , i ) = 0.0 ujay_re ( mode )% f1 ( 2 , i ) = 0.0 ujay_re ( mode )% f1 ( 3 , i ) = 0.0 udjdxi_re ( mode )% f1 ( 1 , i ) = 0.5 * exp ( - (( r - 0.4 ) / 0.05 ) ** 2 ) udjdxi_re ( mode )% f1 ( 2 , i ) = 0.5 * exp ( - (( r - 0.4 ) / 0.05 ) ** 2 ) udjdxi_re ( mode )% f1 ( 3 , i ) = 0.5 * exp ( - (( r - 0.4 ) / 0.05 ) ** 2 ) enddo if ( mode == 0 ) cycle do i = 1 , nd ( 1 ) r = ( i - 0.5 ) * dr ujay_im ( mode )% f1 ( 1 , i ) = 0.0 ujay_im ( mode )% f1 ( 2 , i ) = 0.0 ujay_im ( mode )% f1 ( 3 , i ) = 0.0 udjdxi_im ( mode )% f1 ( 1 , i ) = 0.5 * exp ( - (( r - 0.4 ) / 0.05 ) ** 2 ) udjdxi_im ( mode )% f1 ( 2 , i ) = 0.5 * exp ( - (( r - 0.4 ) / 0.05 ) ** 2 ) udjdxi_im ( mode )% f1 ( 3 , i ) = 0.5 * exp ( - (( r - 0.4 ) / 0.05 ) ** 2 ) enddo enddo ! call HYPRE_StructMatrixGetBoxValues( psi%solver(0)%A, 1, nd(1), 3, & !   psi%solver(0)%stencil_idx, values, ierr ) ! print *, \"A = \", values(1:nd(1)*3) ! call HYPRE_StructVectorGetBoxValues( psi%solver(0)%b ) allocate ( res ( num_iter , ( 2 * num_modes + 1 ) * 2 ) ) allocate ( ub_re_old ( 0 : num_modes ), ub_im_old ( num_modes ) ) call ub_res % new ( dim , nd , nvp , gc_num , has_2d = . true . ) do i = 0 , num_modes call ub_re_old ( i )% new ( dim , nd , nvp , gc_num , has_2d = . true . ) if ( i == 0 ) cycle call ub_im_old ( i )% new ( dim , nd , nvp , gc_num , has_2d = . true . ) enddo do iter = 1 , num_iter print * , 'iter = ' , iter call b % solve ( djdxi , jay ) ub_re_new => b % get_rf_re () ub_im_new => b % get_rf_im () do i = 0 , num_modes ub_res = ub_re_new ( i ) - ub_re_old ( i ) ub_re_old ( i ) = ub_re_new ( i ) p => ub_res % get_f1 () if ( i == 0 ) then res ( iter , 1 ) = maxval ( abs ( p ( 1 ,:))) res ( iter , 2 ) = maxval ( abs ( p ( 2 ,:))) cycle endif res ( iter , 4 * i - 1 ) = maxval ( abs ( p ( 1 ,:))) res ( iter , 4 * i ) = maxval ( abs ( p ( 2 ,:))) ub_res = ub_im_new ( i ) - ub_im_old ( i ) ub_im_old ( i ) = ub_im_new ( i ) p => ub_res % get_f1 () res ( iter , 4 * i + 1 ) = maxval ( abs ( p ( 1 ,:))) res ( iter , 4 * i + 2 ) = maxval ( abs ( p ( 2 ,:))) enddo enddo write ( * , * ) \"Residue of each iteration\" write ( * , '(10A16)' ) \"Re(Br0)\" , \"Re(Bp0)\" , \"Re(Br1)\" , \"Re(Bp1)\" ,& \"Im(Br1)\" , \"Im(Bp1)\" , \"Re(Br2)\" , \"Re(Bp2)\" , \"Im(Br2)\" , \"Im(Bp2)\" do iter = 1 , num_iter write ( * , '(10E16.4)' ) res ( iter ,:) enddo call jay % del () call djdxi % del () call b % del () deallocate ( ub_re_old , ub_im_old ) call write_dbg ( 'main' , 'test_field_bperp_iter' , 0 , 'ends' ) call end_errors () call MPI_FINALIZE ( ierr ) end program test_field_bperp_iter","tags":"","loc":"sourcefile/test_field_bperp_iter.f03.html"},{"title":"TEST_field_bperp.f03 – QuickPIC wit Azimuzal Decomposition","text":"This file depends on sourcefile~~test_field_bperp.f03~~EfferentGraph sourcefile~test_field_bperp.f03 TEST_field_bperp.f03 sourcefile~param.f03 param.f03 sourcefile~test_field_bperp.f03->sourcefile~param.f03 sourcefile~debug_tool.f03 debug_tool.f03 sourcefile~test_field_bperp.f03->sourcefile~debug_tool.f03 sourcefile~system.f03 system.f03 sourcefile~test_field_bperp.f03->sourcefile~system.f03 sourcefile~field_src_class.f03 field_src_class.f03 sourcefile~test_field_bperp.f03->sourcefile~field_src_class.f03 sourcefile~field_b_class.f03 field_b_class.f03 sourcefile~test_field_bperp.f03->sourcefile~field_b_class.f03 sourcefile~ufield_class.f03 ufield_class.f03 sourcefile~test_field_bperp.f03->sourcefile~ufield_class.f03 sourcefile~field_class.f03 field_class.f03 sourcefile~test_field_bperp.f03->sourcefile~field_class.f03 sourcefile~field_src_class.f03->sourcefile~param.f03 sourcefile~field_src_class.f03->sourcefile~system.f03 sourcefile~field_src_class.f03->sourcefile~field_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~field_src_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~grid_class.f03 grid_class.f03 sourcefile~field_src_class.f03->sourcefile~grid_class.f03 sourcefile~field_b_class.f03->sourcefile~param.f03 sourcefile~field_b_class.f03->sourcefile~debug_tool.f03 sourcefile~field_b_class.f03->sourcefile~system.f03 sourcefile~field_b_class.f03->sourcefile~field_src_class.f03 sourcefile~field_b_class.f03->sourcefile~ufield_class.f03 sourcefile~field_b_class.f03->sourcefile~field_class.f03 sourcefile~field_solver_class.f03 field_solver_class.f03 sourcefile~field_b_class.f03->sourcefile~field_solver_class.f03 sourcefile~field_b_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_b_class.f03->sourcefile~grid_class.f03 sourcefile~ufield_class.f03->sourcefile~param.f03 sourcefile~ufield_class.f03->sourcefile~system.f03 sourcefile~ufield_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield_class.f03->sourcefile~grid_class.f03 sourcefile~field_class.f03->sourcefile~param.f03 sourcefile~field_class.f03->sourcefile~system.f03 sourcefile~field_class.f03->sourcefile~ufield_class.f03 sourcefile~field_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field_class.f03->sourcefile~grid_class.f03 sourcefile~field_solver_class.f03->sourcefile~param.f03 sourcefile~field_solver_class.f03->sourcefile~debug_tool.f03 sourcefile~field_solver_class.f03->sourcefile~system.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~grid_class.f03->sourcefile~system.f03 sourcefile~grid_class.f03->sourcefile~parallel_pipe_class.f03 var pansourcefiletest_field_bperpf03EfferentGraph = svgPanZoom('#sourcefiletest_field_bperpf03EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_field_bperp Source Code TEST_field_bperp.f03 Source Code program test_field_bperp use field_b_class use field_class use field_src_class use system use param use mpi use ufield_class use debug_tool implicit none type ( field_b ) :: b type ( field_rho ) :: rho integer :: num_modes = 3 , dim = 3 , order = p_fs_2order , part_shape = p_ps_linear integer , dimension ( 2 ) :: nd = ( / 128 , 1 / ), nvp = ( / 1 , 1 / ) integer , dimension ( 2 , 2 ) :: gc_num real :: dr , dxi , r type ( ufield ), dimension (:), pointer :: uq_re => null (), uq_im => null () type ( ufield ), dimension (:), pointer :: ub_re => null (), ub_im => null () real , dimension (:,:), pointer :: p integer :: ierr , i , mode call MPI_INIT ( ierr ) call init_errors ( 2 , 3 ) call write_dbg ( 'main' , 'test_field_bperp' , 0 , 'starts' ) dr = 1.0 / ( nd ( 1 ) - 0.5 ) dxi = 1.0 gc_num (:, 1 ) = ( / 0 , 0 / ) gc_num (:, 2 ) = ( / 0 , 0 / ) call rho % new ( num_modes , dr , dxi , nd , nvp , part_shape ) call b % new ( num_modes , dr , dxi , nd , nvp , part_shape , p_entity_beam ) uq_re => rho % get_rf_re () uq_im => rho % get_rf_im () ! set the charge do mode = 0 , num_modes do i = 1 , nd ( 1 ) r = ( i - 0.5 ) * dr uq_re ( mode )% f1 ( 1 , i ) = exp ( - (( r - 0.5 ) / 0.05 ) ** 2 ) enddo if ( mode == 0 ) cycle do i = 1 , nd ( 1 ) r = ( i - 0.5 ) * dr uq_im ( mode )% f1 ( 1 , i ) = exp ( - (( r - 0.5 ) / 0.05 ) ** 2 ) enddo enddo call b % solve ( rho ) ub_re => b % get_rf_re () ub_im => b % get_rf_im () p => ub_re ( 0 )% get_f1 () call write_data ( p , 'br-re-0.txt' , 1 ) call write_data ( p , 'bphi-re-0.txt' , 2 ) p => ub_re ( 1 )% get_f1 () call write_data ( p , 'br-re-1.txt' , 1 ) call write_data ( p , 'bphi-re-1.txt' , 2 ) p => ub_re ( 2 )% get_f1 () call write_data ( p , 'br-re-2.txt' , 1 ) call write_data ( p , 'bphi-re-2.txt' , 2 ) p => ub_re ( 3 )% get_f1 () call write_data ( p , 'br-re-3.txt' , 1 ) call write_data ( p , 'bphi-re-3.txt' , 2 ) p => ub_im ( 1 )% get_f1 () call write_data ( p , 'br-im-1.txt' , 1 ) call write_data ( p , 'bphi-im-1.txt' , 2 ) p => ub_im ( 2 )% get_f1 () call write_data ( p , 'br-im-2.txt' , 1 ) call write_data ( p , 'bphi-im-2.txt' , 2 ) p => ub_im ( 3 )% get_f1 () call write_data ( p , 'br-im-3.txt' , 1 ) call write_data ( p , 'bphi-im-3.txt' , 2 ) call rho % del () call b % del () call write_dbg ( 'main' , 'test_field_bperp' , 0 , 'ends' ) call end_errors () call MPI_FINALIZE ( ierr ) end program test_field_bperp","tags":"","loc":"sourcefile/test_field_bperp.f03.html"},{"title":"TEST_ufield.f03 – QuickPIC wit Azimuzal Decomposition","text":"This file depends on sourcefile~~test_ufield.f03~~EfferentGraph sourcefile~test_ufield.f03 TEST_ufield.f03 sourcefile~ufield_class.f03 ufield_class.f03 sourcefile~test_ufield.f03->sourcefile~ufield_class.f03 sourcefile~system.f03 system.f03 sourcefile~ufield_class.f03->sourcefile~system.f03 sourcefile~param.f03 param.f03 sourcefile~ufield_class.f03->sourcefile~param.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~ufield_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~grid_class.f03 grid_class.f03 sourcefile~ufield_class.f03->sourcefile~grid_class.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~grid_class.f03->sourcefile~system.f03 sourcefile~grid_class.f03->sourcefile~parallel_pipe_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_ufield Source Code TEST_ufield.f03 Source Code program test_ufield use ufield_class implicit none type ( ufield ) :: a1 , a2 , a3 integer :: dim = 3 integer , dimension ( 2 ) :: nd = ( / 2 , 2 / ), nvp = ( / 1 , 1 / ) integer , dimension ( 2 , 2 ) :: gc_num real :: k = 5.0 real :: start , finish integer :: i gc_num = 0 call a1 % new ( dim , nd , nvp , gc_num ) call a2 % new ( dim , nd , nvp , gc_num ) call a3 % new ( dim , nd , nvp , gc_num ) a1 % f1 = 1.0 a2 % f1 = 2.0 print * , \"a1 = \" , a1 % f1 print * , \"a2 = \" , a2 % f1 ! call cpu_time( start ) ! do i = 1, 100000 !     a3 = a1 + a2 ! enddo ! call cpu_time( finish ) ! print *, '(\"Time = \",f6.3,\" seconds.\")', finish-start a3 = k * ( a1 + a2 ) + ( a1 + k ) * a2 print * , \"a3 = \" , a3 % f1 end program test_ufield","tags":"","loc":"sourcefile/test_ufield.f03.html"},{"title":"input_json – QuickPIC wit Azimuzal Decomposition ","text":"type, public :: input_json Inherits type~~input_json~~InheritsGraph type~input_json input_json json_file json_file type~input_json->json_file input type~parallel parallel type~input_json->type~parallel p type~grid grid type~input_json->type~grid gp type~parallel_pipe parallel_pipe type~input_json->type~parallel_pipe pp type~parallel_pipe->type~parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~input_json~~InheritedByGraph type~input_json input_json type~simulation simulation type~simulation->type~input_json input Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables p pp gp input Type-Bound Procedures new get info found read_input_json set_json_core_in_file initialize print_to_string load_file load_from_string json_file_get_root json_file_get_alloc_string_vec json_file_get_string_vec json_file_get_logical_vec json_file_get_double_vec json_file_get_integer_vec json_file_get_string json_file_get_logical json_file_get_double json_file_get_integer json_file_get_object json_file_variable_info Components Type Visibility Attributes Name Initial class( parallel ), public, pointer :: p => null() class( parallel_pipe ), public, pointer :: pp => null() class( grid ), public, pointer :: gp => null() type(json_file), private, pointer :: input => null() Type-Bound Procedures generic, public :: new => read_input_json private subroutine read_input_json (this) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this generic, public :: get => json_file_get_object , json_file_get_integer , json_file_get_double , json_file_get_logical , json_file_get_string , json_file_get_integer_vec , json_file_get_double_vec , json_file_get_logical_vec , json_file_get_string_vec , json_file_get_alloc_string_vec , json_file_get_root private subroutine json_file_get_object (this, path, p) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path type(json_value), intent(out), pointer :: p private subroutine json_file_get_integer (this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path integer, intent(out) :: val private subroutine json_file_get_double (this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path real, intent(out) :: val private subroutine json_file_get_logical (this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path logical, intent(out) :: val private subroutine json_file_get_string (this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path character(len=:), intent(out), allocatable :: val private subroutine json_file_get_integer_vec (this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path integer, intent(out), dimension(:), allocatable :: vec private subroutine json_file_get_double_vec (this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path real, intent(out), dimension(:), allocatable :: vec private subroutine json_file_get_logical_vec (this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path logical, intent(out), dimension(:), allocatable :: vec private subroutine json_file_get_string_vec (this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path character(len=*), intent(out), dimension(:), allocatable :: vec private subroutine json_file_get_alloc_string_vec (this, path, vec, ilen) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path character(len=:), intent(out), dimension(:), allocatable :: vec integer, intent(out), dimension(:), allocatable :: ilen private subroutine json_file_get_root (this, p) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this type(json_value), intent(out), pointer :: p generic, public :: info => json_file_variable_info private subroutine json_file_variable_info (this, path, n_children) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path integer, intent(out) :: n_children procedure, public :: found private function found (this, path) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path Return Value logical procedure, private :: read_input_json private subroutine read_input_json (this) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this procedure, private :: set_json_core_in_file private subroutine set_json_core_in_file (this, core) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this type(json_core), intent(in) :: core procedure, private :: initialize private subroutine initialize (this, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys, no_whitespace, unescape_strings, comment_char, path_mode, path_separator, compress_vectors, allow_duplicate_keys) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this logical, intent(in), optional :: verbose logical, intent(in), optional :: compact_reals logical, intent(in), optional :: print_signs character(len=*), intent(in), optional :: real_format integer, intent(in), optional :: spaces_per_tab logical, intent(in), optional :: strict_type_checking logical, intent(in), optional :: trailing_spaces_significant logical, intent(in), optional :: case_sensitive_keys logical, intent(in), optional :: no_whitespace logical, intent(in), optional :: unescape_strings character(len=1), intent(in), optional :: comment_char integer, intent(in), optional :: path_mode character(len=1), intent(in), optional :: path_separator logical, intent(in), optional :: compress_vectors logical, intent(in), optional :: allow_duplicate_keys procedure, private :: print_to_string private subroutine print_to_string (this, str) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=:), intent(out), allocatable :: str procedure, private :: load_file private subroutine load_file (this, filename, unit) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: filename integer, intent(in), optional :: unit procedure, private :: load_from_string private subroutine load_from_string (this, str) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: str procedure, private :: json_file_get_root private subroutine json_file_get_root (this, p) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this type(json_value), intent(out), pointer :: p procedure, private :: json_file_get_alloc_string_vec private subroutine json_file_get_alloc_string_vec (this, path, vec, ilen) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path character(len=:), intent(out), dimension(:), allocatable :: vec integer, intent(out), dimension(:), allocatable :: ilen procedure, private :: json_file_get_string_vec private subroutine json_file_get_string_vec (this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path character(len=*), intent(out), dimension(:), allocatable :: vec procedure, private :: json_file_get_logical_vec private subroutine json_file_get_logical_vec (this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path logical, intent(out), dimension(:), allocatable :: vec procedure, private :: json_file_get_double_vec private subroutine json_file_get_double_vec (this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path real, intent(out), dimension(:), allocatable :: vec procedure, private :: json_file_get_integer_vec private subroutine json_file_get_integer_vec (this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path integer, intent(out), dimension(:), allocatable :: vec procedure, private :: json_file_get_string private subroutine json_file_get_string (this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path character(len=:), intent(out), allocatable :: val procedure, private :: json_file_get_logical private subroutine json_file_get_logical (this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path logical, intent(out) :: val procedure, private :: json_file_get_double private subroutine json_file_get_double (this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path real, intent(out) :: val procedure, private :: json_file_get_integer private subroutine json_file_get_integer (this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path integer, intent(out) :: val procedure, private :: json_file_get_object private subroutine json_file_get_object (this, path, p) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path type(json_value), intent(out), pointer :: p procedure, private :: json_file_variable_info private subroutine json_file_variable_info (this, path, n_children) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path integer, intent(out) :: n_children","tags":"","loc":"type/input_json.html"},{"title":"grid – QuickPIC wit Azimuzal Decomposition ","text":"type, public :: grid Inherited by type~~grid~~InheritedByGraph type~grid grid type~simulation simulation type~simulation->type~grid gp type~input_json input_json type~simulation->type~input_json input type~sim_fields sim_fields type~simulation->type~sim_fields fields type~input_json->type~grid gp type~sim_fields->type~grid gp Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nd ndp nvp noff Type-Bound Procedures new del get_noff get_nd get_ndp get_nvp end_grid init_grid get_noff_dim get_noff_all get_nd_dim get_nd_all get_ndp_dim get_ndp_all get_nvp_dim get_nvp_all Components Type Visibility Attributes Name Initial integer, private, dimension(2) :: nd integer, private, dimension(2) :: ndp integer, private, dimension(2) :: nvp integer, private, dimension(2) :: noff Type-Bound Procedures generic, public :: new => init_grid private subroutine init_grid (this, pp, nr, nz) Arguments Type Intent Optional Attributes Name class( grid ), intent(inout) :: this class( parallel_pipe ), intent(in) :: pp integer, intent(in) :: nr integer, intent(in) :: nz generic, public :: del => end_grid private subroutine end_grid (this) Arguments Type Intent Optional Attributes Name class( grid ), intent(inout) :: this generic, public :: get_noff => get_noff_all , get_noff_dim private function get_noff_all (this) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this Return Value integer,\n  dimension(2) private function get_noff_dim (this, dim) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this integer, intent(in) :: dim Return Value integer generic, public :: get_nd => get_nd_all , get_nd_dim private function get_nd_all (this) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this Return Value integer,\n  dimension(2) private function get_nd_dim (this, dim) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this integer, intent(in) :: dim Return Value integer generic, public :: get_ndp => get_ndp_all , get_ndp_dim private function get_ndp_all (this) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this Return Value integer,\n  dimension(2) private function get_ndp_dim (this, dim) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this integer, intent(in) :: dim Return Value integer generic, public :: get_nvp => get_nvp_all , get_nvp_dim private function get_nvp_all (this) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this Return Value integer,\n  dimension(2) private function get_nvp_dim (this, dim) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this integer, intent(in) :: dim Return Value integer procedure, private :: end_grid private subroutine end_grid (this) Arguments Type Intent Optional Attributes Name class( grid ), intent(inout) :: this procedure, private :: init_grid private subroutine init_grid (this, pp, nr, nz) Arguments Type Intent Optional Attributes Name class( grid ), intent(inout) :: this class( parallel_pipe ), intent(in) :: pp integer, intent(in) :: nr integer, intent(in) :: nz procedure, private :: get_noff_dim private function get_noff_dim (this, dim) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this integer, intent(in) :: dim Return Value integer procedure, private :: get_noff_all private function get_noff_all (this) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this Return Value integer,\n  dimension(2) procedure, private :: get_nd_dim private function get_nd_dim (this, dim) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this integer, intent(in) :: dim Return Value integer procedure, private :: get_nd_all private function get_nd_all (this) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this Return Value integer,\n  dimension(2) procedure, private :: get_ndp_dim private function get_ndp_dim (this, dim) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this integer, intent(in) :: dim Return Value integer procedure, private :: get_ndp_all private function get_ndp_all (this) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this Return Value integer,\n  dimension(2) procedure, private :: get_nvp_dim private function get_nvp_dim (this, dim) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this integer, intent(in) :: dim Return Value integer procedure, private :: get_nvp_all private function get_nvp_all (this) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this Return Value integer,\n  dimension(2)","tags":"","loc":"type/grid.html"},{"title":"field_psi – QuickPIC wit Azimuzal Decomposition ","text":"type, public, extends( field ) :: field_psi Inherits type~~field_psi~~InheritsGraph type~field_psi field_psi type~field field type~field_psi->type~field type~field_solver field_solver type~field_psi->type~field_solver solver type~ufield ufield type~field->type~ufield rf_re, rf_im Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~field_psi~~InheritedByGraph type~field_psi field_psi type~sim_fields sim_fields type~sim_fields->type~field_psi psi type~simulation simulation type~simulation->type~sim_fields fields Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables rf_re rf_im dr dxi num_modes entity solver buf_re buf_im Type-Bound Procedures get_rf_re get_rf_im get_num_modes get_dxi get_dr new del solve init_field_psi end_field_psi set_source get_solution solve_field_psi Components Type Visibility Attributes Name Initial class( ufield ), public, dimension(:), pointer :: rf_re => null() class( ufield ), public, dimension(:), pointer :: rf_im => null() real, public :: dr real, public :: dxi integer, public :: num_modes integer, public :: entity class( field_solver ), public, dimension(:), pointer :: solver => null() real, public, dimension(:), pointer :: buf_re => null() real, public, dimension(:), pointer :: buf_im => null() Type-Bound Procedures generic, public :: get_rf_re => get_rf_re_all , get_rf_re_mode private function get_rf_re_all (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value type( ufield ),\n  dimension(:), pointer private function get_rf_re_mode (this, mode) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this integer, intent(in) :: mode Return Value type( ufield ),\n  pointer generic, public :: get_rf_im => get_rf_im_all , get_rf_im_mode private function get_rf_im_all (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value type( ufield ),\n  dimension(:), pointer private function get_rf_im_mode (this, mode) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this integer, intent(in) :: mode Return Value type( ufield ),\n  pointer procedure, public :: get_num_modes private function get_num_modes (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value integer procedure, public :: get_dxi private function get_dxi (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value real procedure, public :: get_dr private function get_dr (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value real generic, public :: new => init_field , init_field_psi private subroutine init_field (this, pp, gp, dim, dr, dxi, num_modes, gc_num, entity) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp integer, intent(in) :: dim real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in), dimension(2,2) :: gc_num integer, intent(in), optional :: entity private subroutine init_field_psi (this, pp, gp, dr, dxi, num_modes, part_shape) Arguments Type Intent Optional Attributes Name class( field_psi ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape procedure, public :: del => end_field_psi private subroutine end_field_psi (this) Arguments Type Intent Optional Attributes Name class( field_psi ), intent(inout) :: this generic, public :: solve => solve_field_psi private subroutine solve_field_psi (this, q) Arguments Type Intent Optional Attributes Name class( field_psi ), intent(inout) :: this class( field_rho ), intent(in) :: q procedure, private :: init_field_psi private subroutine init_field_psi (this, pp, gp, dr, dxi, num_modes, part_shape) Arguments Type Intent Optional Attributes Name class( field_psi ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape procedure, private :: end_field_psi private subroutine end_field_psi (this) Arguments Type Intent Optional Attributes Name class( field_psi ), intent(inout) :: this procedure, private :: set_source private subroutine set_source (this, mode, q_re, q_im) Arguments Type Intent Optional Attributes Name class( field_psi ), intent(inout) :: this integer, intent(in) :: mode class( ufield ), intent(in) :: q_re class( ufield ), intent(in), optional :: q_im procedure, private :: get_solution private subroutine get_solution (this, mode) Arguments Type Intent Optional Attributes Name class( field_psi ), intent(inout) :: this integer, intent(in) :: mode procedure, private :: solve_field_psi private subroutine solve_field_psi (this, q) Arguments Type Intent Optional Attributes Name class( field_psi ), intent(inout) :: this class( field_rho ), intent(in) :: q","tags":"","loc":"type/field_psi.html"},{"title":"sim_fields – QuickPIC wit Azimuzal Decomposition ","text":"type, private :: sim_fields Inherits type~~sim_fields~~InheritsGraph type~sim_fields sim_fields type~field_jay field_jay type~sim_fields->type~field_jay jay type~field_e field_e type~sim_fields->type~field_e e_spe, e_beam type~field_psi field_psi type~sim_fields->type~field_psi psi type~grid grid type~sim_fields->type~grid gp type~field_rho field_rho type~sim_fields->type~field_rho q_spe, q_beam type~parallel_pipe parallel_pipe type~sim_fields->type~parallel_pipe pp type~field_djdxi field_djdxi type~sim_fields->type~field_djdxi djdxi type~field_b field_b type~sim_fields->type~field_b b_spe, b_beam type~field field type~field_jay->type~field type~field_e->type~field type~field_solver field_solver type~field_e->type~field_solver solver_ez type~field_psi->type~field type~field_psi->type~field_solver solver type~field_rho->type~field type~parallel parallel type~parallel_pipe->type~parallel type~field_djdxi->type~field type~field_b->type~field type~field_b->type~field_solver solver_bz, solver_bperp, solver_bperp_iter type~ufield ufield type~field->type~ufield rf_re, rf_im var pantypesim_fieldsInheritsGraph = svgPanZoom('#typesim_fieldsInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~sim_fields~~InheritedByGraph type~sim_fields sim_fields type~simulation simulation type~simulation->type~sim_fields fields Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables pp gp psi b_spe b_beam e_spe e_beam jay q_spe q_beam djdxi Type-Bound Procedures new del end_sim_fields init_sim_fields Components Type Visibility Attributes Name Initial class( parallel_pipe ), private, pointer :: pp => null() class( grid ), private, pointer :: gp => null() type( field_psi ), private, allocatable :: psi type( field_b ), private, allocatable :: b_spe type( field_b ), private, allocatable :: b_beam type( field_e ), private, allocatable :: e_spe type( field_e ), private, allocatable :: e_beam type( field_jay ), private, allocatable :: jay type( field_rho ), private, allocatable :: q_spe type( field_rho ), private, allocatable :: q_beam type( field_djdxi ), private, allocatable :: djdxi Type-Bound Procedures generic, public :: new => init_sim_fields private subroutine init_sim_fields (this, input, dr, dxi, num_modes, part_shape) Arguments Type Intent Optional Attributes Name class( sim_fields ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape generic, public :: del => end_sim_fields private subroutine end_sim_fields (this) Arguments Type Intent Optional Attributes Name class( sim_fields ), intent(inout) :: this procedure, private :: end_sim_fields private subroutine end_sim_fields (this) Arguments Type Intent Optional Attributes Name class( sim_fields ), intent(inout) :: this procedure, private :: init_sim_fields private subroutine init_sim_fields (this, input, dr, dxi, num_modes, part_shape) Arguments Type Intent Optional Attributes Name class( sim_fields ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape","tags":"","loc":"type/sim_fields.html"},{"title":"simulation – QuickPIC wit Azimuzal Decomposition ","text":"type, public :: simulation Inherits type~~simulation~~InheritsGraph type~simulation simulation type~sim_fields sim_fields type~simulation->type~sim_fields fields type~input_json input_json type~simulation->type~input_json input type~grid grid type~simulation->type~grid gp type~parallel_pipe parallel_pipe type~simulation->type~parallel_pipe pp type~sim_fields->type~grid gp type~sim_fields->type~parallel_pipe pp type~field_jay field_jay type~sim_fields->type~field_jay jay type~field_e field_e type~sim_fields->type~field_e e_spe, e_beam type~field_psi field_psi type~sim_fields->type~field_psi psi type~field_rho field_rho type~sim_fields->type~field_rho q_spe, q_beam type~field_djdxi field_djdxi type~sim_fields->type~field_djdxi djdxi type~field_b field_b type~sim_fields->type~field_b b_spe, b_beam type~input_json->type~grid gp type~input_json->type~parallel_pipe pp type~parallel parallel type~input_json->type~parallel p json_file json_file type~input_json->json_file input type~parallel_pipe->type~parallel type~field field type~field_jay->type~field type~field_e->type~field type~field_solver field_solver type~field_e->type~field_solver solver_ez type~field_psi->type~field type~field_psi->type~field_solver solver type~field_rho->type~field type~field_djdxi->type~field type~field_b->type~field type~field_b->type~field_solver solver_bz, solver_bperp, solver_bperp_iter type~ufield ufield type~field->type~ufield rf_re, rf_im var pantypesimulationInheritsGraph = svgPanZoom('#typesimulationInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables input pp gp fields dr dxi dt iter nstep3d nstep2d start3d nbeams nspecies tstep num_modes interp Type-Bound Procedures new del end_simulation init_simulation Components Type Visibility Attributes Name Initial type( input_json ), private, pointer :: input => null() class( parallel_pipe ), private, pointer :: pp => null() class( grid ), private, pointer :: gp => null() type( sim_fields ), private :: fields real, private :: dr real, private :: dxi real, private :: dt integer, private :: iter integer, private :: nstep3d integer, private :: nstep2d integer, private :: start3d integer, private :: nbeams integer, private :: nspecies integer, private :: tstep integer, private :: num_modes integer, private :: interp Type-Bound Procedures generic, public :: new => init_simulation private subroutine init_simulation (this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout) :: this generic, public :: del => end_simulation private subroutine end_simulation (this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout) :: this procedure, private :: end_simulation private subroutine end_simulation (this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout) :: this procedure, private :: init_simulation private subroutine init_simulation (this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout) :: this","tags":"","loc":"type/simulation.html"},{"title":"field_b – QuickPIC wit Azimuzal Decomposition ","text":"type, public, extends( field ) :: field_b Inherits type~~field_b~~InheritsGraph type~field_b field_b type~field field type~field_b->type~field type~field_solver field_solver type~field_b->type~field_solver solver_bz, solver_bperp, solver_bperp_iter type~ufield ufield type~field->type~ufield rf_re, rf_im Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~field_b~~InheritedByGraph type~field_b field_b type~sim_fields sim_fields type~sim_fields->type~field_b b_spe, b_beam type~simulation simulation type~simulation->type~sim_fields fields Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables rf_re rf_im dr dxi num_modes entity solver_bz solver_bperp solver_bperp_iter buf_re buf_im buf Type-Bound Procedures get_rf_re get_rf_im get_num_modes get_dxi get_dr new del solve init_field_b end_field_b set_source_bz set_source_bperp set_source_bperp_iter get_solution_bz get_solution_bperp get_solution_bperp_iter solve_field_bz solve_field_bperp solve_field_bperp_iter Components Type Visibility Attributes Name Initial class( ufield ), public, dimension(:), pointer :: rf_re => null() class( ufield ), public, dimension(:), pointer :: rf_im => null() real, public :: dr real, public :: dxi integer, public :: num_modes integer, public :: entity class( field_solver ), public, dimension(:), pointer :: solver_bz => null() class( field_solver ), public, dimension(:), pointer :: solver_bperp => null() class( field_solver ), public, dimension(:), pointer :: solver_bperp_iter => null() real, public, dimension(:), pointer :: buf_re => null() real, public, dimension(:), pointer :: buf_im => null() real, public, dimension(:), pointer :: buf => null() Type-Bound Procedures generic, public :: get_rf_re => get_rf_re_all , get_rf_re_mode private function get_rf_re_all (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value type( ufield ),\n  dimension(:), pointer private function get_rf_re_mode (this, mode) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this integer, intent(in) :: mode Return Value type( ufield ),\n  pointer generic, public :: get_rf_im => get_rf_im_all , get_rf_im_mode private function get_rf_im_all (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value type( ufield ),\n  dimension(:), pointer private function get_rf_im_mode (this, mode) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this integer, intent(in) :: mode Return Value type( ufield ),\n  pointer procedure, public :: get_num_modes private function get_num_modes (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value integer procedure, public :: get_dxi private function get_dxi (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value real procedure, public :: get_dr private function get_dr (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value real generic, public :: new => init_field , init_field_b private subroutine init_field (this, pp, gp, dim, dr, dxi, num_modes, gc_num, entity) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp integer, intent(in) :: dim real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in), dimension(2,2) :: gc_num integer, intent(in), optional :: entity private subroutine init_field_b (this, pp, gp, dr, dxi, num_modes, part_shape, entity) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape integer, intent(in) :: entity procedure, public :: del => end_field_b private subroutine end_field_b (this) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this generic, public :: solve => solve_field_bz , solve_field_bperp , solve_field_bperp_iter private subroutine solve_field_bz (this, jay) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this class( field_jay ), intent(in) :: jay private subroutine solve_field_bperp (this, rho) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this class( field_rho ), intent(in) :: rho private subroutine solve_field_bperp_iter (this, djdxi, jay) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this class( field_djdxi ), intent(in) :: djdxi class( field_jay ), intent(in) :: jay procedure, private :: init_field_b private subroutine init_field_b (this, pp, gp, dr, dxi, num_modes, part_shape, entity) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape integer, intent(in) :: entity procedure, private :: end_field_b private subroutine end_field_b (this) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this procedure, private :: set_source_bz private subroutine set_source_bz (this, mode, jay_re, jay_im) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this integer, intent(in) :: mode class( ufield ), intent(in) :: jay_re class( ufield ), intent(in), optional :: jay_im procedure, private :: set_source_bperp private subroutine set_source_bperp (this, mode, q_re, q_im) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this integer, intent(in) :: mode class( ufield ), intent(in) :: q_re class( ufield ), intent(in), optional :: q_im procedure, private :: set_source_bperp_iter private subroutine set_source_bperp_iter (this, mode, djdxi_re, jay_re, djdxi_im, jay_im) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this integer, intent(in) :: mode class( ufield ), intent(in) :: djdxi_re class( ufield ), intent(in) :: jay_re class( ufield ), intent(in), optional :: djdxi_im class( ufield ), intent(in), optional :: jay_im procedure, private :: get_solution_bz private subroutine get_solution_bz (this, mode) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this integer, intent(in) :: mode procedure, private :: get_solution_bperp private subroutine get_solution_bperp (this, mode) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this integer, intent(in) :: mode procedure, private :: get_solution_bperp_iter private subroutine get_solution_bperp_iter (this, mode) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this integer, intent(in) :: mode procedure, private :: solve_field_bz private subroutine solve_field_bz (this, jay) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this class( field_jay ), intent(in) :: jay procedure, private :: solve_field_bperp private subroutine solve_field_bperp (this, rho) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this class( field_rho ), intent(in) :: rho procedure, private :: solve_field_bperp_iter private subroutine solve_field_bperp_iter (this, djdxi, jay) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this class( field_djdxi ), intent(in) :: djdxi class( field_jay ), intent(in) :: jay","tags":"","loc":"type/field_b.html"},{"title":"field_e – QuickPIC wit Azimuzal Decomposition ","text":"type, public, extends( field ) :: field_e Inherits type~~field_e~~InheritsGraph type~field_e field_e type~field field type~field_e->type~field type~field_solver field_solver type~field_e->type~field_solver solver_ez type~ufield ufield type~field->type~ufield rf_re, rf_im Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~field_e~~InheritedByGraph type~field_e field_e type~sim_fields sim_fields type~sim_fields->type~field_e e_spe, e_beam type~simulation simulation type~simulation->type~sim_fields fields Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables rf_re rf_im dr dxi num_modes entity solver_ez buf_re buf_im Type-Bound Procedures get_rf_re get_rf_im get_num_modes get_dxi get_dr new del solve init_field_e end_field_e set_source_ez get_solution_ez solve_field_ez solve_field_eperp solve_field_eperp_beam Components Type Visibility Attributes Name Initial class( ufield ), public, dimension(:), pointer :: rf_re => null() class( ufield ), public, dimension(:), pointer :: rf_im => null() real, public :: dr real, public :: dxi integer, public :: num_modes integer, public :: entity class( field_solver ), public, dimension(:), pointer :: solver_ez => null() real, public, dimension(:), pointer :: buf_re => null() real, public, dimension(:), pointer :: buf_im => null() Type-Bound Procedures generic, public :: get_rf_re => get_rf_re_all , get_rf_re_mode private function get_rf_re_all (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value type( ufield ),\n  dimension(:), pointer private function get_rf_re_mode (this, mode) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this integer, intent(in) :: mode Return Value type( ufield ),\n  pointer generic, public :: get_rf_im => get_rf_im_all , get_rf_im_mode private function get_rf_im_all (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value type( ufield ),\n  dimension(:), pointer private function get_rf_im_mode (this, mode) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this integer, intent(in) :: mode Return Value type( ufield ),\n  pointer procedure, public :: get_num_modes private function get_num_modes (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value integer procedure, public :: get_dxi private function get_dxi (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value real procedure, public :: get_dr private function get_dr (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value real generic, public :: new => init_field , init_field_e private subroutine init_field (this, pp, gp, dim, dr, dxi, num_modes, gc_num, entity) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp integer, intent(in) :: dim real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in), dimension(2,2) :: gc_num integer, intent(in), optional :: entity private subroutine init_field_e (this, pp, gp, dr, dxi, num_modes, part_shape, entity) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape integer, intent(in) :: entity procedure, public :: del => end_field_e private subroutine end_field_e (this) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this generic, public :: solve => solve_field_ez , solve_field_eperp , solve_field_eperp_beam private subroutine solve_field_ez (this, jay) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this class( field_jay ), intent(in) :: jay private subroutine solve_field_eperp (this, b, psi) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this class( field_b ), intent(in) :: b class( field_psi ), intent(in) :: psi private subroutine solve_field_eperp_beam (this, b) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this class( field_b ), intent(in) :: b procedure, private :: init_field_e private subroutine init_field_e (this, pp, gp, dr, dxi, num_modes, part_shape, entity) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape integer, intent(in) :: entity procedure, private :: end_field_e private subroutine end_field_e (this) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this procedure, private :: set_source_ez private subroutine set_source_ez (this, mode, jay_re, jay_im) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this integer, intent(in) :: mode class( ufield ), intent(in) :: jay_re class( ufield ), intent(in), optional :: jay_im procedure, private :: get_solution_ez private subroutine get_solution_ez (this, mode) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this integer, intent(in) :: mode procedure, private :: solve_field_ez private subroutine solve_field_ez (this, jay) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this class( field_jay ), intent(in) :: jay procedure, private :: solve_field_eperp private subroutine solve_field_eperp (this, b, psi) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this class( field_b ), intent(in) :: b class( field_psi ), intent(in) :: psi procedure, private :: solve_field_eperp_beam private subroutine solve_field_eperp_beam (this, b) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this class( field_b ), intent(in) :: b","tags":"","loc":"type/field_e.html"},{"title":"field – QuickPIC wit Azimuzal Decomposition ","text":"type, public :: field Inherits type~~field~~InheritsGraph type~field field type~ufield ufield type~field->type~ufield rf_re, rf_im Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~field~~InheritedByGraph type~field field type~field_jay field_jay type~field_jay->type~field type~field_e field_e type~field_e->type~field type~field_psi field_psi type~field_psi->type~field type~field_rho field_rho type~field_rho->type~field type~field_djdxi field_djdxi type~field_djdxi->type~field type~field_b field_b type~field_b->type~field type~sim_fields sim_fields type~sim_fields->type~field_jay jay type~sim_fields->type~field_e e_spe, e_beam type~sim_fields->type~field_psi psi type~sim_fields->type~field_rho q_spe, q_beam type~sim_fields->type~field_djdxi djdxi type~sim_fields->type~field_b b_spe, b_beam type~simulation simulation type~simulation->type~sim_fields fields Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables rf_re rf_im dr dxi num_modes entity Type-Bound Procedures new del get_rf_re get_rf_im get_num_modes get_dxi get_dr end_field init_field get_rf_im_mode get_rf_im_all get_rf_re_mode get_rf_re_all Components Type Visibility Attributes Name Initial class( ufield ), public, dimension(:), pointer :: rf_re => null() class( ufield ), public, dimension(:), pointer :: rf_im => null() real, public :: dr real, public :: dxi integer, public :: num_modes integer, public :: entity Type-Bound Procedures generic, public :: new => init_field private subroutine init_field (this, pp, gp, dim, dr, dxi, num_modes, gc_num, entity) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp integer, intent(in) :: dim real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in), dimension(2,2) :: gc_num integer, intent(in), optional :: entity procedure, public :: del => end_field private subroutine end_field (this) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this generic, public :: get_rf_re => get_rf_re_all , get_rf_re_mode private function get_rf_re_all (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value type( ufield ),\n  dimension(:), pointer private function get_rf_re_mode (this, mode) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this integer, intent(in) :: mode Return Value type( ufield ),\n  pointer generic, public :: get_rf_im => get_rf_im_all , get_rf_im_mode private function get_rf_im_all (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value type( ufield ),\n  dimension(:), pointer private function get_rf_im_mode (this, mode) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this integer, intent(in) :: mode Return Value type( ufield ),\n  pointer procedure, public :: get_num_modes private function get_num_modes (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value integer procedure, public :: get_dxi private function get_dxi (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value real procedure, public :: get_dr private function get_dr (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value real procedure, private :: end_field private subroutine end_field (this) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this procedure, private :: init_field private subroutine init_field (this, pp, gp, dim, dr, dxi, num_modes, gc_num, entity) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp integer, intent(in) :: dim real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in), dimension(2,2) :: gc_num integer, intent(in), optional :: entity procedure, private :: get_rf_im_mode private function get_rf_im_mode (this, mode) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this integer, intent(in) :: mode Return Value type( ufield ),\n  pointer procedure, private :: get_rf_im_all private function get_rf_im_all (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value type( ufield ),\n  dimension(:), pointer procedure, private :: get_rf_re_mode private function get_rf_re_mode (this, mode) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this integer, intent(in) :: mode Return Value type( ufield ),\n  pointer procedure, private :: get_rf_re_all private function get_rf_re_all (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value type( ufield ),\n  dimension(:), pointer","tags":"","loc":"type/field.html"},{"title":"parallel – QuickPIC wit Azimuzal Decomposition ","text":"type, public :: parallel Inherited by type~~parallel~~InheritedByGraph type~parallel parallel type~input_json input_json type~input_json->type~parallel p type~parallel_pipe parallel_pipe type~input_json->type~parallel_pipe pp type~parallel_pipe->type~parallel type~simulation simulation type~simulation->type~input_json input type~simulation->type~parallel_pipe pp type~sim_fields sim_fields type~simulation->type~sim_fields fields type~sim_fields->type~parallel_pipe pp Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nvp idproc kstrt mreal mint mcplx mdouble mchar lworld Type-Bound Procedures new del getnvp getidproc getkstrt getlworld getmreal getmint getmdouble getmcplx getmchar init_parallel end_parallel Components Type Visibility Attributes Name Initial integer, private :: nvp integer, private :: idproc integer, private :: kstrt integer, private :: mreal integer, private :: mint integer, private :: mcplx integer, private :: mdouble integer, private :: mchar integer, private :: lworld Type-Bound Procedures generic, public :: new => init_parallel private subroutine init_parallel (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(inout) :: this generic, public :: del => end_parallel private subroutine end_parallel (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(inout) :: this procedure, public :: getnvp private function getnvp (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getidproc private function getidproc (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getkstrt private function getkstrt (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getlworld private function getlworld (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getmreal private function getmreal (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getmint private function getmint (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getmdouble private function getmdouble (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getmcplx private function getmcplx (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getmchar private function getmchar (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, private :: init_parallel private subroutine init_parallel (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(inout) :: this procedure, private :: end_parallel private subroutine end_parallel (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(inout) :: this","tags":"","loc":"type/parallel.html"},{"title":"field_rho – QuickPIC wit Azimuzal Decomposition ","text":"type, public, extends( field ) :: field_rho Inherits type~~field_rho~~InheritsGraph type~field_rho field_rho type~field field type~field_rho->type~field type~ufield ufield type~field->type~ufield rf_re, rf_im Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~field_rho~~InheritedByGraph type~field_rho field_rho type~sim_fields sim_fields type~sim_fields->type~field_rho q_spe, q_beam type~simulation simulation type~simulation->type~sim_fields fields Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables rf_re rf_im dr dxi num_modes entity Type-Bound Procedures del get_rf_re get_rf_im get_num_modes get_dxi get_dr new init_field_rho Components Type Visibility Attributes Name Initial class( ufield ), public, dimension(:), pointer :: rf_re => null() class( ufield ), public, dimension(:), pointer :: rf_im => null() real, public :: dr real, public :: dxi integer, public :: num_modes integer, public :: entity Type-Bound Procedures procedure, public :: del => end_field private subroutine end_field (this) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this generic, public :: get_rf_re => get_rf_re_all , get_rf_re_mode private function get_rf_re_all (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value type( ufield ),\n  dimension(:), pointer private function get_rf_re_mode (this, mode) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this integer, intent(in) :: mode Return Value type( ufield ),\n  pointer generic, public :: get_rf_im => get_rf_im_all , get_rf_im_mode private function get_rf_im_all (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value type( ufield ),\n  dimension(:), pointer private function get_rf_im_mode (this, mode) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this integer, intent(in) :: mode Return Value type( ufield ),\n  pointer procedure, public :: get_num_modes private function get_num_modes (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value integer procedure, public :: get_dxi private function get_dxi (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value real procedure, public :: get_dr private function get_dr (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value real generic, public :: new => init_field , init_field_rho private subroutine init_field (this, pp, gp, dim, dr, dxi, num_modes, gc_num, entity) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp integer, intent(in) :: dim real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in), dimension(2,2) :: gc_num integer, intent(in), optional :: entity private subroutine init_field_rho (this, pp, gp, dr, dxi, num_modes, part_shape) Arguments Type Intent Optional Attributes Name class( field_rho ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape procedure, private :: init_field_rho private subroutine init_field_rho (this, pp, gp, dr, dxi, num_modes, part_shape) Arguments Type Intent Optional Attributes Name class( field_rho ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape","tags":"","loc":"type/field_rho.html"},{"title":"field_jay – QuickPIC wit Azimuzal Decomposition ","text":"type, public, extends( field ) :: field_jay Inherits type~~field_jay~~InheritsGraph type~field_jay field_jay type~field field type~field_jay->type~field type~ufield ufield type~field->type~ufield rf_re, rf_im Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~field_jay~~InheritedByGraph type~field_jay field_jay type~sim_fields sim_fields type~sim_fields->type~field_jay jay type~simulation simulation type~simulation->type~sim_fields fields Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables rf_re rf_im dr dxi num_modes entity Type-Bound Procedures del get_rf_re get_rf_im get_num_modes get_dxi get_dr new init_field_jay Components Type Visibility Attributes Name Initial class( ufield ), public, dimension(:), pointer :: rf_re => null() class( ufield ), public, dimension(:), pointer :: rf_im => null() real, public :: dr real, public :: dxi integer, public :: num_modes integer, public :: entity Type-Bound Procedures procedure, public :: del => end_field private subroutine end_field (this) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this generic, public :: get_rf_re => get_rf_re_all , get_rf_re_mode private function get_rf_re_all (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value type( ufield ),\n  dimension(:), pointer private function get_rf_re_mode (this, mode) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this integer, intent(in) :: mode Return Value type( ufield ),\n  pointer generic, public :: get_rf_im => get_rf_im_all , get_rf_im_mode private function get_rf_im_all (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value type( ufield ),\n  dimension(:), pointer private function get_rf_im_mode (this, mode) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this integer, intent(in) :: mode Return Value type( ufield ),\n  pointer procedure, public :: get_num_modes private function get_num_modes (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value integer procedure, public :: get_dxi private function get_dxi (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value real procedure, public :: get_dr private function get_dr (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value real generic, public :: new => init_field , init_field_jay private subroutine init_field (this, pp, gp, dim, dr, dxi, num_modes, gc_num, entity) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp integer, intent(in) :: dim real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in), dimension(2,2) :: gc_num integer, intent(in), optional :: entity private subroutine init_field_jay (this, pp, gp, dr, dxi, num_modes, part_shape) Arguments Type Intent Optional Attributes Name class( field_jay ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape procedure, private :: init_field_jay private subroutine init_field_jay (this, pp, gp, dr, dxi, num_modes, part_shape) Arguments Type Intent Optional Attributes Name class( field_jay ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape","tags":"","loc":"type/field_jay.html"},{"title":"field_djdxi – QuickPIC wit Azimuzal Decomposition ","text":"type, public, extends( field ) :: field_djdxi Inherits type~~field_djdxi~~InheritsGraph type~field_djdxi field_djdxi type~field field type~field_djdxi->type~field type~ufield ufield type~field->type~ufield rf_re, rf_im Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~field_djdxi~~InheritedByGraph type~field_djdxi field_djdxi type~sim_fields sim_fields type~sim_fields->type~field_djdxi djdxi type~simulation simulation type~simulation->type~sim_fields fields Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables rf_re rf_im dr dxi num_modes entity Type-Bound Procedures del get_rf_re get_rf_im get_num_modes get_dxi get_dr new init_field_djdxi Components Type Visibility Attributes Name Initial class( ufield ), public, dimension(:), pointer :: rf_re => null() class( ufield ), public, dimension(:), pointer :: rf_im => null() real, public :: dr real, public :: dxi integer, public :: num_modes integer, public :: entity Type-Bound Procedures procedure, public :: del => end_field private subroutine end_field (this) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this generic, public :: get_rf_re => get_rf_re_all , get_rf_re_mode private function get_rf_re_all (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value type( ufield ),\n  dimension(:), pointer private function get_rf_re_mode (this, mode) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this integer, intent(in) :: mode Return Value type( ufield ),\n  pointer generic, public :: get_rf_im => get_rf_im_all , get_rf_im_mode private function get_rf_im_all (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value type( ufield ),\n  dimension(:), pointer private function get_rf_im_mode (this, mode) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this integer, intent(in) :: mode Return Value type( ufield ),\n  pointer procedure, public :: get_num_modes private function get_num_modes (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value integer procedure, public :: get_dxi private function get_dxi (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value real procedure, public :: get_dr private function get_dr (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value real generic, public :: new => init_field , init_field_djdxi private subroutine init_field (this, pp, gp, dim, dr, dxi, num_modes, gc_num, entity) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp integer, intent(in) :: dim real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in), dimension(2,2) :: gc_num integer, intent(in), optional :: entity private subroutine init_field_djdxi (this, pp, gp, dr, dxi, num_modes, part_shape) Arguments Type Intent Optional Attributes Name class( field_djdxi ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape procedure, private :: init_field_djdxi private subroutine init_field_djdxi (this, pp, gp, dr, dxi, num_modes, part_shape) Arguments Type Intent Optional Attributes Name class( field_djdxi ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape","tags":"","loc":"type/field_djdxi.html"},{"title":"field_solver – QuickPIC wit Azimuzal Decomposition ","text":"type, public :: field_solver Inherited by type~~field_solver~~InheritedByGraph type~field_solver field_solver type~field_e field_e type~field_e->type~field_solver solver_ez type~field_psi field_psi type~field_psi->type~field_solver solver type~field_b field_b type~field_b->type~field_solver solver_bz, solver_bperp, solver_bperp_iter type~sim_fields sim_fields type~sim_fields->type~field_e e_spe, e_beam type~sim_fields->type~field_psi psi type~sim_fields->type~field_b b_spe, b_beam type~simulation simulation type~simulation->type~sim_fields fields Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables offsets stencil_idx num_stencil solver_type kind mode tol A b x grid stencil solver precond par_A par_b par_x iupper ilower Type-Bound Procedures new solve del end_field_solver init_field_solver set_struct_solver solve_equation set_struct_grid set_struct_stencil set_struct_matrix set_ij_matrix set_ij_solver Components Type Visibility Attributes Name Initial integer, public, dimension(:), pointer :: offsets => null() integer, public, dimension(:), pointer :: stencil_idx => null() integer, public :: num_stencil integer, public :: solver_type integer, public :: kind integer, public :: mode real, public :: tol integer(kind=HYPRE_TYPE), public :: A integer(kind=HYPRE_TYPE), public :: b integer(kind=HYPRE_TYPE), public :: x integer(kind=HYPRE_TYPE), public :: grid integer(kind=HYPRE_TYPE), public :: stencil integer(kind=HYPRE_TYPE), public :: solver integer(kind=HYPRE_TYPE), public :: precond integer(kind=HYPRE_TYPE), public :: par_A integer(kind=HYPRE_TYPE), public :: par_b integer(kind=HYPRE_TYPE), public :: par_x integer, public :: iupper integer, public :: ilower Type-Bound Procedures generic, public :: new => init_field_solver private subroutine init_field_solver (this, nd, ndp, noff, kind, mode, dr, solver_type, tol) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this integer, intent(in), dimension(2) :: nd integer, intent(in), dimension(2) :: ndp integer, intent(in), dimension(2) :: noff integer, intent(in) :: kind integer, intent(in) :: mode real, intent(in) :: dr integer, intent(in) :: solver_type real, intent(in) :: tol generic, public :: solve => solve_equation private subroutine solve_equation (this, src_sol) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this real, intent(inout), dimension(:), pointer :: src_sol generic, public :: del => end_field_solver private subroutine end_field_solver (this) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this procedure, private :: end_field_solver private subroutine end_field_solver (this) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this procedure, private :: init_field_solver private subroutine init_field_solver (this, nd, ndp, noff, kind, mode, dr, solver_type, tol) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this integer, intent(in), dimension(2) :: nd integer, intent(in), dimension(2) :: ndp integer, intent(in), dimension(2) :: noff integer, intent(in) :: kind integer, intent(in) :: mode real, intent(in) :: dr integer, intent(in) :: solver_type real, intent(in) :: tol procedure, private :: set_struct_solver private subroutine set_struct_solver (this, comm) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this integer, intent(in) :: comm procedure, private :: solve_equation private subroutine solve_equation (this, src_sol) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this real, intent(inout), dimension(:), pointer :: src_sol procedure, private :: set_struct_grid private subroutine set_struct_grid (this, comm, ndp, noff) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this integer, intent(in) :: comm integer, intent(in), dimension(2) :: ndp integer, intent(in), dimension(2) :: noff procedure, private :: set_struct_stencil private subroutine set_struct_stencil (this) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this procedure, private :: set_struct_matrix private subroutine set_struct_matrix (this, comm, nd, dr) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this integer, intent(in) :: comm integer, intent(in), dimension(:) :: nd real, intent(in) :: dr procedure, private :: set_ij_matrix private subroutine set_ij_matrix (this, comm, nd, ndp, noff, dr) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this integer, intent(in) :: comm integer, intent(in), dimension(:) :: nd integer, intent(in), dimension(:) :: ndp integer, intent(in), dimension(:) :: noff real, intent(in) :: dr procedure, private :: set_ij_solver private subroutine set_ij_solver (this, comm) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this integer, intent(in) :: comm","tags":"","loc":"type/field_solver.html"},{"title":"parallel_pipe – QuickPIC wit Azimuzal Decomposition ","text":"type, public, extends( parallel ) :: parallel_pipe Inherits type~~parallel_pipe~~InheritsGraph type~parallel_pipe parallel_pipe type~parallel parallel type~parallel_pipe->type~parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~parallel_pipe~~InheritedByGraph type~parallel_pipe parallel_pipe type~simulation simulation type~simulation->type~parallel_pipe pp type~input_json input_json type~simulation->type~input_json input type~sim_fields sim_fields type~simulation->type~sim_fields fields type~input_json->type~parallel_pipe pp type~sim_fields->type~parallel_pipe pp Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nstage stageid lidproc lkstrt lgrp lnvp Type-Bound Procedures del getnvp getidproc getkstrt getlworld getmreal getmint getmdouble getmcplx getmchar getnstage getstageid getlidproc getlkstrt getlgrp getlnvp init_parallel_pipe new Components Type Visibility Attributes Name Initial integer, private :: nstage = 1 integer, private :: stageid = 0 integer, private :: lidproc integer, private :: lkstrt integer, private :: lgrp integer, private :: lnvp Type-Bound Procedures generic, public :: del => end_parallel private subroutine end_parallel (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(inout) :: this procedure, public :: getnvp private function getnvp (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getidproc private function getidproc (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getkstrt private function getkstrt (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getlworld private function getlworld (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getmreal private function getmreal (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getmint private function getmint (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getmdouble private function getmdouble (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getmcplx private function getmcplx (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getmchar private function getmchar (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getnstage private function getnstage (this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer procedure, public :: getstageid private function getstageid (this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer procedure, public :: getlidproc private function getlidproc (this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer procedure, public :: getlkstrt private function getlkstrt (this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer procedure, public :: getlgrp private function getlgrp (this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer procedure, public :: getlnvp private function getlnvp (this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer procedure, private :: init_parallel_pipe private subroutine init_parallel_pipe (this, nst) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(inout) :: this integer, intent(in) :: nst generic, public :: new => init_parallel , init_parallel_pipe private subroutine init_parallel (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(inout) :: this private subroutine init_parallel_pipe (this, nst) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(inout) :: this integer, intent(in) :: nst","tags":"","loc":"type/parallel_pipe.html"},{"title":"ufield – QuickPIC wit Azimuzal Decomposition ","text":"type, public :: ufield Inherited by type~~ufield~~InheritedByGraph type~ufield ufield type~field field type~field->type~ufield rf_re, rf_im type~field_jay field_jay type~field_jay->type~field type~field_e field_e type~field_e->type~field type~field_psi field_psi type~field_psi->type~field type~field_rho field_rho type~field_rho->type~field type~field_djdxi field_djdxi type~field_djdxi->type~field type~field_b field_b type~field_b->type~field type~sim_fields sim_fields type~sim_fields->type~field_jay jay type~sim_fields->type~field_e e_spe, e_beam type~sim_fields->type~field_psi psi type~sim_fields->type~field_rho q_spe, q_beam type~sim_fields->type~field_djdxi djdxi type~sim_fields->type~field_b b_spe, b_beam type~simulation simulation type~simulation->type~sim_fields fields Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables f1 f2 nd ndp nvp dim noff gc_num has_2d buf Type-Bound Procedures new del get_nd get_ndp get_gc_num get_nvp get_noff get_dim copy_slice get_f1 get_f2 assignment(=) operator(+) operator(-) operator(*) end_ufield init_ufield_cp init_ufield get_nd_dim get_nd_all get_ndp_dim get_ndp_all get_gc_num_dim get_gc_num_all get_nvp_dim get_nvp_all get_noff_dim get_noff_all add_scalar2 add_scalar1 add_array dot_scalar2 dot_scalar1 dot_array sub_scalar2 sub_scalar1 sub_array assign_array Components Type Visibility Attributes Name Initial real, public, dimension(:,:), pointer :: f1 => null() real, private, dimension(:,:,:), pointer :: f2 => null() integer, private, dimension(2) :: nd integer, private, dimension(2) :: ndp integer, private, dimension(2) :: nvp integer, private :: dim integer, private, dimension(2) :: noff integer, private, dimension(2,2) :: gc_num logical, private :: has_2d real, private, dimension(:), pointer :: buf => null() Type-Bound Procedures generic, public :: new => init_ufield , init_ufield_cp private subroutine init_ufield (this, pp, gp, dim, gc_num, has_2d) Arguments Type Intent Optional Attributes Name class( ufield ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp integer, intent(in) :: dim integer, intent(in), dimension(2,2) :: gc_num logical, intent(in), optional :: has_2d private subroutine init_ufield_cp (this, that, has_2d) Arguments Type Intent Optional Attributes Name class( ufield ), intent(inout) :: this class( ufield ), intent(in) :: that logical, intent(in), optional :: has_2d generic, public :: del => end_ufield private subroutine end_ufield (this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(inout) :: this generic, public :: get_nd => get_nd_all , get_nd_dim private function get_nd_all (this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value integer,\n  dimension(2) private function get_nd_dim (this, dim) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this integer, intent(in) :: dim Return Value integer generic, public :: get_ndp => get_ndp_all , get_ndp_dim private function get_ndp_all (this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value integer,\n  dimension(2) private function get_ndp_dim (this, dim) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this integer, intent(in) :: dim Return Value integer generic, public :: get_gc_num => get_gc_num_all , get_gc_num_dim private function get_gc_num_all (this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value integer,\n  dimension(2,2) private function get_gc_num_dim (this, dim) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this integer, intent(in) :: dim Return Value integer,\n  dimension(2) generic, public :: get_nvp => get_nvp_all , get_nvp_dim private function get_nvp_all (this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value integer,\n  dimension(2) private function get_nvp_dim (this, dim) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this integer, intent(in) :: dim Return Value integer generic, public :: get_noff => get_noff_all , get_noff_dim private function get_noff_all (this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value integer,\n  dimension(2) private function get_noff_dim (this, dim) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this integer, intent(in) :: dim Return Value integer procedure, public :: get_dim private function get_dim (this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value integer procedure, public :: copy_slice private subroutine copy_slice (this, idx, dir) Arguments Type Intent Optional Attributes Name class( ufield ), intent(inout) :: this integer, intent(in) :: idx integer, intent(in) :: dir procedure, public :: get_f1 private function get_f1 (this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value real,\n  dimension(:,:), pointer procedure, public :: get_f2 private function get_f2 (this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value real,\n  dimension(:,:,:), pointer generic, public :: assignment(=) => assign_array private subroutine assign_array (this, that) Arguments Type Intent Optional Attributes Name class( ufield ), intent(inout) :: this class(*), intent(in) :: that generic, public :: operator(+) => add_array , add_scalar1 , add_scalar2 private function add_array (a1, a2) result(a3) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: a1 class( ufield ), intent(in) :: a2 Return Value class( ufield ),\n  allocatable private function add_scalar1 (a1, a2) result(a3) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: a1 real, intent(in) :: a2 Return Value class( ufield ),\n  allocatable private function add_scalar2 (a2, a1) result(a3) Arguments Type Intent Optional Attributes Name real, intent(in) :: a2 class( ufield ), intent(in) :: a1 Return Value class( ufield ),\n  allocatable generic, public :: operator(-) => sub_array , sub_scalar1 , sub_scalar2 private function sub_array (a1, a2) result(a3) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: a1 class( ufield ), intent(in) :: a2 Return Value class( ufield ),\n  allocatable private function sub_scalar1 (a1, a2) result(a3) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: a1 real, intent(in) :: a2 Return Value class( ufield ),\n  allocatable private function sub_scalar2 (a2, a1) result(a3) Arguments Type Intent Optional Attributes Name real, intent(in) :: a2 class( ufield ), intent(in) :: a1 Return Value class( ufield ),\n  allocatable generic, public :: operator(*) => dot_array , dot_scalar1 , dot_scalar2 private function dot_array (a1, a2) result(a3) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: a1 class( ufield ), intent(in) :: a2 Return Value class( ufield ),\n  allocatable private function dot_scalar1 (a1, a2) result(a3) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: a1 real, intent(in) :: a2 Return Value class( ufield ),\n  allocatable private function dot_scalar2 (a2, a1) result(a3) Arguments Type Intent Optional Attributes Name real, intent(in) :: a2 class( ufield ), intent(in) :: a1 Return Value class( ufield ),\n  allocatable procedure, private :: end_ufield private subroutine end_ufield (this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(inout) :: this procedure, private :: init_ufield_cp private subroutine init_ufield_cp (this, that, has_2d) Arguments Type Intent Optional Attributes Name class( ufield ), intent(inout) :: this class( ufield ), intent(in) :: that logical, intent(in), optional :: has_2d procedure, private :: init_ufield private subroutine init_ufield (this, pp, gp, dim, gc_num, has_2d) Arguments Type Intent Optional Attributes Name class( ufield ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp integer, intent(in) :: dim integer, intent(in), dimension(2,2) :: gc_num logical, intent(in), optional :: has_2d procedure, private :: get_nd_dim private function get_nd_dim (this, dim) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this integer, intent(in) :: dim Return Value integer procedure, private :: get_nd_all private function get_nd_all (this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value integer,\n  dimension(2) procedure, private :: get_ndp_dim private function get_ndp_dim (this, dim) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this integer, intent(in) :: dim Return Value integer procedure, private :: get_ndp_all private function get_ndp_all (this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value integer,\n  dimension(2) procedure, private :: get_gc_num_dim private function get_gc_num_dim (this, dim) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this integer, intent(in) :: dim Return Value integer,\n  dimension(2) procedure, private :: get_gc_num_all private function get_gc_num_all (this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value integer,\n  dimension(2,2) procedure, private :: get_nvp_dim private function get_nvp_dim (this, dim) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this integer, intent(in) :: dim Return Value integer procedure, private :: get_nvp_all private function get_nvp_all (this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value integer,\n  dimension(2) procedure, private :: get_noff_dim private function get_noff_dim (this, dim) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this integer, intent(in) :: dim Return Value integer procedure, private :: get_noff_all private function get_noff_all (this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value integer,\n  dimension(2) procedure, private, pass(a1) :: add_scalar2 private function add_scalar2 (a2, a1) result(a3) Arguments Type Intent Optional Attributes Name real, intent(in) :: a2 class( ufield ), intent(in) :: a1 Return Value class( ufield ),\n  allocatable procedure, private, pass(a1) :: add_scalar1 private function add_scalar1 (a1, a2) result(a3) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: a1 real, intent(in) :: a2 Return Value class( ufield ),\n  allocatable procedure, private, pass(a1) :: add_array private function add_array (a1, a2) result(a3) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: a1 class( ufield ), intent(in) :: a2 Return Value class( ufield ),\n  allocatable procedure, private, pass(a1) :: dot_scalar2 private function dot_scalar2 (a2, a1) result(a3) Arguments Type Intent Optional Attributes Name real, intent(in) :: a2 class( ufield ), intent(in) :: a1 Return Value class( ufield ),\n  allocatable procedure, private, pass(a1) :: dot_scalar1 private function dot_scalar1 (a1, a2) result(a3) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: a1 real, intent(in) :: a2 Return Value class( ufield ),\n  allocatable procedure, private, pass(a1) :: dot_array private function dot_array (a1, a2) result(a3) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: a1 class( ufield ), intent(in) :: a2 Return Value class( ufield ),\n  allocatable procedure, private, pass(a1) :: sub_scalar2 private function sub_scalar2 (a2, a1) result(a3) Arguments Type Intent Optional Attributes Name real, intent(in) :: a2 class( ufield ), intent(in) :: a1 Return Value class( ufield ),\n  allocatable procedure, private, pass(a1) :: sub_scalar1 private function sub_scalar1 (a1, a2) result(a3) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: a1 real, intent(in) :: a2 Return Value class( ufield ),\n  allocatable procedure, private, pass(a1) :: sub_array private function sub_array (a1, a2) result(a3) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: a1 class( ufield ), intent(in) :: a2 Return Value class( ufield ),\n  allocatable procedure, private :: assign_array private subroutine assign_array (this, that) Arguments Type Intent Optional Attributes Name class( ufield ), intent(inout) :: this class(*), intent(in) :: that","tags":"","loc":"type/ufield.html"},{"title":"found – QuickPIC wit Azimuzal Decomposition","text":"private function found(this, path) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path Return Value logical Calls proc~~found~~CallsGraph proc~found found write_dbg write_dbg proc~found->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/found.html"},{"title":"read_input_json – QuickPIC wit Azimuzal Decomposition","text":"private subroutine read_input_json(this) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this Calls proc~~read_input_json~~CallsGraph proc~read_input_json read_input_json write_err write_err proc~read_input_json->write_err write_dbg write_dbg proc~read_input_json->write_dbg mpi_bcast mpi_bcast proc~read_input_json->mpi_bcast Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/read_input_json.html"},{"title":"initialize – QuickPIC wit Azimuzal Decomposition","text":"private subroutine initialize(this, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys, no_whitespace, unescape_strings, comment_char, path_mode, path_separator, compress_vectors, allow_duplicate_keys) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this logical, intent(in), optional :: verbose logical, intent(in), optional :: compact_reals logical, intent(in), optional :: print_signs character(len=*), intent(in), optional :: real_format integer, intent(in), optional :: spaces_per_tab logical, intent(in), optional :: strict_type_checking logical, intent(in), optional :: trailing_spaces_significant logical, intent(in), optional :: case_sensitive_keys logical, intent(in), optional :: no_whitespace logical, intent(in), optional :: unescape_strings character(len=1), intent(in), optional :: comment_char integer, intent(in), optional :: path_mode character(len=1), intent(in), optional :: path_separator logical, intent(in), optional :: compress_vectors logical, intent(in), optional :: allow_duplicate_keys Calls proc~~initialize~~CallsGraph proc~initialize initialize write_dbg write_dbg proc~initialize->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initialize.html"},{"title":"set_json_core_in_file – QuickPIC wit Azimuzal Decomposition","text":"private subroutine set_json_core_in_file(this, core) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this type(json_core), intent(in) :: core Calls proc~~set_json_core_in_file~~CallsGraph proc~set_json_core_in_file set_json_core_in_file write_dbg write_dbg proc~set_json_core_in_file->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_json_core_in_file.html"},{"title":"load_file – QuickPIC wit Azimuzal Decomposition","text":"private subroutine load_file(this, filename, unit) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: filename integer, intent(in), optional :: unit Calls proc~~load_file~~CallsGraph proc~load_file load_file write_dbg write_dbg proc~load_file->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/load_file.html"},{"title":"print_to_string – QuickPIC wit Azimuzal Decomposition","text":"private subroutine print_to_string(this, str) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=:), intent(out), allocatable :: str Calls proc~~print_to_string~~CallsGraph proc~print_to_string print_to_string write_dbg write_dbg proc~print_to_string->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/print_to_string.html"},{"title":"load_from_string – QuickPIC wit Azimuzal Decomposition","text":"private subroutine load_from_string(this, str) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: str Calls proc~~load_from_string~~CallsGraph proc~load_from_string load_from_string write_dbg write_dbg proc~load_from_string->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/load_from_string.html"},{"title":"json_file_get_object – QuickPIC wit Azimuzal Decomposition","text":"private subroutine json_file_get_object(this, path, p) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path type(json_value), intent(out), pointer :: p Calls proc~~json_file_get_object~~CallsGraph proc~json_file_get_object json_file_get_object write_err write_err proc~json_file_get_object->write_err write_dbg write_dbg proc~json_file_get_object->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/json_file_get_object.html"},{"title":"json_file_get_integer – QuickPIC wit Azimuzal Decomposition","text":"private subroutine json_file_get_integer(this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path integer, intent(out) :: val Calls proc~~json_file_get_integer~~CallsGraph proc~json_file_get_integer json_file_get_integer write_err write_err proc~json_file_get_integer->write_err write_dbg write_dbg proc~json_file_get_integer->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/json_file_get_integer.html"},{"title":"json_file_get_double – QuickPIC wit Azimuzal Decomposition","text":"private subroutine json_file_get_double(this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path real, intent(out) :: val Calls proc~~json_file_get_double~~CallsGraph proc~json_file_get_double json_file_get_double write_err write_err proc~json_file_get_double->write_err write_dbg write_dbg proc~json_file_get_double->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/json_file_get_double.html"},{"title":"json_file_get_logical – QuickPIC wit Azimuzal Decomposition","text":"private subroutine json_file_get_logical(this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path logical, intent(out) :: val Calls proc~~json_file_get_logical~~CallsGraph proc~json_file_get_logical json_file_get_logical write_err write_err proc~json_file_get_logical->write_err write_dbg write_dbg proc~json_file_get_logical->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/json_file_get_logical.html"},{"title":"json_file_get_string – QuickPIC wit Azimuzal Decomposition","text":"private subroutine json_file_get_string(this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path character(len=:), intent(out), allocatable :: val Calls proc~~json_file_get_string~~CallsGraph proc~json_file_get_string json_file_get_string write_err write_err proc~json_file_get_string->write_err write_dbg write_dbg proc~json_file_get_string->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/json_file_get_string.html"},{"title":"json_file_get_integer_vec – QuickPIC wit Azimuzal Decomposition","text":"private subroutine json_file_get_integer_vec(this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path integer, intent(out), dimension(:), allocatable :: vec Calls proc~~json_file_get_integer_vec~~CallsGraph proc~json_file_get_integer_vec json_file_get_integer_vec write_err write_err proc~json_file_get_integer_vec->write_err write_dbg write_dbg proc~json_file_get_integer_vec->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/json_file_get_integer_vec.html"},{"title":"json_file_get_double_vec – QuickPIC wit Azimuzal Decomposition","text":"private subroutine json_file_get_double_vec(this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path real, intent(out), dimension(:), allocatable :: vec Calls proc~~json_file_get_double_vec~~CallsGraph proc~json_file_get_double_vec json_file_get_double_vec write_err write_err proc~json_file_get_double_vec->write_err write_dbg write_dbg proc~json_file_get_double_vec->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/json_file_get_double_vec.html"},{"title":"json_file_get_logical_vec – QuickPIC wit Azimuzal Decomposition","text":"private subroutine json_file_get_logical_vec(this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path logical, intent(out), dimension(:), allocatable :: vec Calls proc~~json_file_get_logical_vec~~CallsGraph proc~json_file_get_logical_vec json_file_get_logical_vec write_err write_err proc~json_file_get_logical_vec->write_err write_dbg write_dbg proc~json_file_get_logical_vec->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/json_file_get_logical_vec.html"},{"title":"json_file_get_string_vec – QuickPIC wit Azimuzal Decomposition","text":"private subroutine json_file_get_string_vec(this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path character(len=*), intent(out), dimension(:), allocatable :: vec Calls proc~~json_file_get_string_vec~~CallsGraph proc~json_file_get_string_vec json_file_get_string_vec write_err write_err proc~json_file_get_string_vec->write_err write_dbg write_dbg proc~json_file_get_string_vec->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/json_file_get_string_vec.html"},{"title":"json_file_get_alloc_string_vec – QuickPIC wit Azimuzal Decomposition","text":"private subroutine json_file_get_alloc_string_vec(this, path, vec, ilen) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path character(len=:), intent(out), dimension(:), allocatable :: vec integer, intent(out), dimension(:), allocatable :: ilen Calls proc~~json_file_get_alloc_string_vec~~CallsGraph proc~json_file_get_alloc_string_vec json_file_get_alloc_string_vec write_err write_err proc~json_file_get_alloc_string_vec->write_err write_dbg write_dbg proc~json_file_get_alloc_string_vec->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/json_file_get_alloc_string_vec.html"},{"title":"json_file_get_root – QuickPIC wit Azimuzal Decomposition","text":"private subroutine json_file_get_root(this, p) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this type(json_value), intent(out), pointer :: p Calls proc~~json_file_get_root~~CallsGraph proc~json_file_get_root json_file_get_root write_dbg write_dbg proc~json_file_get_root->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/json_file_get_root.html"},{"title":"json_file_variable_info – QuickPIC wit Azimuzal Decomposition","text":"private subroutine json_file_variable_info(this, path, n_children) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path integer, intent(out) :: n_children Calls proc~~json_file_variable_info~~CallsGraph proc~json_file_variable_info json_file_variable_info write_err write_err proc~json_file_variable_info->write_err write_dbg write_dbg proc~json_file_variable_info->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/json_file_variable_info.html"},{"title":"get_nd_all – QuickPIC wit Azimuzal Decomposition","text":"private function get_nd_all(this) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this Return Value integer,\n  dimension(2) Contents None","tags":"","loc":"proc/get_nd_all.html"},{"title":"get_nd_dim – QuickPIC wit Azimuzal Decomposition","text":"private function get_nd_dim(this, dim) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this integer, intent(in) :: dim Return Value integer Contents None","tags":"","loc":"proc/get_nd_dim.html"},{"title":"get_ndp_all – QuickPIC wit Azimuzal Decomposition","text":"private function get_ndp_all(this) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this Return Value integer,\n  dimension(2) Contents None","tags":"","loc":"proc/get_ndp_all.html"},{"title":"get_ndp_dim – QuickPIC wit Azimuzal Decomposition","text":"private function get_ndp_dim(this, dim) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this integer, intent(in) :: dim Return Value integer Contents None","tags":"","loc":"proc/get_ndp_dim.html"},{"title":"get_nvp_all – QuickPIC wit Azimuzal Decomposition","text":"private function get_nvp_all(this) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this Return Value integer,\n  dimension(2) Contents None","tags":"","loc":"proc/get_nvp_all.html"},{"title":"get_nvp_dim – QuickPIC wit Azimuzal Decomposition","text":"private function get_nvp_dim(this, dim) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this integer, intent(in) :: dim Return Value integer Contents None","tags":"","loc":"proc/get_nvp_dim.html"},{"title":"get_noff_all – QuickPIC wit Azimuzal Decomposition","text":"private function get_noff_all(this) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this Return Value integer,\n  dimension(2) Contents None","tags":"","loc":"proc/get_noff_all.html"},{"title":"get_noff_dim – QuickPIC wit Azimuzal Decomposition","text":"private function get_noff_dim(this, dim) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this integer, intent(in) :: dim Return Value integer Contents None","tags":"","loc":"proc/get_noff_dim.html"},{"title":"init_grid – QuickPIC wit Azimuzal Decomposition","text":"private subroutine init_grid(this, pp, nr, nz) Arguments Type Intent Optional Attributes Name class( grid ), intent(inout) :: this class( parallel_pipe ), intent(in) :: pp integer, intent(in) :: nr integer, intent(in) :: nz Calls proc~~init_grid~~CallsGraph proc~init_grid init_grid write_dbg write_dbg proc~init_grid->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_grid.html"},{"title":"end_grid – QuickPIC wit Azimuzal Decomposition","text":"private subroutine end_grid(this) Arguments Type Intent Optional Attributes Name class( grid ), intent(inout) :: this Calls proc~~end_grid~~CallsGraph proc~end_grid end_grid write_dbg write_dbg proc~end_grid->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/end_grid.html"},{"title":"init_field_psi – QuickPIC wit Azimuzal Decomposition","text":"private subroutine init_field_psi(this, pp, gp, dr, dxi, num_modes, part_shape) Arguments Type Intent Optional Attributes Name class( field_psi ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape Calls proc~~init_field_psi~~CallsGraph proc~init_field_psi init_field_psi write_err write_err proc~init_field_psi->write_err write_dbg write_dbg proc~init_field_psi->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_field_psi.html"},{"title":"end_field_psi – QuickPIC wit Azimuzal Decomposition","text":"private subroutine end_field_psi(this) Arguments Type Intent Optional Attributes Name class( field_psi ), intent(inout) :: this Calls proc~~end_field_psi~~CallsGraph proc~end_field_psi end_field_psi write_dbg write_dbg proc~end_field_psi->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/end_field_psi.html"},{"title":"set_source – QuickPIC wit Azimuzal Decomposition","text":"private subroutine set_source(this, mode, q_re, q_im) Arguments Type Intent Optional Attributes Name class( field_psi ), intent(inout) :: this integer, intent(in) :: mode class( ufield ), intent(in) :: q_re class( ufield ), intent(in), optional :: q_im Calls proc~~set_source~~CallsGraph proc~set_source set_source write_err write_err proc~set_source->write_err write_dbg write_dbg proc~set_source->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_source.html"},{"title":"get_solution – QuickPIC wit Azimuzal Decomposition","text":"private subroutine get_solution(this, mode) Arguments Type Intent Optional Attributes Name class( field_psi ), intent(inout) :: this integer, intent(in) :: mode Calls proc~~get_solution~~CallsGraph proc~get_solution get_solution write_dbg write_dbg proc~get_solution->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_solution.html"},{"title":"solve_field_psi – QuickPIC wit Azimuzal Decomposition","text":"private subroutine solve_field_psi(this, q) Arguments Type Intent Optional Attributes Name class( field_psi ), intent(inout) :: this class( field_rho ), intent(in) :: q Calls proc~~solve_field_psi~~CallsGraph proc~solve_field_psi solve_field_psi write_dbg write_dbg proc~solve_field_psi->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/solve_field_psi.html"},{"title":"init_sim_fields – QuickPIC wit Azimuzal Decomposition","text":"private subroutine init_sim_fields(this, input, dr, dxi, num_modes, part_shape) Arguments Type Intent Optional Attributes Name class( sim_fields ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape Calls proc~~init_sim_fields~~CallsGraph proc~init_sim_fields init_sim_fields write_dbg write_dbg proc~init_sim_fields->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_sim_fields.html"},{"title":"end_sim_fields – QuickPIC wit Azimuzal Decomposition","text":"private subroutine end_sim_fields(this) Arguments Type Intent Optional Attributes Name class( sim_fields ), intent(inout) :: this Calls proc~~end_sim_fields~~CallsGraph proc~end_sim_fields end_sim_fields write_dbg write_dbg proc~end_sim_fields->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/end_sim_fields.html"},{"title":"init_simulation – QuickPIC wit Azimuzal Decomposition","text":"private subroutine init_simulation(this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout) :: this Calls proc~~init_simulation~~CallsGraph proc~init_simulation init_simulation write_err write_err proc~init_simulation->write_err write_dbg write_dbg proc~init_simulation->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_simulation.html"},{"title":"end_simulation – QuickPIC wit Azimuzal Decomposition","text":"private subroutine end_simulation(this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout) :: this Calls proc~~end_simulation~~CallsGraph proc~end_simulation end_simulation write_dbg write_dbg proc~end_simulation->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/end_simulation.html"},{"title":"init_field_b – QuickPIC wit Azimuzal Decomposition","text":"private subroutine init_field_b(this, pp, gp, dr, dxi, num_modes, part_shape, entity) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape integer, intent(in) :: entity Calls proc~~init_field_b~~CallsGraph proc~init_field_b init_field_b write_err write_err proc~init_field_b->write_err write_dbg write_dbg proc~init_field_b->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_field_b.html"},{"title":"end_field_b – QuickPIC wit Azimuzal Decomposition","text":"private subroutine end_field_b(this) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this Calls proc~~end_field_b~~CallsGraph proc~end_field_b end_field_b write_dbg write_dbg proc~end_field_b->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/end_field_b.html"},{"title":"set_source_bz – QuickPIC wit Azimuzal Decomposition","text":"private subroutine set_source_bz(this, mode, jay_re, jay_im) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this integer, intent(in) :: mode class( ufield ), intent(in) :: jay_re class( ufield ), intent(in), optional :: jay_im Calls proc~~set_source_bz~~CallsGraph proc~set_source_bz set_source_bz write_err write_err proc~set_source_bz->write_err write_dbg write_dbg proc~set_source_bz->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_source_bz.html"},{"title":"set_source_bperp – QuickPIC wit Azimuzal Decomposition","text":"private subroutine set_source_bperp(this, mode, q_re, q_im) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this integer, intent(in) :: mode class( ufield ), intent(in) :: q_re class( ufield ), intent(in), optional :: q_im Calls proc~~set_source_bperp~~CallsGraph proc~set_source_bperp set_source_bperp write_err write_err proc~set_source_bperp->write_err write_dbg write_dbg proc~set_source_bperp->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_source_bperp.html"},{"title":"set_source_bperp_iter – QuickPIC wit Azimuzal Decomposition","text":"private subroutine set_source_bperp_iter(this, mode, djdxi_re, jay_re, djdxi_im, jay_im) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this integer, intent(in) :: mode class( ufield ), intent(in) :: djdxi_re class( ufield ), intent(in) :: jay_re class( ufield ), intent(in), optional :: djdxi_im class( ufield ), intent(in), optional :: jay_im Calls proc~~set_source_bperp_iter~~CallsGraph proc~set_source_bperp_iter set_source_bperp_iter write_err write_err proc~set_source_bperp_iter->write_err write_dbg write_dbg proc~set_source_bperp_iter->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_source_bperp_iter.html"},{"title":"get_solution_bz – QuickPIC wit Azimuzal Decomposition","text":"private subroutine get_solution_bz(this, mode) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this integer, intent(in) :: mode Calls proc~~get_solution_bz~~CallsGraph proc~get_solution_bz get_solution_bz write_dbg write_dbg proc~get_solution_bz->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_solution_bz.html"},{"title":"get_solution_bperp – QuickPIC wit Azimuzal Decomposition","text":"private subroutine get_solution_bperp(this, mode) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this integer, intent(in) :: mode Calls proc~~get_solution_bperp~~CallsGraph proc~get_solution_bperp get_solution_bperp write_dbg write_dbg proc~get_solution_bperp->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_solution_bperp.html"},{"title":"get_solution_bperp_iter – QuickPIC wit Azimuzal Decomposition","text":"private subroutine get_solution_bperp_iter(this, mode) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this integer, intent(in) :: mode Calls proc~~get_solution_bperp_iter~~CallsGraph proc~get_solution_bperp_iter get_solution_bperp_iter write_dbg write_dbg proc~get_solution_bperp_iter->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_solution_bperp_iter.html"},{"title":"solve_field_bz – QuickPIC wit Azimuzal Decomposition","text":"private subroutine solve_field_bz(this, jay) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this class( field_jay ), intent(in) :: jay Calls proc~~solve_field_bz~~CallsGraph proc~solve_field_bz solve_field_bz write_dbg write_dbg proc~solve_field_bz->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/solve_field_bz.html"},{"title":"solve_field_bperp – QuickPIC wit Azimuzal Decomposition","text":"private subroutine solve_field_bperp(this, rho) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this class( field_rho ), intent(in) :: rho Calls proc~~solve_field_bperp~~CallsGraph proc~solve_field_bperp solve_field_bperp write_dbg write_dbg proc~solve_field_bperp->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/solve_field_bperp.html"},{"title":"solve_field_bperp_iter – QuickPIC wit Azimuzal Decomposition","text":"private subroutine solve_field_bperp_iter(this, djdxi, jay) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this class( field_djdxi ), intent(in) :: djdxi class( field_jay ), intent(in) :: jay Calls proc~~solve_field_bperp_iter~~CallsGraph proc~solve_field_bperp_iter solve_field_bperp_iter write_dbg write_dbg proc~solve_field_bperp_iter->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/solve_field_bperp_iter.html"},{"title":"init_field_e – QuickPIC wit Azimuzal Decomposition","text":"private subroutine init_field_e(this, pp, gp, dr, dxi, num_modes, part_shape, entity) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape integer, intent(in) :: entity Calls proc~~init_field_e~~CallsGraph proc~init_field_e init_field_e write_err write_err proc~init_field_e->write_err write_dbg write_dbg proc~init_field_e->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_field_e.html"},{"title":"end_field_e – QuickPIC wit Azimuzal Decomposition","text":"private subroutine end_field_e(this) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this Calls proc~~end_field_e~~CallsGraph proc~end_field_e end_field_e write_dbg write_dbg proc~end_field_e->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/end_field_e.html"},{"title":"set_source_ez – QuickPIC wit Azimuzal Decomposition","text":"private subroutine set_source_ez(this, mode, jay_re, jay_im) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this integer, intent(in) :: mode class( ufield ), intent(in) :: jay_re class( ufield ), intent(in), optional :: jay_im Calls proc~~set_source_ez~~CallsGraph proc~set_source_ez set_source_ez write_err write_err proc~set_source_ez->write_err write_dbg write_dbg proc~set_source_ez->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_source_ez.html"},{"title":"get_solution_ez – QuickPIC wit Azimuzal Decomposition","text":"private subroutine get_solution_ez(this, mode) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this integer, intent(in) :: mode Calls proc~~get_solution_ez~~CallsGraph proc~get_solution_ez get_solution_ez write_dbg write_dbg proc~get_solution_ez->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_solution_ez.html"},{"title":"solve_field_ez – QuickPIC wit Azimuzal Decomposition","text":"private subroutine solve_field_ez(this, jay) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this class( field_jay ), intent(in) :: jay Calls proc~~solve_field_ez~~CallsGraph proc~solve_field_ez solve_field_ez write_dbg write_dbg proc~solve_field_ez->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/solve_field_ez.html"},{"title":"solve_field_eperp – QuickPIC wit Azimuzal Decomposition","text":"private subroutine solve_field_eperp(this, b, psi) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this class( field_b ), intent(in) :: b class( field_psi ), intent(in) :: psi Calls proc~~solve_field_eperp~~CallsGraph proc~solve_field_eperp solve_field_eperp write_dbg write_dbg proc~solve_field_eperp->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/solve_field_eperp.html"},{"title":"solve_field_eperp_beam – QuickPIC wit Azimuzal Decomposition","text":"private subroutine solve_field_eperp_beam(this, b) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this class( field_b ), intent(in) :: b Calls proc~~solve_field_eperp_beam~~CallsGraph proc~solve_field_eperp_beam solve_field_eperp_beam write_dbg write_dbg proc~solve_field_eperp_beam->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/solve_field_eperp_beam.html"},{"title":"get_dr – QuickPIC wit Azimuzal Decomposition","text":"private function get_dr(this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value real Contents None","tags":"","loc":"proc/get_dr.html"},{"title":"get_dxi – QuickPIC wit Azimuzal Decomposition","text":"private function get_dxi(this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value real Contents None","tags":"","loc":"proc/get_dxi.html"},{"title":"get_num_modes – QuickPIC wit Azimuzal Decomposition","text":"private function get_num_modes(this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/get_num_modes.html"},{"title":"get_rf_re_all – QuickPIC wit Azimuzal Decomposition","text":"private function get_rf_re_all(this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value type( ufield ),\n  dimension(:),pointer Contents None","tags":"","loc":"proc/get_rf_re_all.html"},{"title":"get_rf_re_mode – QuickPIC wit Azimuzal Decomposition","text":"private function get_rf_re_mode(this, mode) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this integer, intent(in) :: mode Return Value type( ufield ),\n  pointer Contents None","tags":"","loc":"proc/get_rf_re_mode.html"},{"title":"get_rf_im_all – QuickPIC wit Azimuzal Decomposition","text":"private function get_rf_im_all(this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value type( ufield ),\n  dimension(:),pointer Contents None","tags":"","loc":"proc/get_rf_im_all.html"},{"title":"get_rf_im_mode – QuickPIC wit Azimuzal Decomposition","text":"private function get_rf_im_mode(this, mode) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this integer, intent(in) :: mode Return Value type( ufield ),\n  pointer Contents None","tags":"","loc":"proc/get_rf_im_mode.html"},{"title":"init_field – QuickPIC wit Azimuzal Decomposition","text":"private subroutine init_field(this, pp, gp, dim, dr, dxi, num_modes, gc_num, entity) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp integer, intent(in) :: dim real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in), dimension(2,2) :: gc_num integer, intent(in), optional :: entity Calls proc~~init_field~~CallsGraph proc~init_field init_field write_dbg write_dbg proc~init_field->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_field.html"},{"title":"end_field – QuickPIC wit Azimuzal Decomposition","text":"private subroutine end_field(this) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this Calls proc~~end_field~~CallsGraph proc~end_field end_field write_dbg write_dbg proc~end_field->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/end_field.html"},{"title":"init_errors – QuickPIC wit Azimuzal Decomposition","text":"public subroutine init_errors(eunit, monitor) Arguments Type Intent Optional Attributes Name integer, intent(in) :: eunit integer, intent(in) :: monitor Calls proc~~init_errors~~CallsGraph proc~init_errors init_errors dtimer dtimer proc~init_errors->dtimer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_errors.html"},{"title":"end_errors – QuickPIC wit Azimuzal Decomposition","text":"public subroutine end_errors() Arguments None Contents None","tags":"","loc":"proc/end_errors.html"},{"title":"write_err – QuickPIC wit Azimuzal Decomposition","text":"public subroutine write_err(estr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: estr Calls proc~~write_err~~CallsGraph proc~write_err write_err dtimer dtimer proc~write_err->dtimer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_err.html"},{"title":"write_wrn – QuickPIC wit Azimuzal Decomposition","text":"public subroutine write_wrn(wstr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: wstr Calls proc~~write_wrn~~CallsGraph proc~write_wrn write_wrn dtimer dtimer proc~write_wrn->dtimer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_wrn.html"},{"title":"write_dbg – QuickPIC wit Azimuzal Decomposition","text":"public subroutine write_dbg(clsname, sname, level, msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: clsname character(len=*), intent(in) :: sname integer, intent(in) :: level character(len=*), intent(in), optional :: msg Calls proc~~write_dbg~~CallsGraph proc~write_dbg write_dbg dtimer dtimer proc~write_dbg->dtimer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_dbg.html"},{"title":"init_errors – QuickPIC wit Azimuzal Decomposition","text":"private interface init_errors Contents Module Procedures init_errors Module Procedures private interface init_errors () Arguments None","tags":"","loc":"interface/init_errors.html"},{"title":"end_errors – QuickPIC wit Azimuzal Decomposition","text":"private interface end_errors Contents Module Procedures end_errors Module Procedures private interface end_errors () Arguments None","tags":"","loc":"interface/end_errors.html"},{"title":"write_err – QuickPIC wit Azimuzal Decomposition","text":"private interface write_err Contents Module Procedures write_err Module Procedures private interface write_err () Arguments None","tags":"","loc":"interface/write_err.html"},{"title":"write_wrn – QuickPIC wit Azimuzal Decomposition","text":"private interface write_wrn Contents Module Procedures write_wrn Module Procedures private interface write_wrn () Arguments None","tags":"","loc":"interface/write_wrn.html"},{"title":"write_dbg – QuickPIC wit Azimuzal Decomposition","text":"private interface write_dbg Contents Module Procedures write_dbg Module Procedures private interface write_dbg () Arguments None","tags":"","loc":"interface/write_dbg.html"},{"title":"write_array – QuickPIC wit Azimuzal Decomposition","text":"public subroutine write_array(f, fname) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:), pointer :: f character(len=*), intent(in) :: fname Called by proc~~write_array~~CalledByGraph proc~write_array write_array interface~write_data write_data interface~write_data->proc~write_array program~test_field_eperp test_field_eperp program~test_field_eperp->interface~write_data program~test_field_bz test_field_bz program~test_field_bz->interface~write_data program~test_field_psi test_field_psi program~test_field_psi->interface~write_data program~test_field_bperp test_field_bperp program~test_field_bperp->interface~write_data program~test_field_ez test_field_ez program~test_field_ez->interface~write_data program~test_field_eperp~2 test_field_eperp program~test_field_eperp~2->interface~write_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_array.html"},{"title":"write_data1d – QuickPIC wit Azimuzal Decomposition","text":"public subroutine write_data1d(f, fname, dim) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:), pointer :: f character(len=*), intent(in) :: fname integer, intent(in) :: dim Called by proc~~write_data1d~~CalledByGraph proc~write_data1d write_data1d interface~write_data write_data interface~write_data->proc~write_data1d program~test_field_eperp test_field_eperp program~test_field_eperp->interface~write_data program~test_field_bz test_field_bz program~test_field_bz->interface~write_data program~test_field_psi test_field_psi program~test_field_psi->interface~write_data program~test_field_bperp test_field_bperp program~test_field_bperp->interface~write_data program~test_field_ez test_field_ez program~test_field_ez->interface~write_data program~test_field_eperp~2 test_field_eperp program~test_field_eperp~2->interface~write_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_data1d.html"},{"title":"write_data2d – QuickPIC wit Azimuzal Decomposition","text":"public subroutine write_data2d(f, fname, dim) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:,:), pointer :: f character(len=*), intent(in) :: fname integer, intent(in) :: dim Called by proc~~write_data2d~~CalledByGraph proc~write_data2d write_data2d interface~write_data write_data interface~write_data->proc~write_data2d program~test_field_eperp test_field_eperp program~test_field_eperp->interface~write_data program~test_field_bz test_field_bz program~test_field_bz->interface~write_data program~test_field_psi test_field_psi program~test_field_psi->interface~write_data program~test_field_bperp test_field_bperp program~test_field_bperp->interface~write_data program~test_field_ez test_field_ez program~test_field_ez->interface~write_data program~test_field_eperp~2 test_field_eperp program~test_field_eperp~2->interface~write_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_data2d.html"},{"title":"write_data – QuickPIC wit Azimuzal Decomposition","text":"public interface write_data Calls interface~~write_data~~CallsGraph interface~write_data write_data proc~write_data1d write_data1d interface~write_data->proc~write_data1d proc~write_data2d write_data2d interface~write_data->proc~write_data2d proc~write_array write_array interface~write_data->proc~write_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~write_data~~CalledByGraph interface~write_data write_data program~test_field_eperp test_field_eperp program~test_field_eperp->interface~write_data program~test_field_bz test_field_bz program~test_field_bz->interface~write_data program~test_field_psi test_field_psi program~test_field_psi->interface~write_data program~test_field_bperp test_field_bperp program~test_field_bperp->interface~write_data program~test_field_ez test_field_ez program~test_field_ez->interface~write_data program~test_field_eperp~2 test_field_eperp program~test_field_eperp~2->interface~write_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures write_data1d write_data2d write_array Module Procedures public subroutine write_data1d (f, fname, dim) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:), pointer :: f character(len=*), intent(in) :: fname integer, intent(in) :: dim public subroutine write_data2d (f, fname, dim) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:,:), pointer :: f character(len=*), intent(in) :: fname integer, intent(in) :: dim public subroutine write_array (f, fname) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:), pointer :: f character(len=*), intent(in) :: fname","tags":"","loc":"interface/write_data.html"},{"title":"getnvp – QuickPIC wit Azimuzal Decomposition","text":"private function getnvp(this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getnvp.html"},{"title":"getidproc – QuickPIC wit Azimuzal Decomposition","text":"private function getidproc(this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getidproc.html"},{"title":"getkstrt – QuickPIC wit Azimuzal Decomposition","text":"private function getkstrt(this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getkstrt.html"},{"title":"getlworld – QuickPIC wit Azimuzal Decomposition","text":"private function getlworld(this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getlworld.html"},{"title":"getmint – QuickPIC wit Azimuzal Decomposition","text":"private function getmint(this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getmint.html"},{"title":"getmreal – QuickPIC wit Azimuzal Decomposition","text":"private function getmreal(this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getmreal.html"},{"title":"getmdouble – QuickPIC wit Azimuzal Decomposition","text":"private function getmdouble(this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getmdouble.html"},{"title":"getmcplx – QuickPIC wit Azimuzal Decomposition","text":"private function getmcplx(this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getmcplx.html"},{"title":"getmchar – QuickPIC wit Azimuzal Decomposition","text":"private function getmchar(this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getmchar.html"},{"title":"init_parallel – QuickPIC wit Azimuzal Decomposition","text":"private subroutine init_parallel(this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(inout) :: this Calls proc~~init_parallel~~CallsGraph proc~init_parallel init_parallel proc~ppinit2 ppinit2 proc~init_parallel->proc~ppinit2 proc~init_omp init_omp proc~init_parallel->proc~init_omp mpi_comm_size mpi_comm_size proc~ppinit2->mpi_comm_size mpi_init mpi_init proc~ppinit2->mpi_init mpi_comm_rank mpi_comm_rank proc~ppinit2->mpi_comm_rank mpi_initialized mpi_initialized proc~ppinit2->mpi_initialized omp_get_max_threads omp_get_max_threads proc~init_omp->omp_get_max_threads omp_get_thread_num omp_get_thread_num proc~init_omp->omp_get_thread_num omp_get_num_procs omp_get_num_procs proc~init_omp->omp_get_num_procs omp_set_num_threads omp_set_num_threads proc~init_omp->omp_set_num_threads Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_parallel.html"},{"title":"ppinit2 – QuickPIC wit Azimuzal Decomposition","text":"private subroutine ppinit2(idproc, nvp, lworld, mint, mreal, mdouble, mcplx, mchar) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: idproc integer, intent(inout) :: nvp integer, intent(inout) :: lworld integer, intent(inout) :: mint integer, intent(inout) :: mreal integer, intent(inout) :: mdouble integer, intent(inout) :: mcplx integer, intent(inout) :: mchar Calls proc~~ppinit2~~CallsGraph proc~ppinit2 ppinit2 mpi_init mpi_init proc~ppinit2->mpi_init mpi_comm_size mpi_comm_size proc~ppinit2->mpi_comm_size mpi_initialized mpi_initialized proc~ppinit2->mpi_initialized mpi_comm_rank mpi_comm_rank proc~ppinit2->mpi_comm_rank Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~ppinit2~~CalledByGraph proc~ppinit2 ppinit2 proc~init_parallel init_parallel proc~init_parallel->proc~ppinit2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppinit2.html"},{"title":"init_omp – QuickPIC wit Azimuzal Decomposition","text":"private subroutine init_omp(nth) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nth Calls proc~~init_omp~~CallsGraph proc~init_omp init_omp omp_set_num_threads omp_set_num_threads proc~init_omp->omp_set_num_threads omp_get_thread_num omp_get_thread_num proc~init_omp->omp_get_thread_num omp_get_num_procs omp_get_num_procs proc~init_omp->omp_get_num_procs omp_get_max_threads omp_get_max_threads proc~init_omp->omp_get_max_threads Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~init_omp~~CalledByGraph proc~init_omp init_omp proc~init_parallel init_parallel proc~init_parallel->proc~init_omp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_omp.html"},{"title":"end_parallel – QuickPIC wit Azimuzal Decomposition","text":"private subroutine end_parallel(this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(inout) :: this Calls proc~~end_parallel~~CallsGraph proc~end_parallel end_parallel mpi_barrier mpi_barrier proc~end_parallel->mpi_barrier mpi_finalize mpi_finalize proc~end_parallel->mpi_finalize mpi_initialized mpi_initialized proc~end_parallel->mpi_initialized Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/end_parallel.html"},{"title":"init_field_rho – QuickPIC wit Azimuzal Decomposition","text":"private subroutine init_field_rho(this, pp, gp, dr, dxi, num_modes, part_shape) Arguments Type Intent Optional Attributes Name class( field_rho ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape Calls proc~~init_field_rho~~CallsGraph proc~init_field_rho init_field_rho write_err write_err proc~init_field_rho->write_err write_dbg write_dbg proc~init_field_rho->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_field_rho.html"},{"title":"init_field_jay – QuickPIC wit Azimuzal Decomposition","text":"private subroutine init_field_jay(this, pp, gp, dr, dxi, num_modes, part_shape) Arguments Type Intent Optional Attributes Name class( field_jay ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape Calls proc~~init_field_jay~~CallsGraph proc~init_field_jay init_field_jay write_err write_err proc~init_field_jay->write_err write_dbg write_dbg proc~init_field_jay->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_field_jay.html"},{"title":"init_field_djdxi – QuickPIC wit Azimuzal Decomposition","text":"private subroutine init_field_djdxi(this, pp, gp, dr, dxi, num_modes, part_shape) Arguments Type Intent Optional Attributes Name class( field_djdxi ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape Calls proc~~init_field_djdxi~~CallsGraph proc~init_field_djdxi init_field_djdxi write_err write_err proc~init_field_djdxi->write_err write_dbg write_dbg proc~init_field_djdxi->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_field_djdxi.html"},{"title":"init_field_solver – QuickPIC wit Azimuzal Decomposition","text":"private subroutine init_field_solver(this, nd, ndp, noff, kind, mode, dr, solver_type, tol) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this integer, intent(in), dimension(2) :: nd integer, intent(in), dimension(2) :: ndp integer, intent(in), dimension(2) :: noff integer, intent(in) :: kind integer, intent(in) :: mode real, intent(in) :: dr integer, intent(in) :: solver_type real, intent(in) :: tol Calls proc~~init_field_solver~~CallsGraph proc~init_field_solver init_field_solver hypre_ijvectorsetobjecttype hypre_ijvectorsetobjecttype proc~init_field_solver->hypre_ijvectorsetobjecttype write_dbg write_dbg proc~init_field_solver->write_dbg hypre_structvectorcreate hypre_structvectorcreate proc~init_field_solver->hypre_structvectorcreate hypre_structvectorinitialize hypre_structvectorinitialize proc~init_field_solver->hypre_structvectorinitialize hypre_ijvectorcreate hypre_ijvectorcreate proc~init_field_solver->hypre_ijvectorcreate hypre_ijvectorinitialize hypre_ijvectorinitialize proc~init_field_solver->hypre_ijvectorinitialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_field_solver.html"},{"title":"end_field_solver – QuickPIC wit Azimuzal Decomposition","text":"private subroutine end_field_solver(this) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this Calls proc~~end_field_solver~~CallsGraph proc~end_field_solver end_field_solver hypre_structgmresdestroy hypre_structgmresdestroy proc~end_field_solver->hypre_structgmresdestroy hypre_structsmgdestroy hypre_structsmgdestroy proc~end_field_solver->hypre_structsmgdestroy hypre_structgriddestroy hypre_structgriddestroy proc~end_field_solver->hypre_structgriddestroy hypre_structvectordestroy hypre_structvectordestroy proc~end_field_solver->hypre_structvectordestroy hypre_ijmatrixdestroy hypre_ijmatrixdestroy proc~end_field_solver->hypre_ijmatrixdestroy hypre_structpcgdestroy hypre_structpcgdestroy proc~end_field_solver->hypre_structpcgdestroy hypre_structcycreddestroy hypre_structcycreddestroy proc~end_field_solver->hypre_structcycreddestroy hypre_structjacobidestroy hypre_structjacobidestroy proc~end_field_solver->hypre_structjacobidestroy write_dbg write_dbg proc~end_field_solver->write_dbg hypre_structstencildestroy hypre_structstencildestroy proc~end_field_solver->hypre_structstencildestroy hypre_structmatrixdestroy hypre_structmatrixdestroy proc~end_field_solver->hypre_structmatrixdestroy hypre_boomeramgdestroy hypre_boomeramgdestroy proc~end_field_solver->hypre_boomeramgdestroy hypre_ijvectordestroy hypre_ijvectordestroy proc~end_field_solver->hypre_ijvectordestroy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/end_field_solver.html"},{"title":"set_struct_solver – QuickPIC wit Azimuzal Decomposition","text":"private subroutine set_struct_solver(this, comm) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this integer, intent(in) :: comm Calls proc~~set_struct_solver~~CallsGraph proc~set_struct_solver set_struct_solver hypre_structsmgsetprintlevel hypre_structsmgsetprintlevel proc~set_struct_solver->hypre_structsmgsetprintlevel hypre_structgmressettol hypre_structgmressettol proc~set_struct_solver->hypre_structgmressettol hypre_structcycredsetup hypre_structcycredsetup proc~set_struct_solver->hypre_structcycredsetup write_dbg write_dbg proc~set_struct_solver->write_dbg hypre_structpcgsetrelchange hypre_structpcgsetrelchange proc~set_struct_solver->hypre_structpcgsetrelchange hypre_structgmressetprintlevel hypre_structgmressetprintlevel proc~set_struct_solver->hypre_structgmressetprintlevel hypre_structpcgcreate hypre_structpcgcreate proc~set_struct_solver->hypre_structpcgcreate hypre_structjacobisetzeroguess hypre_structjacobisetzeroguess proc~set_struct_solver->hypre_structjacobisetzeroguess hypre_structgmressetlogging hypre_structgmressetlogging proc~set_struct_solver->hypre_structgmressetlogging hypre_structjacobisetmaxiter hypre_structjacobisetmaxiter proc~set_struct_solver->hypre_structjacobisetmaxiter hypre_structsmgsetlogging hypre_structsmgsetlogging proc~set_struct_solver->hypre_structsmgsetlogging hypre_structgmressetup hypre_structgmressetup proc~set_struct_solver->hypre_structgmressetup hypre_structpcgsetprecond hypre_structpcgsetprecond proc~set_struct_solver->hypre_structpcgsetprecond hypre_structcycredcreate hypre_structcycredcreate proc~set_struct_solver->hypre_structcycredcreate hypre_structsmgsetnumprerelax hypre_structsmgsetnumprerelax proc~set_struct_solver->hypre_structsmgsetnumprerelax hypre_structpcgsetlogging hypre_structpcgsetlogging proc~set_struct_solver->hypre_structpcgsetlogging hypre_structjacobisettol hypre_structjacobisettol proc~set_struct_solver->hypre_structjacobisettol hypre_structpcgsetmaxiter hypre_structpcgsetmaxiter proc~set_struct_solver->hypre_structpcgsetmaxiter hypre_structsmgsettol hypre_structsmgsettol proc~set_struct_solver->hypre_structsmgsettol hypre_structpcgsetprintlevel hypre_structpcgsetprintlevel proc~set_struct_solver->hypre_structpcgsetprintlevel hypre_structpcgsettwonorm hypre_structpcgsettwonorm proc~set_struct_solver->hypre_structpcgsettwonorm hypre_structsmgsetnumpostrelax hypre_structsmgsetnumpostrelax proc~set_struct_solver->hypre_structsmgsetnumpostrelax hypre_structsmgcreate hypre_structsmgcreate proc~set_struct_solver->hypre_structsmgcreate hypre_structsmgsetrelchange hypre_structsmgsetrelchange proc~set_struct_solver->hypre_structsmgsetrelchange hypre_structgmressetmaxiter hypre_structgmressetmaxiter proc~set_struct_solver->hypre_structgmressetmaxiter hypre_structpcgsetup hypre_structpcgsetup proc~set_struct_solver->hypre_structpcgsetup hypre_structgmressetprecond hypre_structgmressetprecond proc~set_struct_solver->hypre_structgmressetprecond hypre_structpcgsettol hypre_structpcgsettol proc~set_struct_solver->hypre_structpcgsettol hypre_structjacobicreate hypre_structjacobicreate proc~set_struct_solver->hypre_structjacobicreate hypre_structsmgsetmemoryuse hypre_structsmgsetmemoryuse proc~set_struct_solver->hypre_structsmgsetmemoryuse hypre_structsmgsetup hypre_structsmgsetup proc~set_struct_solver->hypre_structsmgsetup hypre_structsmgsetmaxiter hypre_structsmgsetmaxiter proc~set_struct_solver->hypre_structsmgsetmaxiter hypre_structgmrescreate hypre_structgmrescreate proc~set_struct_solver->hypre_structgmrescreate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_struct_solver.html"},{"title":"solve_equation – QuickPIC wit Azimuzal Decomposition","text":"private subroutine solve_equation(this, src_sol) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this real, intent(inout), dimension(:), pointer :: src_sol Calls proc~~solve_equation~~CallsGraph proc~solve_equation solve_equation hypre_structvectorassemble hypre_structvectorassemble proc~solve_equation->hypre_structvectorassemble hypre_structsmgsolve hypre_structsmgsolve proc~solve_equation->hypre_structsmgsolve hypre_boomeramgsolve hypre_boomeramgsolve proc~solve_equation->hypre_boomeramgsolve hypre_structpcgsolve hypre_structpcgsolve proc~solve_equation->hypre_structpcgsolve write_dbg write_dbg proc~solve_equation->write_dbg hypre_ijvectorgetobject hypre_ijvectorgetobject proc~solve_equation->hypre_ijvectorgetobject hypre_structvectorgetboxvalues hypre_structvectorgetboxvalues proc~solve_equation->hypre_structvectorgetboxvalues hypre_ijvectorassemble hypre_ijvectorassemble proc~solve_equation->hypre_ijvectorassemble hypre_ijvectorgetvalues hypre_ijvectorgetvalues proc~solve_equation->hypre_ijvectorgetvalues hypre_structcycredsolve hypre_structcycredsolve proc~solve_equation->hypre_structcycredsolve hypre_structvectorsetboxvalues hypre_structvectorsetboxvalues proc~solve_equation->hypre_structvectorsetboxvalues hypre_ijvectorsetvalues hypre_ijvectorsetvalues proc~solve_equation->hypre_ijvectorsetvalues hypre_structgmressolve hypre_structgmressolve proc~solve_equation->hypre_structgmressolve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/solve_equation.html"},{"title":"set_struct_grid – QuickPIC wit Azimuzal Decomposition","text":"private subroutine set_struct_grid(this, comm, ndp, noff) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this integer, intent(in) :: comm integer, intent(in), dimension(2) :: ndp integer, intent(in), dimension(2) :: noff Calls proc~~set_struct_grid~~CallsGraph proc~set_struct_grid set_struct_grid hypre_structgridsetextents hypre_structgridsetextents proc~set_struct_grid->hypre_structgridsetextents hypre_structgridcreate hypre_structgridcreate proc~set_struct_grid->hypre_structgridcreate hypre_structgridassemble hypre_structgridassemble proc~set_struct_grid->hypre_structgridassemble write_dbg write_dbg proc~set_struct_grid->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_struct_grid.html"},{"title":"set_struct_stencil – QuickPIC wit Azimuzal Decomposition","text":"private subroutine set_struct_stencil(this) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this Calls proc~~set_struct_stencil~~CallsGraph proc~set_struct_stencil set_struct_stencil write_dbg write_dbg proc~set_struct_stencil->write_dbg hypre_structstencilcreate hypre_structstencilcreate proc~set_struct_stencil->hypre_structstencilcreate hypre_structstencilsetelement hypre_structstencilsetelement proc~set_struct_stencil->hypre_structstencilsetelement Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_struct_stencil.html"},{"title":"set_struct_matrix – QuickPIC wit Azimuzal Decomposition","text":"private subroutine set_struct_matrix(this, comm, nd, dr) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this integer, intent(in) :: comm integer, intent(in), dimension(:) :: nd real, intent(in) :: dr Calls proc~~set_struct_matrix~~CallsGraph proc~set_struct_matrix set_struct_matrix hypre_structmatrixassemble hypre_structmatrixassemble proc~set_struct_matrix->hypre_structmatrixassemble hypre_structmatrixcreate hypre_structmatrixcreate proc~set_struct_matrix->hypre_structmatrixcreate write_dbg write_dbg proc~set_struct_matrix->write_dbg hypre_structmatrixsetboxvalues hypre_structmatrixsetboxvalues proc~set_struct_matrix->hypre_structmatrixsetboxvalues hypre_structmatrixinitialize hypre_structmatrixinitialize proc~set_struct_matrix->hypre_structmatrixinitialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_struct_matrix.html"},{"title":"set_ij_solver – QuickPIC wit Azimuzal Decomposition","text":"private subroutine set_ij_solver(this, comm) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this integer, intent(in) :: comm Calls proc~~set_ij_solver~~CallsGraph proc~set_ij_solver set_ij_solver hypre_structsmgsetprintlevel hypre_structsmgsetprintlevel proc~set_ij_solver->hypre_structsmgsetprintlevel hypre_parcsrpcgcreate hypre_parcsrpcgcreate proc~set_ij_solver->hypre_parcsrpcgcreate hypre_parcsrpcgsettol hypre_parcsrpcgsettol proc~set_ij_solver->hypre_parcsrpcgsettol hypre_boomeramgsetcoarsentype hypre_boomeramgsetcoarsentype proc~set_ij_solver->hypre_boomeramgsetcoarsentype write_dbg write_dbg proc~set_ij_solver->write_dbg hypre_boomeramgsetmaxlevels hypre_boomeramgsetmaxlevels proc~set_ij_solver->hypre_boomeramgsetmaxlevels hypre_parcsrpcgsettwonorm hypre_parcsrpcgsettwonorm proc~set_ij_solver->hypre_parcsrpcgsettwonorm hypre_structsmgsetlogging hypre_structsmgsetlogging proc~set_ij_solver->hypre_structsmgsetlogging hypre_boomeramgsettol hypre_boomeramgsettol proc~set_ij_solver->hypre_boomeramgsettol hypre_boomeramgsetmaxiter hypre_boomeramgsetmaxiter proc~set_ij_solver->hypre_boomeramgsetmaxiter hypre_structsmgsetnumprerelax hypre_structsmgsetnumprerelax proc~set_ij_solver->hypre_structsmgsetnumprerelax hypre_boomeramgcreate hypre_boomeramgcreate proc~set_ij_solver->hypre_boomeramgcreate hypre_structsmgsettol hypre_structsmgsettol proc~set_ij_solver->hypre_structsmgsettol hypre_structsmgcreate hypre_structsmgcreate proc~set_ij_solver->hypre_structsmgcreate hypre_structsmgsetnumpostrelax hypre_structsmgsetnumpostrelax proc~set_ij_solver->hypre_structsmgsetnumpostrelax hypre_structsmgsetrelchange hypre_structsmgsetrelchange proc~set_ij_solver->hypre_structsmgsetrelchange hypre_boomeramgsetrelaxtype hypre_boomeramgsetrelaxtype proc~set_ij_solver->hypre_boomeramgsetrelaxtype hypre_boomeramgsetnumsweeps hypre_boomeramgsetnumsweeps proc~set_ij_solver->hypre_boomeramgsetnumsweeps hypre_parcsrpcgsetprecond hypre_parcsrpcgsetprecond proc~set_ij_solver->hypre_parcsrpcgsetprecond hypre_parcsrpcgsetup hypre_parcsrpcgsetup proc~set_ij_solver->hypre_parcsrpcgsetup hypre_structsmgsetmemoryuse hypre_structsmgsetmemoryuse proc~set_ij_solver->hypre_structsmgsetmemoryuse hypre_boomeramgsetup hypre_boomeramgsetup proc~set_ij_solver->hypre_boomeramgsetup hypre_boomeramgsetrelaxorder hypre_boomeramgsetrelaxorder proc~set_ij_solver->hypre_boomeramgsetrelaxorder hypre_structsmgsetup hypre_structsmgsetup proc~set_ij_solver->hypre_structsmgsetup hypre_parcsrpcgsetmaxiter hypre_parcsrpcgsetmaxiter proc~set_ij_solver->hypre_parcsrpcgsetmaxiter hypre_structsmgsetmaxiter hypre_structsmgsetmaxiter proc~set_ij_solver->hypre_structsmgsetmaxiter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_ij_solver.html"},{"title":"set_ij_matrix – QuickPIC wit Azimuzal Decomposition","text":"private subroutine set_ij_matrix(this, comm, nd, ndp, noff, dr) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this integer, intent(in) :: comm integer, intent(in), dimension(:) :: nd integer, intent(in), dimension(:) :: ndp integer, intent(in), dimension(:) :: noff real, intent(in) :: dr Calls proc~~set_ij_matrix~~CallsGraph proc~set_ij_matrix set_ij_matrix hypre_ijmatrixsetobjecttype hypre_ijmatrixsetobjecttype proc~set_ij_matrix->hypre_ijmatrixsetobjecttype hypre_ijmatrixgetobject hypre_ijmatrixgetobject proc~set_ij_matrix->hypre_ijmatrixgetobject hypre_ijmatrixcreate hypre_ijmatrixcreate proc~set_ij_matrix->hypre_ijmatrixcreate hypre_ijmatrixinitialize hypre_ijmatrixinitialize proc~set_ij_matrix->hypre_ijmatrixinitialize write_dbg write_dbg proc~set_ij_matrix->write_dbg hypre_ijmatrixassemble hypre_ijmatrixassemble proc~set_ij_matrix->hypre_ijmatrixassemble hypre_ijmatrixsetvalues hypre_ijmatrixsetvalues proc~set_ij_matrix->hypre_ijmatrixsetvalues Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_ij_matrix.html"},{"title":"getlidproc – QuickPIC wit Azimuzal Decomposition","text":"private function getlidproc(this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getlidproc.html"},{"title":"getlkstrt – QuickPIC wit Azimuzal Decomposition","text":"private function getlkstrt(this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getlkstrt.html"},{"title":"getlgrp – QuickPIC wit Azimuzal Decomposition","text":"private function getlgrp(this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getlgrp.html"},{"title":"getlnvp – QuickPIC wit Azimuzal Decomposition","text":"private function getlnvp(this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getlnvp.html"},{"title":"getnstage – QuickPIC wit Azimuzal Decomposition","text":"private function getnstage(this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getnstage.html"},{"title":"getstageid – QuickPIC wit Azimuzal Decomposition","text":"private function getstageid(this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getstageid.html"},{"title":"init_parallel_pipe – QuickPIC wit Azimuzal Decomposition","text":"private subroutine init_parallel_pipe(this, nst) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(inout) :: this integer, intent(in) :: nst Calls proc~~init_parallel_pipe~~CallsGraph proc~init_parallel_pipe init_parallel_pipe mpi_comm_size mpi_comm_size proc~init_parallel_pipe->mpi_comm_size mpi_comm_split mpi_comm_split proc~init_parallel_pipe->mpi_comm_split mpi_comm_rank mpi_comm_rank proc~init_parallel_pipe->mpi_comm_rank Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_parallel_pipe.html"},{"title":"add_array – QuickPIC wit Azimuzal Decomposition","text":"private function add_array(a1, a2) result(a3) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: a1 class( ufield ), intent(in) :: a2 Return Value class( ufield ),\n  allocatable Contents None","tags":"","loc":"proc/add_array.html"},{"title":"add_scalar1 – QuickPIC wit Azimuzal Decomposition","text":"private function add_scalar1(a1, a2) result(a3) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: a1 real, intent(in) :: a2 Return Value class( ufield ),\n  allocatable Contents None","tags":"","loc":"proc/add_scalar1.html"},{"title":"add_scalar2 – QuickPIC wit Azimuzal Decomposition","text":"private function add_scalar2(a2, a1) result(a3) Arguments Type Intent Optional Attributes Name real, intent(in) :: a2 class( ufield ), intent(in) :: a1 Return Value class( ufield ),\n  allocatable Contents None","tags":"","loc":"proc/add_scalar2.html"},{"title":"sub_array – QuickPIC wit Azimuzal Decomposition","text":"private function sub_array(a1, a2) result(a3) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: a1 class( ufield ), intent(in) :: a2 Return Value class( ufield ),\n  allocatable Contents None","tags":"","loc":"proc/sub_array.html"},{"title":"sub_scalar1 – QuickPIC wit Azimuzal Decomposition","text":"private function sub_scalar1(a1, a2) result(a3) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: a1 real, intent(in) :: a2 Return Value class( ufield ),\n  allocatable Contents None","tags":"","loc":"proc/sub_scalar1.html"},{"title":"sub_scalar2 – QuickPIC wit Azimuzal Decomposition","text":"private function sub_scalar2(a2, a1) result(a3) Arguments Type Intent Optional Attributes Name real, intent(in) :: a2 class( ufield ), intent(in) :: a1 Return Value class( ufield ),\n  allocatable Contents None","tags":"","loc":"proc/sub_scalar2.html"},{"title":"dot_array – QuickPIC wit Azimuzal Decomposition","text":"private function dot_array(a1, a2) result(a3) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: a1 class( ufield ), intent(in) :: a2 Return Value class( ufield ),\n  allocatable Contents None","tags":"","loc":"proc/dot_array.html"},{"title":"dot_scalar1 – QuickPIC wit Azimuzal Decomposition","text":"private function dot_scalar1(a1, a2) result(a3) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: a1 real, intent(in) :: a2 Return Value class( ufield ),\n  allocatable Contents None","tags":"","loc":"proc/dot_scalar1.html"},{"title":"dot_scalar2 – QuickPIC wit Azimuzal Decomposition","text":"private function dot_scalar2(a2, a1) result(a3) Arguments Type Intent Optional Attributes Name real, intent(in) :: a2 class( ufield ), intent(in) :: a1 Return Value class( ufield ),\n  allocatable Contents None","tags":"","loc":"proc/dot_scalar2.html"},{"title":"get_dim – QuickPIC wit Azimuzal Decomposition","text":"private function get_dim(this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/get_dim.html"},{"title":"get_nd_all – QuickPIC wit Azimuzal Decomposition","text":"private function get_nd_all(this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value integer,\n  dimension(2) Contents None","tags":"","loc":"proc/get_nd_all~2.html"},{"title":"get_nd_dim – QuickPIC wit Azimuzal Decomposition","text":"private function get_nd_dim(this, dim) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this integer, intent(in) :: dim Return Value integer Contents None","tags":"","loc":"proc/get_nd_dim~2.html"},{"title":"get_ndp_all – QuickPIC wit Azimuzal Decomposition","text":"private function get_ndp_all(this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value integer,\n  dimension(2) Contents None","tags":"","loc":"proc/get_ndp_all~2.html"},{"title":"get_ndp_dim – QuickPIC wit Azimuzal Decomposition","text":"private function get_ndp_dim(this, dim) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this integer, intent(in) :: dim Return Value integer Contents None","tags":"","loc":"proc/get_ndp_dim~2.html"},{"title":"get_gc_num_all – QuickPIC wit Azimuzal Decomposition","text":"private function get_gc_num_all(this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value integer,\n  dimension(2,2) Contents None","tags":"","loc":"proc/get_gc_num_all.html"},{"title":"get_gc_num_dim – QuickPIC wit Azimuzal Decomposition","text":"private function get_gc_num_dim(this, dim) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this integer, intent(in) :: dim Return Value integer,\n  dimension(2) Contents None","tags":"","loc":"proc/get_gc_num_dim.html"},{"title":"get_nvp_all – QuickPIC wit Azimuzal Decomposition","text":"private function get_nvp_all(this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value integer,\n  dimension(2) Contents None","tags":"","loc":"proc/get_nvp_all~2.html"},{"title":"get_nvp_dim – QuickPIC wit Azimuzal Decomposition","text":"private function get_nvp_dim(this, dim) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this integer, intent(in) :: dim Return Value integer Contents None","tags":"","loc":"proc/get_nvp_dim~2.html"},{"title":"get_noff_all – QuickPIC wit Azimuzal Decomposition","text":"private function get_noff_all(this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value integer,\n  dimension(2) Contents None","tags":"","loc":"proc/get_noff_all~2.html"},{"title":"get_noff_dim – QuickPIC wit Azimuzal Decomposition","text":"private function get_noff_dim(this, dim) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this integer, intent(in) :: dim Return Value integer Contents None","tags":"","loc":"proc/get_noff_dim~2.html"},{"title":"get_f1 – QuickPIC wit Azimuzal Decomposition","text":"private function get_f1(this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value real,\n  dimension(:,:),pointer Contents None","tags":"","loc":"proc/get_f1.html"},{"title":"get_f2 – QuickPIC wit Azimuzal Decomposition","text":"private function get_f2(this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value real,\n  dimension(:,:,:),pointer Contents None","tags":"","loc":"proc/get_f2.html"},{"title":"init_ufield – QuickPIC wit Azimuzal Decomposition","text":"private subroutine init_ufield(this, pp, gp, dim, gc_num, has_2d) Arguments Type Intent Optional Attributes Name class( ufield ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp integer, intent(in) :: dim integer, intent(in), dimension(2,2) :: gc_num logical, intent(in), optional :: has_2d Calls proc~~init_ufield~~CallsGraph proc~init_ufield init_ufield write_dbg write_dbg proc~init_ufield->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_ufield.html"},{"title":"init_ufield_cp – QuickPIC wit Azimuzal Decomposition","text":"private subroutine init_ufield_cp(this, that, has_2d) Arguments Type Intent Optional Attributes Name class( ufield ), intent(inout) :: this class( ufield ), intent(in) :: that logical, intent(in), optional :: has_2d Calls proc~~init_ufield_cp~~CallsGraph proc~init_ufield_cp init_ufield_cp write_dbg write_dbg proc~init_ufield_cp->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_ufield_cp.html"},{"title":"end_ufield – QuickPIC wit Azimuzal Decomposition","text":"private subroutine end_ufield(this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(inout) :: this Calls proc~~end_ufield~~CallsGraph proc~end_ufield end_ufield write_dbg write_dbg proc~end_ufield->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/end_ufield.html"},{"title":"copy_slice – QuickPIC wit Azimuzal Decomposition","text":"private subroutine copy_slice(this, idx, dir) Arguments Type Intent Optional Attributes Name class( ufield ), intent(inout) :: this integer, intent(in) :: idx integer, intent(in) :: dir Calls proc~~copy_slice~~CallsGraph proc~copy_slice copy_slice write_dbg write_dbg proc~copy_slice->write_dbg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/copy_slice.html"},{"title":"assign_array – QuickPIC wit Azimuzal Decomposition","text":"private subroutine assign_array(this, that) Arguments Type Intent Optional Attributes Name class( ufield ), intent(inout) :: this class(*), intent(in) :: that Contents None","tags":"","loc":"proc/assign_array.html"},{"title":"input_class – QuickPIC wit Azimuzal Decomposition","text":"Uses parallel_class parallel_pipe_class grid_class mpi json_module system module~~input_class~~UsesGraph module~input_class input_class mpi mpi module~input_class->mpi module~parallel_class parallel_class module~input_class->module~parallel_class module~grid_class grid_class module~input_class->module~grid_class module~parallel_pipe_class parallel_pipe_class module~input_class->module~parallel_pipe_class module~system system module~input_class->module~system json_module json_module module~input_class->json_module module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib module~grid_class->module~parallel_pipe_class module~grid_class->module~system module~parallel_pipe_class->mpi module~parallel_pipe_class->module~parallel_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~input_class~~UsedByGraph module~input_class input_class module~simulation_class simulation_class module~simulation_class->module~input_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables cls_name cls_level gp p pp Derived Types input_json Functions found Subroutines read_input_json initialize set_json_core_in_file load_file print_to_string load_from_string json_file_get_object json_file_get_integer json_file_get_double json_file_get_logical json_file_get_string json_file_get_integer_vec json_file_get_double_vec json_file_get_logical_vec json_file_get_string_vec json_file_get_alloc_string_vec json_file_get_root json_file_variable_info Variables Type Visibility Attributes Name Initial character(len=10), private, save :: cls_name = 'input' integer, private, parameter :: cls_level = 1 type( grid ), private, save, target :: gp type( parallel ), private, save, target :: p type( parallel_pipe ), private, save, target :: pp Derived Types type, public :: input_json Components Type Visibility Attributes Name Initial class( parallel ), public, pointer :: p => null() class( parallel_pipe ), public, pointer :: pp => null() class( grid ), public, pointer :: gp => null() type(json_file), private, pointer :: input => null() Type-Bound Procedures generic, public :: new => read_input_json generic, public :: get => json_file_get_object, json_file_get_integer, json_file_get_double, json_file_get_logical, json_file_get_string, json_file_get_integer_vec, json_file_get_double_vec, json_file_get_logical_vec, json_file_get_string_vec, json_file_get_alloc_string_vec, json_file_get_root generic, public :: info => json_file_variable_info procedure, public :: found procedure, private :: read_input_json procedure, private :: set_json_core_in_file procedure, private :: initialize procedure, private :: print_to_string procedure, private :: load_file procedure, private :: load_from_string procedure, private :: json_file_get_root procedure, private :: json_file_get_alloc_string_vec procedure, private :: json_file_get_string_vec procedure, private :: json_file_get_logical_vec procedure, private :: json_file_get_double_vec procedure, private :: json_file_get_integer_vec procedure, private :: json_file_get_string procedure, private :: json_file_get_logical procedure, private :: json_file_get_double procedure, private :: json_file_get_integer procedure, private :: json_file_get_object procedure, private :: json_file_variable_info Functions private function found (this, path) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path Return Value logical Subroutines private subroutine read_input_json (this) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this private subroutine initialize (this, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys, no_whitespace, unescape_strings, comment_char, path_mode, path_separator, compress_vectors, allow_duplicate_keys) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this logical, intent(in), optional :: verbose logical, intent(in), optional :: compact_reals logical, intent(in), optional :: print_signs character(len=*), intent(in), optional :: real_format integer, intent(in), optional :: spaces_per_tab logical, intent(in), optional :: strict_type_checking logical, intent(in), optional :: trailing_spaces_significant logical, intent(in), optional :: case_sensitive_keys logical, intent(in), optional :: no_whitespace logical, intent(in), optional :: unescape_strings character(len=1), intent(in), optional :: comment_char integer, intent(in), optional :: path_mode character(len=1), intent(in), optional :: path_separator logical, intent(in), optional :: compress_vectors logical, intent(in), optional :: allow_duplicate_keys private subroutine set_json_core_in_file (this, core) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this type(json_core), intent(in) :: core private subroutine load_file (this, filename, unit) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: filename integer, intent(in), optional :: unit private subroutine print_to_string (this, str) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=:), intent(out), allocatable :: str private subroutine load_from_string (this, str) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: str private subroutine json_file_get_object (this, path, p) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path type(json_value), intent(out), pointer :: p private subroutine json_file_get_integer (this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path integer, intent(out) :: val private subroutine json_file_get_double (this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path real, intent(out) :: val private subroutine json_file_get_logical (this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path logical, intent(out) :: val private subroutine json_file_get_string (this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path character(len=:), intent(out), allocatable :: val private subroutine json_file_get_integer_vec (this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path integer, intent(out), dimension(:), allocatable :: vec private subroutine json_file_get_double_vec (this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path real, intent(out), dimension(:), allocatable :: vec private subroutine json_file_get_logical_vec (this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path logical, intent(out), dimension(:), allocatable :: vec private subroutine json_file_get_string_vec (this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path character(len=*), intent(out), dimension(:), allocatable :: vec private subroutine json_file_get_alloc_string_vec (this, path, vec, ilen) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path character(len=:), intent(out), dimension(:), allocatable :: vec integer, intent(out), dimension(:), allocatable :: ilen private subroutine json_file_get_root (this, p) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this type(json_value), intent(out), pointer :: p private subroutine json_file_variable_info (this, path, n_children) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path integer, intent(out) :: n_children","tags":"","loc":"module/input_class.html"},{"title":"grid_class – QuickPIC wit Azimuzal Decomposition","text":"Uses parallel_pipe_class system module~~grid_class~~UsesGraph module~grid_class grid_class module~system system module~grid_class->module~system module~parallel_pipe_class parallel_pipe_class module~grid_class->module~parallel_pipe_class module~parallel_class parallel_class module~parallel_pipe_class->module~parallel_class mpi mpi module~parallel_pipe_class->mpi module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~grid_class~~UsedByGraph module~grid_class grid_class module~field_class field_class module~field_class->module~grid_class module~ufield_class ufield_class module~field_class->module~ufield_class module~field_src_class field_src_class module~field_src_class->module~grid_class module~field_src_class->module~field_class module~input_class input_class module~input_class->module~grid_class module~ufield_class->module~grid_class module~field_e_class field_e_class module~field_e_class->module~grid_class module~field_e_class->module~field_class module~field_e_class->module~field_src_class module~field_e_class->module~ufield_class module~field_b_class field_b_class module~field_e_class->module~field_b_class module~field_psi_class field_psi_class module~field_e_class->module~field_psi_class module~field_b_class->module~grid_class module~field_b_class->module~field_class module~field_b_class->module~field_src_class module~field_b_class->module~ufield_class module~simulation_class simulation_class module~simulation_class->module~grid_class module~simulation_class->module~field_src_class module~simulation_class->module~input_class module~simulation_class->module~field_e_class module~simulation_class->module~field_b_class module~simulation_class->module~field_psi_class module~field_psi_class->module~grid_class module~field_psi_class->module~field_class module~field_psi_class->module~field_src_class module~field_psi_class->module~ufield_class program~test_field_eperp test_field_eperp program~test_field_eperp->module~field_class program~test_field_eperp->module~field_src_class program~test_field_eperp->module~ufield_class program~test_field_eperp->module~field_e_class program~test_field_eperp->module~field_b_class program~test_field_eperp->module~field_psi_class program~test_field_bz test_field_bz program~test_field_bz->module~field_class program~test_field_bz->module~field_src_class program~test_field_bz->module~ufield_class program~test_field_bz->module~field_b_class program~test_field_psi test_field_psi program~test_field_psi->module~field_class program~test_field_psi->module~field_src_class program~test_field_psi->module~ufield_class program~test_field_psi->module~field_psi_class program~test_field_bperp test_field_bperp program~test_field_bperp->module~field_class program~test_field_bperp->module~field_src_class program~test_field_bperp->module~ufield_class program~test_field_bperp->module~field_b_class program~test_ufield test_ufield program~test_ufield->module~ufield_class program~test_field_ez test_field_ez program~test_field_ez->module~field_class program~test_field_ez->module~field_src_class program~test_field_ez->module~ufield_class program~test_field_ez->module~field_e_class program~test_field_eperp~2 test_field_eperp program~test_field_eperp~2->module~field_class program~test_field_eperp~2->module~field_src_class program~test_field_eperp~2->module~ufield_class program~test_field_eperp~2->module~field_e_class program~test_field_eperp~2->module~field_b_class program~test_field_bperp_iter test_field_bperp_iter program~test_field_bperp_iter->module~field_class program~test_field_bperp_iter->module~field_src_class program~test_field_bperp_iter->module~ufield_class program~test_field_bperp_iter->module~field_b_class var panmodulegrid_classUsedByGraph = svgPanZoom('#modulegrid_classUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables cls_name cls_level Derived Types grid Functions get_nd_all get_nd_dim get_ndp_all get_ndp_dim get_nvp_all get_nvp_dim get_noff_all get_noff_dim Subroutines init_grid end_grid Variables Type Visibility Attributes Name Initial character(len=18), private, save :: cls_name = 'grid' integer, private, parameter :: cls_level = 0 Derived Types type, public :: grid Components Type Visibility Attributes Name Initial integer, private, dimension(2) :: nd integer, private, dimension(2) :: ndp integer, private, dimension(2) :: nvp integer, private, dimension(2) :: noff Type-Bound Procedures generic, public :: new => init_grid generic, public :: del => end_grid generic, public :: get_noff => get_noff_all, get_noff_dim generic, public :: get_nd => get_nd_all, get_nd_dim generic, public :: get_ndp => get_ndp_all, get_ndp_dim generic, public :: get_nvp => get_nvp_all, get_nvp_dim procedure, private :: end_grid procedure, private :: init_grid procedure, private :: get_noff_dim procedure, private :: get_noff_all procedure, private :: get_nd_dim procedure, private :: get_nd_all procedure, private :: get_ndp_dim procedure, private :: get_ndp_all procedure, private :: get_nvp_dim procedure, private :: get_nvp_all Functions private function get_nd_all (this) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this Return Value integer,\n  dimension(2) private function get_nd_dim (this, dim) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this integer, intent(in) :: dim Return Value integer private function get_ndp_all (this) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this Return Value integer,\n  dimension(2) private function get_ndp_dim (this, dim) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this integer, intent(in) :: dim Return Value integer private function get_nvp_all (this) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this Return Value integer,\n  dimension(2) private function get_nvp_dim (this, dim) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this integer, intent(in) :: dim Return Value integer private function get_noff_all (this) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this Return Value integer,\n  dimension(2) private function get_noff_dim (this, dim) Arguments Type Intent Optional Attributes Name class( grid ), intent(in) :: this integer, intent(in) :: dim Return Value integer Subroutines private subroutine init_grid (this, pp, nr, nz) Arguments Type Intent Optional Attributes Name class( grid ), intent(inout) :: this class( parallel_pipe ), intent(in) :: pp integer, intent(in) :: nr integer, intent(in) :: nz private subroutine end_grid (this) Arguments Type Intent Optional Attributes Name class( grid ), intent(inout) :: this","tags":"","loc":"module/grid_class.html"},{"title":"field_psi_class – QuickPIC wit Azimuzal Decomposition","text":"Uses parallel_pipe_class grid_class field_class field_solver_class field_src_class ufield_class param system module~~field_psi_class~~UsesGraph module~field_psi_class field_psi_class module~field_class field_class module~field_psi_class->module~field_class module~field_src_class field_src_class module~field_psi_class->module~field_src_class module~param param module~field_psi_class->module~param module~ufield_class ufield_class module~field_psi_class->module~ufield_class module~grid_class grid_class module~field_psi_class->module~grid_class module~parallel_pipe_class parallel_pipe_class module~field_psi_class->module~parallel_pipe_class module~field_solver_class field_solver_class module~field_psi_class->module~field_solver_class module~system system module~field_psi_class->module~system module~field_class->module~param module~field_class->module~ufield_class module~field_class->module~grid_class module~field_class->module~parallel_pipe_class module~field_class->module~system module~field_src_class->module~field_class module~field_src_class->module~param module~field_src_class->module~grid_class module~field_src_class->module~parallel_pipe_class module~field_src_class->module~system module~ufield_class->module~param module~ufield_class->module~grid_class module~ufield_class->module~parallel_pipe_class module~ufield_class->module~system module~grid_class->module~parallel_pipe_class module~grid_class->module~system module~parallel_class parallel_class module~parallel_pipe_class->module~parallel_class mpi mpi module~parallel_pipe_class->mpi module~field_solver_class->module~param module~field_solver_class->module~system module~field_solver_class->mpi module~debug_tool debug_tool module~field_solver_class->module~debug_tool module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib var panmodulefield_psi_classUsesGraph = svgPanZoom('#modulefield_psi_classUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~field_psi_class~~UsedByGraph module~field_psi_class field_psi_class program~test_field_eperp test_field_eperp program~test_field_eperp->module~field_psi_class module~field_e_class field_e_class program~test_field_eperp->module~field_e_class program~test_field_psi test_field_psi program~test_field_psi->module~field_psi_class module~simulation_class simulation_class module~simulation_class->module~field_psi_class module~simulation_class->module~field_e_class module~field_e_class->module~field_psi_class program~test_field_ez test_field_ez program~test_field_ez->module~field_e_class program~test_field_eperp~2 test_field_eperp program~test_field_eperp~2->module~field_e_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables cls_name cls_level Derived Types field_psi Subroutines init_field_psi end_field_psi set_source get_solution solve_field_psi Variables Type Visibility Attributes Name Initial character(len=20), private, parameter :: cls_name = \"field_psi\" integer, private, parameter :: cls_level = 1 Derived Types type, public, extends( field ) :: field_psi Components Type Visibility Attributes Name Initial class( ufield ), public, dimension(:), pointer :: rf_re => null() class( ufield ), public, dimension(:), pointer :: rf_im => null() real, public :: dr real, public :: dxi integer, public :: num_modes integer, public :: entity class( field_solver ), public, dimension(:), pointer :: solver => null() real, public, dimension(:), pointer :: buf_re => null() real, public, dimension(:), pointer :: buf_im => null() Type-Bound Procedures generic, public :: get_rf_re => get_rf_re_all, get_rf_re_mode generic, public :: get_rf_im => get_rf_im_all, get_rf_im_mode procedure, public :: get_num_modes procedure, public :: get_dxi procedure, public :: get_dr generic, public :: new => init_field, init_field_psi procedure, public :: del => end_field_psi generic, public :: solve => solve_field_psi procedure, private :: init_field_psi procedure, private :: end_field_psi procedure, private :: set_source procedure, private :: get_solution procedure, private :: solve_field_psi Subroutines private subroutine init_field_psi (this, pp, gp, dr, dxi, num_modes, part_shape) Arguments Type Intent Optional Attributes Name class( field_psi ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape private subroutine end_field_psi (this) Arguments Type Intent Optional Attributes Name class( field_psi ), intent(inout) :: this private subroutine set_source (this, mode, q_re, q_im) Arguments Type Intent Optional Attributes Name class( field_psi ), intent(inout) :: this integer, intent(in) :: mode class( ufield ), intent(in) :: q_re class( ufield ), intent(in), optional :: q_im private subroutine get_solution (this, mode) Arguments Type Intent Optional Attributes Name class( field_psi ), intent(inout) :: this integer, intent(in) :: mode private subroutine solve_field_psi (this, q) Arguments Type Intent Optional Attributes Name class( field_psi ), intent(inout) :: this class( field_rho ), intent(in) :: q","tags":"","loc":"module/field_psi_class.html"},{"title":"simulation_class – QuickPIC wit Azimuzal Decomposition","text":"Uses parallel_class parallel_pipe_class grid_class field_psi_class field_e_class field_b_class field_src_class input_class system param mpi module~~simulation_class~~UsesGraph module~simulation_class simulation_class mpi mpi module~simulation_class->mpi module~field_src_class field_src_class module~simulation_class->module~field_src_class module~input_class input_class module~simulation_class->module~input_class module~parallel_class parallel_class module~simulation_class->module~parallel_class module~param param module~simulation_class->module~param module~field_e_class field_e_class module~simulation_class->module~field_e_class module~grid_class grid_class module~simulation_class->module~grid_class module~parallel_pipe_class parallel_pipe_class module~simulation_class->module~parallel_pipe_class module~field_b_class field_b_class module~simulation_class->module~field_b_class module~system system module~simulation_class->module~system module~field_psi_class field_psi_class module~simulation_class->module~field_psi_class module~field_src_class->module~param module~field_src_class->module~grid_class module~field_src_class->module~parallel_pipe_class module~field_src_class->module~system module~field_class field_class module~field_src_class->module~field_class module~input_class->mpi module~input_class->module~parallel_class module~input_class->module~grid_class module~input_class->module~parallel_pipe_class module~input_class->module~system json_module json_module module~input_class->json_module module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib module~field_e_class->module~field_src_class module~field_e_class->module~param module~field_e_class->module~grid_class module~field_e_class->module~parallel_pipe_class module~field_e_class->module~field_b_class module~field_e_class->module~system module~field_e_class->module~field_psi_class module~field_e_class->module~field_class module~ufield_class ufield_class module~field_e_class->module~ufield_class module~field_solver_class field_solver_class module~field_e_class->module~field_solver_class module~grid_class->module~parallel_pipe_class module~grid_class->module~system module~parallel_pipe_class->mpi module~parallel_pipe_class->module~parallel_class module~field_b_class->module~field_src_class module~field_b_class->module~param module~field_b_class->module~grid_class module~field_b_class->module~parallel_pipe_class module~field_b_class->module~system module~debug_tool debug_tool module~field_b_class->module~debug_tool module~field_b_class->module~field_class module~field_b_class->module~ufield_class module~field_b_class->module~field_solver_class module~field_psi_class->module~field_src_class module~field_psi_class->module~param module~field_psi_class->module~grid_class module~field_psi_class->module~parallel_pipe_class module~field_psi_class->module~system module~field_psi_class->module~field_class module~field_psi_class->module~ufield_class module~field_psi_class->module~field_solver_class module~field_class->module~param module~field_class->module~grid_class module~field_class->module~parallel_pipe_class module~field_class->module~system module~field_class->module~ufield_class module~ufield_class->module~param module~ufield_class->module~grid_class module~ufield_class->module~parallel_pipe_class module~ufield_class->module~system module~field_solver_class->mpi module~field_solver_class->module~param module~field_solver_class->module~system module~field_solver_class->module~debug_tool var panmodulesimulation_classUsesGraph = svgPanZoom('#modulesimulation_classUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types sim_fields simulation Subroutines init_sim_fields end_sim_fields init_simulation end_simulation Derived Types type, private :: sim_fields Components Type Visibility Attributes Name Initial class( parallel_pipe ), private, pointer :: pp => null() class( grid ), private, pointer :: gp => null() type( field_psi ), private, allocatable :: psi type( field_b ), private, allocatable :: b_spe type( field_b ), private, allocatable :: b_beam type( field_e ), private, allocatable :: e_spe type( field_e ), private, allocatable :: e_beam type( field_jay ), private, allocatable :: jay type( field_rho ), private, allocatable :: q_spe type( field_rho ), private, allocatable :: q_beam type( field_djdxi ), private, allocatable :: djdxi Type-Bound Procedures generic, public :: new => init_sim_fields generic, public :: del => end_sim_fields procedure, private :: end_sim_fields procedure, private :: init_sim_fields type, public :: simulation Components Type Visibility Attributes Name Initial type( input_json ), private, pointer :: input => null() class( parallel_pipe ), private, pointer :: pp => null() class( grid ), private, pointer :: gp => null() type( sim_fields ), private :: fields real, private :: dr real, private :: dxi real, private :: dt integer, private :: iter integer, private :: nstep3d integer, private :: nstep2d integer, private :: start3d integer, private :: nbeams integer, private :: nspecies integer, private :: tstep integer, private :: num_modes integer, private :: interp Type-Bound Procedures generic, public :: new => init_simulation generic, public :: del => end_simulation procedure, private :: end_simulation procedure, private :: init_simulation Subroutines private subroutine init_sim_fields (this, input, dr, dxi, num_modes, part_shape) Arguments Type Intent Optional Attributes Name class( sim_fields ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape private subroutine end_sim_fields (this) Arguments Type Intent Optional Attributes Name class( sim_fields ), intent(inout) :: this private subroutine init_simulation (this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout) :: this private subroutine end_simulation (this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout) :: this","tags":"","loc":"module/simulation_class.html"},{"title":"field_b_class – QuickPIC wit Azimuzal Decomposition","text":"Uses field_class field_src_class field_solver_class ufield_class param system parallel_pipe_class grid_class debug_tool module~~field_b_class~~UsesGraph module~field_b_class field_b_class module~debug_tool debug_tool module~field_b_class->module~debug_tool module~field_class field_class module~field_b_class->module~field_class module~field_src_class field_src_class module~field_b_class->module~field_src_class module~param param module~field_b_class->module~param module~ufield_class ufield_class module~field_b_class->module~ufield_class module~grid_class grid_class module~field_b_class->module~grid_class module~parallel_pipe_class parallel_pipe_class module~field_b_class->module~parallel_pipe_class module~field_solver_class field_solver_class module~field_b_class->module~field_solver_class module~system system module~field_b_class->module~system module~field_class->module~param module~field_class->module~ufield_class module~field_class->module~grid_class module~field_class->module~parallel_pipe_class module~field_class->module~system module~field_src_class->module~field_class module~field_src_class->module~param module~field_src_class->module~grid_class module~field_src_class->module~parallel_pipe_class module~field_src_class->module~system module~ufield_class->module~param module~ufield_class->module~grid_class module~ufield_class->module~parallel_pipe_class module~ufield_class->module~system module~grid_class->module~parallel_pipe_class module~grid_class->module~system module~parallel_class parallel_class module~parallel_pipe_class->module~parallel_class mpi mpi module~parallel_pipe_class->mpi module~field_solver_class->module~debug_tool module~field_solver_class->module~param module~field_solver_class->module~system module~field_solver_class->mpi module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib var panmodulefield_b_classUsesGraph = svgPanZoom('#modulefield_b_classUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~field_b_class~~UsedByGraph module~field_b_class field_b_class program~test_field_eperp test_field_eperp program~test_field_eperp->module~field_b_class module~field_e_class field_e_class program~test_field_eperp->module~field_e_class program~test_field_bz test_field_bz program~test_field_bz->module~field_b_class program~test_field_bperp test_field_bperp program~test_field_bperp->module~field_b_class module~field_e_class->module~field_b_class program~test_field_eperp~2 test_field_eperp program~test_field_eperp~2->module~field_b_class program~test_field_eperp~2->module~field_e_class program~test_field_bperp_iter test_field_bperp_iter program~test_field_bperp_iter->module~field_b_class module~simulation_class simulation_class module~simulation_class->module~field_b_class module~simulation_class->module~field_e_class program~test_field_ez test_field_ez program~test_field_ez->module~field_e_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables cls_name cls_level Derived Types field_b Subroutines init_field_b end_field_b set_source_bz set_source_bperp set_source_bperp_iter get_solution_bz get_solution_bperp get_solution_bperp_iter solve_field_bz solve_field_bperp solve_field_bperp_iter Variables Type Visibility Attributes Name Initial character(len=20), private, parameter :: cls_name = \"field_b\" integer, private, parameter :: cls_level = 1 Derived Types type, public, extends( field ) :: field_b Components Type Visibility Attributes Name Initial class( ufield ), public, dimension(:), pointer :: rf_re => null() class( ufield ), public, dimension(:), pointer :: rf_im => null() real, public :: dr real, public :: dxi integer, public :: num_modes integer, public :: entity class( field_solver ), public, dimension(:), pointer :: solver_bz => null() class( field_solver ), public, dimension(:), pointer :: solver_bperp => null() class( field_solver ), public, dimension(:), pointer :: solver_bperp_iter => null() real, public, dimension(:), pointer :: buf_re => null() real, public, dimension(:), pointer :: buf_im => null() real, public, dimension(:), pointer :: buf => null() Type-Bound Procedures generic, public :: get_rf_re => get_rf_re_all, get_rf_re_mode generic, public :: get_rf_im => get_rf_im_all, get_rf_im_mode procedure, public :: get_num_modes procedure, public :: get_dxi procedure, public :: get_dr generic, public :: new => init_field, init_field_b procedure, public :: del => end_field_b generic, public :: solve => solve_field_bz, solve_field_bperp, solve_field_bperp_iter procedure, private :: init_field_b procedure, private :: end_field_b procedure, private :: set_source_bz procedure, private :: set_source_bperp procedure, private :: set_source_bperp_iter procedure, private :: get_solution_bz procedure, private :: get_solution_bperp procedure, private :: get_solution_bperp_iter procedure, private :: solve_field_bz procedure, private :: solve_field_bperp procedure, private :: solve_field_bperp_iter Subroutines private subroutine init_field_b (this, pp, gp, dr, dxi, num_modes, part_shape, entity) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape integer, intent(in) :: entity private subroutine end_field_b (this) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this private subroutine set_source_bz (this, mode, jay_re, jay_im) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this integer, intent(in) :: mode class( ufield ), intent(in) :: jay_re class( ufield ), intent(in), optional :: jay_im private subroutine set_source_bperp (this, mode, q_re, q_im) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this integer, intent(in) :: mode class( ufield ), intent(in) :: q_re class( ufield ), intent(in), optional :: q_im private subroutine set_source_bperp_iter (this, mode, djdxi_re, jay_re, djdxi_im, jay_im) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this integer, intent(in) :: mode class( ufield ), intent(in) :: djdxi_re class( ufield ), intent(in) :: jay_re class( ufield ), intent(in), optional :: djdxi_im class( ufield ), intent(in), optional :: jay_im private subroutine get_solution_bz (this, mode) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this integer, intent(in) :: mode private subroutine get_solution_bperp (this, mode) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this integer, intent(in) :: mode private subroutine get_solution_bperp_iter (this, mode) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this integer, intent(in) :: mode private subroutine solve_field_bz (this, jay) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this class( field_jay ), intent(in) :: jay private subroutine solve_field_bperp (this, rho) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this class( field_rho ), intent(in) :: rho private subroutine solve_field_bperp_iter (this, djdxi, jay) Arguments Type Intent Optional Attributes Name class( field_b ), intent(inout) :: this class( field_djdxi ), intent(in) :: djdxi class( field_jay ), intent(in) :: jay","tags":"","loc":"module/field_b_class.html"},{"title":"field_e_class – QuickPIC wit Azimuzal Decomposition","text":"Uses parallel_pipe_class grid_class field_class field_b_class field_psi_class field_src_class field_solver_class ufield_class param system module~~field_e_class~~UsesGraph module~field_e_class field_e_class module~field_class field_class module~field_e_class->module~field_class module~field_src_class field_src_class module~field_e_class->module~field_src_class module~param param module~field_e_class->module~param module~ufield_class ufield_class module~field_e_class->module~ufield_class module~grid_class grid_class module~field_e_class->module~grid_class module~parallel_pipe_class parallel_pipe_class module~field_e_class->module~parallel_pipe_class module~field_solver_class field_solver_class module~field_e_class->module~field_solver_class module~field_b_class field_b_class module~field_e_class->module~field_b_class module~system system module~field_e_class->module~system module~field_psi_class field_psi_class module~field_e_class->module~field_psi_class module~field_class->module~param module~field_class->module~ufield_class module~field_class->module~grid_class module~field_class->module~parallel_pipe_class module~field_class->module~system module~field_src_class->module~field_class module~field_src_class->module~param module~field_src_class->module~grid_class module~field_src_class->module~parallel_pipe_class module~field_src_class->module~system module~ufield_class->module~param module~ufield_class->module~grid_class module~ufield_class->module~parallel_pipe_class module~ufield_class->module~system module~grid_class->module~parallel_pipe_class module~grid_class->module~system module~parallel_class parallel_class module~parallel_pipe_class->module~parallel_class mpi mpi module~parallel_pipe_class->mpi module~field_solver_class->module~param module~field_solver_class->module~system module~field_solver_class->mpi module~debug_tool debug_tool module~field_solver_class->module~debug_tool module~field_b_class->module~field_class module~field_b_class->module~field_src_class module~field_b_class->module~param module~field_b_class->module~ufield_class module~field_b_class->module~grid_class module~field_b_class->module~parallel_pipe_class module~field_b_class->module~field_solver_class module~field_b_class->module~system module~field_b_class->module~debug_tool module~field_psi_class->module~field_class module~field_psi_class->module~field_src_class module~field_psi_class->module~param module~field_psi_class->module~ufield_class module~field_psi_class->module~grid_class module~field_psi_class->module~parallel_pipe_class module~field_psi_class->module~field_solver_class module~field_psi_class->module~system module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib var panmodulefield_e_classUsesGraph = svgPanZoom('#modulefield_e_classUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~field_e_class~~UsedByGraph module~field_e_class field_e_class program~test_field_eperp test_field_eperp program~test_field_eperp->module~field_e_class program~test_field_ez test_field_ez program~test_field_ez->module~field_e_class program~test_field_eperp~2 test_field_eperp program~test_field_eperp~2->module~field_e_class module~simulation_class simulation_class module~simulation_class->module~field_e_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables cls_name cls_level Derived Types field_e Subroutines init_field_e end_field_e set_source_ez get_solution_ez solve_field_ez solve_field_eperp solve_field_eperp_beam Variables Type Visibility Attributes Name Initial character(len=20), private, parameter :: cls_name = \"field_e\" integer, private, parameter :: cls_level = 1 Derived Types type, public, extends( field ) :: field_e Components Type Visibility Attributes Name Initial class( ufield ), public, dimension(:), pointer :: rf_re => null() class( ufield ), public, dimension(:), pointer :: rf_im => null() real, public :: dr real, public :: dxi integer, public :: num_modes integer, public :: entity class( field_solver ), public, dimension(:), pointer :: solver_ez => null() real, public, dimension(:), pointer :: buf_re => null() real, public, dimension(:), pointer :: buf_im => null() Type-Bound Procedures generic, public :: get_rf_re => get_rf_re_all, get_rf_re_mode generic, public :: get_rf_im => get_rf_im_all, get_rf_im_mode procedure, public :: get_num_modes procedure, public :: get_dxi procedure, public :: get_dr generic, public :: new => init_field, init_field_e procedure, public :: del => end_field_e generic, public :: solve => solve_field_ez, solve_field_eperp, solve_field_eperp_beam procedure, private :: init_field_e procedure, private :: end_field_e procedure, private :: set_source_ez procedure, private :: get_solution_ez procedure, private :: solve_field_ez procedure, private :: solve_field_eperp procedure, private :: solve_field_eperp_beam Subroutines private subroutine init_field_e (this, pp, gp, dr, dxi, num_modes, part_shape, entity) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape integer, intent(in) :: entity private subroutine end_field_e (this) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this private subroutine set_source_ez (this, mode, jay_re, jay_im) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this integer, intent(in) :: mode class( ufield ), intent(in) :: jay_re class( ufield ), intent(in), optional :: jay_im private subroutine get_solution_ez (this, mode) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this integer, intent(in) :: mode private subroutine solve_field_ez (this, jay) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this class( field_jay ), intent(in) :: jay private subroutine solve_field_eperp (this, b, psi) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this class( field_b ), intent(in) :: b class( field_psi ), intent(in) :: psi private subroutine solve_field_eperp_beam (this, b) Arguments Type Intent Optional Attributes Name class( field_e ), intent(inout) :: this class( field_b ), intent(in) :: b","tags":"","loc":"module/field_e_class.html"},{"title":"param – QuickPIC wit Azimuzal Decomposition","text":"Used by module~~param~~UsedByGraph module~param param program~test_field_eperp test_field_eperp program~test_field_eperp->module~param module~field_class field_class program~test_field_eperp->module~field_class module~field_src_class field_src_class program~test_field_eperp->module~field_src_class module~ufield_class ufield_class program~test_field_eperp->module~ufield_class module~field_e_class field_e_class program~test_field_eperp->module~field_e_class module~field_b_class field_b_class program~test_field_eperp->module~field_b_class module~field_psi_class field_psi_class program~test_field_eperp->module~field_psi_class module~field_class->module~param module~field_class->module~ufield_class module~field_src_class->module~param module~field_src_class->module~field_class program~test_field_bz test_field_bz program~test_field_bz->module~param program~test_field_bz->module~field_class program~test_field_bz->module~field_src_class program~test_field_bz->module~ufield_class program~test_field_bz->module~field_b_class program~test_field_psi test_field_psi program~test_field_psi->module~param program~test_field_psi->module~field_class program~test_field_psi->module~field_src_class program~test_field_psi->module~ufield_class program~test_field_psi->module~field_psi_class module~ufield_class->module~param module~field_e_class->module~param module~field_e_class->module~field_class module~field_e_class->module~field_src_class module~field_e_class->module~ufield_class module~field_solver_class field_solver_class module~field_e_class->module~field_solver_class module~field_e_class->module~field_b_class module~field_e_class->module~field_psi_class program~test_field_bperp test_field_bperp program~test_field_bperp->module~param program~test_field_bperp->module~field_class program~test_field_bperp->module~field_src_class program~test_field_bperp->module~ufield_class program~test_field_bperp->module~field_b_class program~test_field_ez test_field_ez program~test_field_ez->module~param program~test_field_ez->module~field_class program~test_field_ez->module~field_src_class program~test_field_ez->module~ufield_class program~test_field_ez->module~field_e_class program~test_field_eperp~2 test_field_eperp program~test_field_eperp~2->module~param program~test_field_eperp~2->module~field_class program~test_field_eperp~2->module~field_src_class program~test_field_eperp~2->module~ufield_class program~test_field_eperp~2->module~field_e_class program~test_field_eperp~2->module~field_b_class module~field_solver_class->module~param program~test_field_bperp_iter test_field_bperp_iter program~test_field_bperp_iter->module~param program~test_field_bperp_iter->module~field_class program~test_field_bperp_iter->module~field_src_class program~test_field_bperp_iter->module~ufield_class program~test_field_bperp_iter->module~field_b_class module~field_b_class->module~param module~field_b_class->module~field_class module~field_b_class->module~field_src_class module~field_b_class->module~ufield_class module~field_b_class->module~field_solver_class module~simulation_class simulation_class module~simulation_class->module~param module~simulation_class->module~field_src_class module~simulation_class->module~field_e_class module~simulation_class->module~field_b_class module~simulation_class->module~field_psi_class module~field_psi_class->module~param module~field_psi_class->module~field_class module~field_psi_class->module~field_src_class module~field_psi_class->module~ufield_class module~field_psi_class->module~field_solver_class program~test_ufield test_ufield program~test_ufield->module~ufield_class var panmoduleparamUsedByGraph = svgPanZoom('#moduleparamUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables pi p_real p_imag p_max_xdim p_lower p_upper p_ps_linear p_ps_quadratic p_fs_2order p_fs_4order p_bnd_axial p_bnd_conduct p_fk_psi p_fk_ez p_fk_bz p_fk_bperp p_fk_br_iter p_fk_bphi_iter p_fk_bperp_iter p_entity_none p_entity_beam p_entity_plasma HYPRE_TYPE HYPRE_PARCSR p_hypre_cycred p_hypre_pcg p_hypre_smg p_hypre_gmres p_hypre_amg p_hypre_parpcg p_copy_1to2 p_copy_2to1 Variables Type Visibility Attributes Name Initial real, public, parameter :: pi = 3.14159265359 integer, public, parameter :: p_real = 0 integer, public, parameter :: p_imag = 1 integer, public, parameter :: p_max_xdim = 3 integer, public, parameter :: p_lower = 1 integer, public, parameter :: p_upper = 2 integer, public, parameter :: p_ps_linear = 1 integer, public, parameter :: p_ps_quadratic = 2 integer, public, parameter :: p_fs_2order = 1 integer, public, parameter :: p_fs_4order = 2 integer, public, parameter :: p_bnd_axial = 0 integer, public, parameter :: p_bnd_conduct = 1 integer, public, parameter :: p_fk_psi = 0 integer, public, parameter :: p_fk_ez = 1 integer, public, parameter :: p_fk_bz = 2 integer, public, parameter :: p_fk_bperp = 3 integer, public, parameter :: p_fk_br_iter = 4 integer, public, parameter :: p_fk_bphi_iter = 5 integer, public, parameter :: p_fk_bperp_iter = 6 integer, public, parameter :: p_entity_none = 0 integer, public, parameter :: p_entity_beam = 1 integer, public, parameter :: p_entity_plasma = 2 integer, public, parameter :: HYPRE_TYPE = 8 integer, public, parameter :: HYPRE_PARCSR = 5555 integer, public, parameter :: p_hypre_cycred = 1 integer, public, parameter :: p_hypre_pcg = 2 integer, public, parameter :: p_hypre_smg = 3 integer, public, parameter :: p_hypre_gmres = 4 integer, public, parameter :: p_hypre_amg = 5 integer, public, parameter :: p_hypre_parpcg = 6 integer, public, parameter :: p_copy_1to2 = 1 integer, public, parameter :: p_copy_2to1 = -1","tags":"","loc":"module/param.html"},{"title":"field_class – QuickPIC wit Azimuzal Decomposition","text":"Uses parallel_pipe_class grid_class ufield_class param system module~~field_class~~UsesGraph module~field_class field_class module~param param module~field_class->module~param module~ufield_class ufield_class module~field_class->module~ufield_class module~grid_class grid_class module~field_class->module~grid_class module~parallel_pipe_class parallel_pipe_class module~field_class->module~parallel_pipe_class module~system system module~field_class->module~system module~ufield_class->module~param module~ufield_class->module~grid_class module~ufield_class->module~parallel_pipe_class module~ufield_class->module~system module~grid_class->module~parallel_pipe_class module~grid_class->module~system module~parallel_class parallel_class module~parallel_pipe_class->module~parallel_class mpi mpi module~parallel_pipe_class->mpi module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~field_class~~UsedByGraph module~field_class field_class program~test_field_eperp test_field_eperp program~test_field_eperp->module~field_class module~field_src_class field_src_class program~test_field_eperp->module~field_src_class module~field_e_class field_e_class program~test_field_eperp->module~field_e_class module~field_b_class field_b_class program~test_field_eperp->module~field_b_class module~field_psi_class field_psi_class program~test_field_eperp->module~field_psi_class module~field_src_class->module~field_class program~test_field_bz test_field_bz program~test_field_bz->module~field_class program~test_field_bz->module~field_src_class program~test_field_bz->module~field_b_class program~test_field_psi test_field_psi program~test_field_psi->module~field_class program~test_field_psi->module~field_src_class program~test_field_psi->module~field_psi_class program~test_field_bperp test_field_bperp program~test_field_bperp->module~field_class program~test_field_bperp->module~field_src_class program~test_field_bperp->module~field_b_class module~field_e_class->module~field_class module~field_e_class->module~field_src_class module~field_e_class->module~field_b_class module~field_e_class->module~field_psi_class program~test_field_ez test_field_ez program~test_field_ez->module~field_class program~test_field_ez->module~field_src_class program~test_field_ez->module~field_e_class program~test_field_eperp~2 test_field_eperp program~test_field_eperp~2->module~field_class program~test_field_eperp~2->module~field_src_class program~test_field_eperp~2->module~field_e_class program~test_field_eperp~2->module~field_b_class program~test_field_bperp_iter test_field_bperp_iter program~test_field_bperp_iter->module~field_class program~test_field_bperp_iter->module~field_src_class program~test_field_bperp_iter->module~field_b_class module~field_b_class->module~field_class module~field_b_class->module~field_src_class module~field_psi_class->module~field_class module~field_psi_class->module~field_src_class module~simulation_class simulation_class module~simulation_class->module~field_src_class module~simulation_class->module~field_e_class module~simulation_class->module~field_b_class module~simulation_class->module~field_psi_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables cls_name cls_level Derived Types field Functions get_dr get_dxi get_num_modes get_rf_re_all get_rf_re_mode get_rf_im_all get_rf_im_mode Subroutines init_field end_field Variables Type Visibility Attributes Name Initial character(len=20), private, parameter :: cls_name = \"field\" integer, private, parameter :: cls_level = 1 Derived Types type, public :: field Components Type Visibility Attributes Name Initial class( ufield ), public, dimension(:), pointer :: rf_re => null() class( ufield ), public, dimension(:), pointer :: rf_im => null() real, public :: dr real, public :: dxi integer, public :: num_modes integer, public :: entity Type-Bound Procedures generic, public :: new => init_field procedure, public :: del => end_field generic, public :: get_rf_re => get_rf_re_all, get_rf_re_mode generic, public :: get_rf_im => get_rf_im_all, get_rf_im_mode procedure, public :: get_num_modes procedure, public :: get_dxi procedure, public :: get_dr procedure, private :: end_field procedure, private :: init_field procedure, private :: get_rf_im_mode procedure, private :: get_rf_im_all procedure, private :: get_rf_re_mode procedure, private :: get_rf_re_all Functions private function get_dr (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value real private function get_dxi (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value real private function get_num_modes (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value integer private function get_rf_re_all (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value type( ufield ),\n  dimension(:), pointer private function get_rf_re_mode (this, mode) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this integer, intent(in) :: mode Return Value type( ufield ),\n  pointer private function get_rf_im_all (this) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this Return Value type( ufield ),\n  dimension(:), pointer private function get_rf_im_mode (this, mode) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this integer, intent(in) :: mode Return Value type( ufield ),\n  pointer Subroutines private subroutine init_field (this, pp, gp, dim, dr, dxi, num_modes, gc_num, entity) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp integer, intent(in) :: dim real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in), dimension(2,2) :: gc_num integer, intent(in), optional :: entity private subroutine end_field (this) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this","tags":"","loc":"module/field_class.html"},{"title":"system – QuickPIC wit Azimuzal Decomposition","text":"Used by module~~system~~UsedByGraph module~system system program~test_field_eperp test_field_eperp program~test_field_eperp->module~system module~field_class field_class program~test_field_eperp->module~field_class module~field_src_class field_src_class program~test_field_eperp->module~field_src_class module~ufield_class ufield_class program~test_field_eperp->module~ufield_class module~field_e_class field_e_class program~test_field_eperp->module~field_e_class module~field_b_class field_b_class program~test_field_eperp->module~field_b_class module~field_psi_class field_psi_class program~test_field_eperp->module~field_psi_class module~field_class->module~system module~field_class->module~ufield_class module~grid_class grid_class module~field_class->module~grid_class module~field_src_class->module~system module~field_src_class->module~field_class module~field_src_class->module~grid_class module~input_class input_class module~input_class->module~system module~input_class->module~grid_class program~test_field_bz test_field_bz program~test_field_bz->module~system program~test_field_bz->module~field_class program~test_field_bz->module~field_src_class program~test_field_bz->module~ufield_class program~test_field_bz->module~field_b_class program~test_field_psi test_field_psi program~test_field_psi->module~system program~test_field_psi->module~field_class program~test_field_psi->module~field_src_class program~test_field_psi->module~ufield_class program~test_field_psi->module~field_psi_class module~ufield_class->module~system module~ufield_class->module~grid_class module~field_e_class->module~system module~field_e_class->module~field_class module~field_e_class->module~field_src_class module~field_e_class->module~ufield_class module~field_e_class->module~grid_class module~field_solver_class field_solver_class module~field_e_class->module~field_solver_class module~field_e_class->module~field_b_class module~field_e_class->module~field_psi_class program~test_field_bperp test_field_bperp program~test_field_bperp->module~system program~test_field_bperp->module~field_class program~test_field_bperp->module~field_src_class program~test_field_bperp->module~ufield_class program~test_field_bperp->module~field_b_class module~grid_class->module~system program~test_field_ez test_field_ez program~test_field_ez->module~system program~test_field_ez->module~field_class program~test_field_ez->module~field_src_class program~test_field_ez->module~ufield_class program~test_field_ez->module~field_e_class program~test_field_eperp~2 test_field_eperp program~test_field_eperp~2->module~system program~test_field_eperp~2->module~field_class program~test_field_eperp~2->module~field_src_class program~test_field_eperp~2->module~ufield_class program~test_field_eperp~2->module~field_e_class program~test_field_eperp~2->module~field_b_class module~field_solver_class->module~system program~test_field_bperp_iter test_field_bperp_iter program~test_field_bperp_iter->module~system program~test_field_bperp_iter->module~field_class program~test_field_bperp_iter->module~field_src_class program~test_field_bperp_iter->module~ufield_class program~test_field_bperp_iter->module~field_b_class module~field_b_class->module~system module~field_b_class->module~field_class module~field_b_class->module~field_src_class module~field_b_class->module~ufield_class module~field_b_class->module~grid_class module~field_b_class->module~field_solver_class module~simulation_class simulation_class module~simulation_class->module~system module~simulation_class->module~field_src_class module~simulation_class->module~input_class module~simulation_class->module~field_e_class module~simulation_class->module~grid_class module~simulation_class->module~field_b_class module~simulation_class->module~field_psi_class module~field_psi_class->module~system module~field_psi_class->module~field_class module~field_psi_class->module~field_src_class module~field_psi_class->module~ufield_class module~field_psi_class->module~grid_class module~field_psi_class->module~field_solver_class program~test_ufield test_ufield program~test_ufield->module~ufield_class var panmodulesystemUsedByGraph = svgPanZoom('#modulesystemUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables class_monitor fid itime dtime Interfaces init_errors end_errors write_err write_wrn write_dbg Subroutines init_errors end_errors write_err write_wrn write_dbg Variables Type Visibility Attributes Name Initial integer, private, save :: class_monitor = 0 integer, private, save :: fid integer, private, dimension(4), save :: itime double precision, private, save :: dtime Interfaces private interface init_errors private interface init_errors () Arguments None private interface end_errors private interface end_errors () Arguments None private interface write_err private interface write_err () Arguments None private interface write_wrn private interface write_wrn () Arguments None private interface write_dbg private interface write_dbg () Arguments None Subroutines public subroutine init_errors (eunit, monitor) Arguments Type Intent Optional Attributes Name integer, intent(in) :: eunit integer, intent(in) :: monitor public subroutine end_errors () Arguments None public subroutine write_err (estr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: estr public subroutine write_wrn (wstr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: wstr public subroutine write_dbg (clsname, sname, level, msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: clsname character(len=*), intent(in) :: sname integer, intent(in) :: level character(len=*), intent(in), optional :: msg","tags":"","loc":"module/system.html"},{"title":"debug_tool – QuickPIC wit Azimuzal Decomposition","text":"Used by module~~debug_tool~~UsedByGraph module~debug_tool debug_tool program~test_field_eperp test_field_eperp program~test_field_eperp->module~debug_tool module~field_b_class field_b_class program~test_field_eperp->module~field_b_class module~field_e_class field_e_class program~test_field_eperp->module~field_e_class module~field_psi_class field_psi_class program~test_field_eperp->module~field_psi_class program~test_field_bz test_field_bz program~test_field_bz->module~debug_tool program~test_field_bz->module~field_b_class program~test_field_psi test_field_psi program~test_field_psi->module~debug_tool program~test_field_psi->module~field_psi_class program~test_field_bperp test_field_bperp program~test_field_bperp->module~debug_tool program~test_field_bperp->module~field_b_class program~test_field_ez test_field_ez program~test_field_ez->module~debug_tool program~test_field_ez->module~field_e_class program~test_field_eperp~2 test_field_eperp program~test_field_eperp~2->module~debug_tool program~test_field_eperp~2->module~field_b_class program~test_field_eperp~2->module~field_e_class module~field_solver_class field_solver_class module~field_solver_class->module~debug_tool program~test_field_bperp_iter test_field_bperp_iter program~test_field_bperp_iter->module~debug_tool program~test_field_bperp_iter->module~field_b_class module~field_b_class->module~debug_tool module~field_b_class->module~field_solver_class module~field_e_class->module~field_solver_class module~field_e_class->module~field_b_class module~field_e_class->module~field_psi_class module~field_psi_class->module~field_solver_class module~simulation_class simulation_class module~simulation_class->module~field_b_class module~simulation_class->module~field_e_class module~simulation_class->module~field_psi_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces write_data Subroutines write_array write_data1d write_data2d Interfaces public interface write_data public subroutine write_data1d (f, fname, dim) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:), pointer :: f character(len=*), intent(in) :: fname integer, intent(in) :: dim public subroutine write_data2d (f, fname, dim) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:,:), pointer :: f character(len=*), intent(in) :: fname integer, intent(in) :: dim public subroutine write_array (f, fname) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:), pointer :: f character(len=*), intent(in) :: fname Subroutines public subroutine write_array (f, fname) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:), pointer :: f character(len=*), intent(in) :: fname public subroutine write_data1d (f, fname, dim) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:), pointer :: f character(len=*), intent(in) :: fname integer, intent(in) :: dim public subroutine write_data2d (f, fname, dim) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:,:), pointer :: f character(len=*), intent(in) :: fname integer, intent(in) :: dim","tags":"","loc":"module/debug_tool.html"},{"title":"parallel_class – QuickPIC wit Azimuzal Decomposition","text":"Uses mpi omp_lib module~~parallel_class~~UsesGraph module~parallel_class parallel_class mpi mpi module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~parallel_class~~UsedByGraph module~parallel_class parallel_class module~parallel_pipe_class parallel_pipe_class module~parallel_pipe_class->module~parallel_class module~simulation_class simulation_class module~simulation_class->module~parallel_class module~simulation_class->module~parallel_pipe_class module~input_class input_class module~simulation_class->module~input_class module~field_src_class field_src_class module~simulation_class->module~field_src_class module~field_e_class field_e_class module~simulation_class->module~field_e_class module~grid_class grid_class module~simulation_class->module~grid_class module~field_b_class field_b_class module~simulation_class->module~field_b_class module~field_psi_class field_psi_class module~simulation_class->module~field_psi_class module~input_class->module~parallel_class module~input_class->module~parallel_pipe_class module~input_class->module~grid_class module~field_class field_class module~field_class->module~parallel_pipe_class module~ufield_class ufield_class module~field_class->module~ufield_class module~field_class->module~grid_class module~field_src_class->module~parallel_pipe_class module~field_src_class->module~field_class module~field_src_class->module~grid_class module~ufield_class->module~parallel_pipe_class module~ufield_class->module~grid_class module~field_e_class->module~parallel_pipe_class module~field_e_class->module~field_class module~field_e_class->module~field_src_class module~field_e_class->module~ufield_class module~field_e_class->module~grid_class module~field_e_class->module~field_b_class module~field_e_class->module~field_psi_class module~grid_class->module~parallel_pipe_class module~field_b_class->module~parallel_pipe_class module~field_b_class->module~field_class module~field_b_class->module~field_src_class module~field_b_class->module~ufield_class module~field_b_class->module~grid_class module~field_psi_class->module~parallel_pipe_class module~field_psi_class->module~field_class module~field_psi_class->module~field_src_class module~field_psi_class->module~ufield_class module~field_psi_class->module~grid_class program~test_field_eperp test_field_eperp program~test_field_eperp->module~field_class program~test_field_eperp->module~field_src_class program~test_field_eperp->module~ufield_class program~test_field_eperp->module~field_e_class program~test_field_eperp->module~field_b_class program~test_field_eperp->module~field_psi_class program~test_field_bz test_field_bz program~test_field_bz->module~field_class program~test_field_bz->module~field_src_class program~test_field_bz->module~ufield_class program~test_field_bz->module~field_b_class program~test_field_psi test_field_psi program~test_field_psi->module~field_class program~test_field_psi->module~field_src_class program~test_field_psi->module~ufield_class program~test_field_psi->module~field_psi_class program~test_field_bperp test_field_bperp program~test_field_bperp->module~field_class program~test_field_bperp->module~field_src_class program~test_field_bperp->module~ufield_class program~test_field_bperp->module~field_b_class program~test_ufield test_ufield program~test_ufield->module~ufield_class program~test_field_ez test_field_ez program~test_field_ez->module~field_class program~test_field_ez->module~field_src_class program~test_field_ez->module~ufield_class program~test_field_ez->module~field_e_class program~test_field_eperp~2 test_field_eperp program~test_field_eperp~2->module~field_class program~test_field_eperp~2->module~field_src_class program~test_field_eperp~2->module~ufield_class program~test_field_eperp~2->module~field_e_class program~test_field_eperp~2->module~field_b_class program~test_field_bperp_iter test_field_bperp_iter program~test_field_bperp_iter->module~field_class program~test_field_bperp_iter->module~field_src_class program~test_field_bperp_iter->module~ufield_class program~test_field_bperp_iter->module~field_b_class var panmoduleparallel_classUsedByGraph = svgPanZoom('#moduleparallel_classUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types parallel Functions getnvp getidproc getkstrt getlworld getmint getmreal getmdouble getmcplx getmchar Subroutines init_parallel ppinit2 init_omp end_parallel Derived Types type, public :: parallel Components Type Visibility Attributes Name Initial integer, private :: nvp integer, private :: idproc integer, private :: kstrt integer, private :: mreal integer, private :: mint integer, private :: mcplx integer, private :: mdouble integer, private :: mchar integer, private :: lworld Type-Bound Procedures generic, public :: new => init_parallel generic, public :: del => end_parallel procedure, public :: getnvp procedure, public :: getidproc procedure, public :: getkstrt procedure, public :: getlworld procedure, public :: getmreal procedure, public :: getmint procedure, public :: getmdouble procedure, public :: getmcplx procedure, public :: getmchar procedure, private :: init_parallel procedure, private :: end_parallel Functions private function getnvp (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer private function getidproc (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer private function getkstrt (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer private function getlworld (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer private function getmint (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer private function getmreal (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer private function getmdouble (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer private function getmcplx (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer private function getmchar (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer Subroutines private subroutine init_parallel (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(inout) :: this private subroutine ppinit2 (idproc, nvp, lworld, mint, mreal, mdouble, mcplx, mchar) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: idproc integer, intent(inout) :: nvp integer, intent(inout) :: lworld integer, intent(inout) :: mint integer, intent(inout) :: mreal integer, intent(inout) :: mdouble integer, intent(inout) :: mcplx integer, intent(inout) :: mchar private subroutine init_omp (nth) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nth private subroutine end_parallel (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(inout) :: this","tags":"","loc":"module/parallel_class.html"},{"title":"field_src_class – QuickPIC wit Azimuzal Decomposition","text":"Uses field_class parallel_pipe_class grid_class param system module~~field_src_class~~UsesGraph module~field_src_class field_src_class module~field_class field_class module~field_src_class->module~field_class module~param param module~field_src_class->module~param module~grid_class grid_class module~field_src_class->module~grid_class module~parallel_pipe_class parallel_pipe_class module~field_src_class->module~parallel_pipe_class module~system system module~field_src_class->module~system module~field_class->module~param module~field_class->module~grid_class module~field_class->module~parallel_pipe_class module~field_class->module~system module~ufield_class ufield_class module~field_class->module~ufield_class module~grid_class->module~parallel_pipe_class module~grid_class->module~system module~parallel_class parallel_class module~parallel_pipe_class->module~parallel_class mpi mpi module~parallel_pipe_class->mpi module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib module~ufield_class->module~param module~ufield_class->module~grid_class module~ufield_class->module~parallel_pipe_class module~ufield_class->module~system var panmodulefield_src_classUsesGraph = svgPanZoom('#modulefield_src_classUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~field_src_class~~UsedByGraph module~field_src_class field_src_class program~test_field_eperp test_field_eperp program~test_field_eperp->module~field_src_class module~field_e_class field_e_class program~test_field_eperp->module~field_e_class module~field_b_class field_b_class program~test_field_eperp->module~field_b_class module~field_psi_class field_psi_class program~test_field_eperp->module~field_psi_class program~test_field_bz test_field_bz program~test_field_bz->module~field_src_class program~test_field_bz->module~field_b_class program~test_field_psi test_field_psi program~test_field_psi->module~field_src_class program~test_field_psi->module~field_psi_class program~test_field_bperp test_field_bperp program~test_field_bperp->module~field_src_class program~test_field_bperp->module~field_b_class module~field_e_class->module~field_src_class module~field_e_class->module~field_b_class module~field_e_class->module~field_psi_class program~test_field_ez test_field_ez program~test_field_ez->module~field_src_class program~test_field_ez->module~field_e_class program~test_field_eperp~2 test_field_eperp program~test_field_eperp~2->module~field_src_class program~test_field_eperp~2->module~field_e_class program~test_field_eperp~2->module~field_b_class program~test_field_bperp_iter test_field_bperp_iter program~test_field_bperp_iter->module~field_src_class program~test_field_bperp_iter->module~field_b_class module~field_b_class->module~field_src_class module~simulation_class simulation_class module~simulation_class->module~field_src_class module~simulation_class->module~field_e_class module~simulation_class->module~field_b_class module~simulation_class->module~field_psi_class module~field_psi_class->module~field_src_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables cls_name cls_level Derived Types field_rho field_jay field_djdxi Subroutines init_field_rho init_field_jay init_field_djdxi Variables Type Visibility Attributes Name Initial character(len=20), private, parameter :: cls_name = \"field_src\" integer, private, parameter :: cls_level = 1 Derived Types type, public, extends( field ) :: field_rho Components Type Visibility Attributes Name Initial class( ufield ), public, dimension(:), pointer :: rf_re => null() class( ufield ), public, dimension(:), pointer :: rf_im => null() real, public :: dr real, public :: dxi integer, public :: num_modes integer, public :: entity Type-Bound Procedures procedure, public :: del => end_field generic, public :: get_rf_re => get_rf_re_all, get_rf_re_mode generic, public :: get_rf_im => get_rf_im_all, get_rf_im_mode procedure, public :: get_num_modes procedure, public :: get_dxi procedure, public :: get_dr generic, public :: new => init_field, init_field_rho procedure, private :: init_field_rho type, public, extends( field ) :: field_jay Components Type Visibility Attributes Name Initial class( ufield ), public, dimension(:), pointer :: rf_re => null() class( ufield ), public, dimension(:), pointer :: rf_im => null() real, public :: dr real, public :: dxi integer, public :: num_modes integer, public :: entity Type-Bound Procedures procedure, public :: del => end_field generic, public :: get_rf_re => get_rf_re_all, get_rf_re_mode generic, public :: get_rf_im => get_rf_im_all, get_rf_im_mode procedure, public :: get_num_modes procedure, public :: get_dxi procedure, public :: get_dr generic, public :: new => init_field, init_field_jay procedure, private :: init_field_jay type, public, extends( field ) :: field_djdxi Components Type Visibility Attributes Name Initial class( ufield ), public, dimension(:), pointer :: rf_re => null() class( ufield ), public, dimension(:), pointer :: rf_im => null() real, public :: dr real, public :: dxi integer, public :: num_modes integer, public :: entity Type-Bound Procedures procedure, public :: del => end_field generic, public :: get_rf_re => get_rf_re_all, get_rf_re_mode generic, public :: get_rf_im => get_rf_im_all, get_rf_im_mode procedure, public :: get_num_modes procedure, public :: get_dxi procedure, public :: get_dr generic, public :: new => init_field, init_field_djdxi procedure, private :: init_field_djdxi Subroutines private subroutine init_field_rho (this, pp, gp, dr, dxi, num_modes, part_shape) Arguments Type Intent Optional Attributes Name class( field_rho ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape private subroutine init_field_jay (this, pp, gp, dr, dxi, num_modes, part_shape) Arguments Type Intent Optional Attributes Name class( field_jay ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape private subroutine init_field_djdxi (this, pp, gp, dr, dxi, num_modes, part_shape) Arguments Type Intent Optional Attributes Name class( field_djdxi ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp real, intent(in) :: dr real, intent(in) :: dxi integer, intent(in) :: num_modes integer, intent(in) :: part_shape","tags":"","loc":"module/field_src_class.html"},{"title":"field_solver_class – QuickPIC wit Azimuzal Decomposition","text":"Uses mpi param system debug_tool module~~field_solver_class~~UsesGraph module~field_solver_class field_solver_class module~param param module~field_solver_class->module~param mpi mpi module~field_solver_class->mpi module~system system module~field_solver_class->module~system module~debug_tool debug_tool module~field_solver_class->module~debug_tool Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~field_solver_class~~UsedByGraph module~field_solver_class field_solver_class module~field_b_class field_b_class module~field_b_class->module~field_solver_class module~field_e_class field_e_class module~field_e_class->module~field_solver_class module~field_e_class->module~field_b_class module~field_psi_class field_psi_class module~field_e_class->module~field_psi_class module~field_psi_class->module~field_solver_class program~test_field_eperp test_field_eperp program~test_field_eperp->module~field_b_class program~test_field_eperp->module~field_e_class program~test_field_eperp->module~field_psi_class program~test_field_bz test_field_bz program~test_field_bz->module~field_b_class program~test_field_bperp test_field_bperp program~test_field_bperp->module~field_b_class program~test_field_psi test_field_psi program~test_field_psi->module~field_psi_class program~test_field_ez test_field_ez program~test_field_ez->module~field_e_class program~test_field_eperp~2 test_field_eperp program~test_field_eperp~2->module~field_b_class program~test_field_eperp~2->module~field_e_class program~test_field_bperp_iter test_field_bperp_iter program~test_field_bperp_iter->module~field_b_class module~simulation_class simulation_class module~simulation_class->module~field_b_class module~simulation_class->module~field_e_class module~simulation_class->module~field_psi_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables cls_name cls_level itime dtime HYPRE_BUF Derived Types field_solver Subroutines init_field_solver end_field_solver set_struct_solver solve_equation set_struct_grid set_struct_stencil set_struct_matrix set_ij_solver set_ij_matrix Variables Type Visibility Attributes Name Initial character(len=20), private, parameter :: cls_name = \"field_solver\" integer, private, parameter :: cls_level = 2 integer, private, dimension(4), save :: itime double precision, private, save :: dtime real, public, dimension(:), pointer :: HYPRE_BUF => null() Derived Types type, public :: field_solver Components Type Visibility Attributes Name Initial integer, public, dimension(:), pointer :: offsets => null() integer, public, dimension(:), pointer :: stencil_idx => null() integer, public :: num_stencil integer, public :: solver_type integer, public :: kind integer, public :: mode real, public :: tol integer(kind=HYPRE_TYPE), public :: A integer(kind=HYPRE_TYPE), public :: b integer(kind=HYPRE_TYPE), public :: x integer(kind=HYPRE_TYPE), public :: grid integer(kind=HYPRE_TYPE), public :: stencil integer(kind=HYPRE_TYPE), public :: solver integer(kind=HYPRE_TYPE), public :: precond integer(kind=HYPRE_TYPE), public :: par_A integer(kind=HYPRE_TYPE), public :: par_b integer(kind=HYPRE_TYPE), public :: par_x integer, public :: iupper integer, public :: ilower Type-Bound Procedures generic, public :: new => init_field_solver generic, public :: solve => solve_equation generic, public :: del => end_field_solver procedure, private :: end_field_solver procedure, private :: init_field_solver procedure, private :: set_struct_solver procedure, private :: solve_equation procedure, private :: set_struct_grid procedure, private :: set_struct_stencil procedure, private :: set_struct_matrix procedure, private :: set_ij_matrix procedure, private :: set_ij_solver Subroutines private subroutine init_field_solver (this, nd, ndp, noff, kind, mode, dr, solver_type, tol) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this integer, intent(in), dimension(2) :: nd integer, intent(in), dimension(2) :: ndp integer, intent(in), dimension(2) :: noff integer, intent(in) :: kind integer, intent(in) :: mode real, intent(in) :: dr integer, intent(in) :: solver_type real, intent(in) :: tol private subroutine end_field_solver (this) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this private subroutine set_struct_solver (this, comm) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this integer, intent(in) :: comm private subroutine solve_equation (this, src_sol) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this real, intent(inout), dimension(:), pointer :: src_sol private subroutine set_struct_grid (this, comm, ndp, noff) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this integer, intent(in) :: comm integer, intent(in), dimension(2) :: ndp integer, intent(in), dimension(2) :: noff private subroutine set_struct_stencil (this) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this private subroutine set_struct_matrix (this, comm, nd, dr) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this integer, intent(in) :: comm integer, intent(in), dimension(:) :: nd real, intent(in) :: dr private subroutine set_ij_solver (this, comm) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this integer, intent(in) :: comm private subroutine set_ij_matrix (this, comm, nd, ndp, noff, dr) Arguments Type Intent Optional Attributes Name class( field_solver ), intent(inout) :: this integer, intent(in) :: comm integer, intent(in), dimension(:) :: nd integer, intent(in), dimension(:) :: ndp integer, intent(in), dimension(:) :: noff real, intent(in) :: dr","tags":"","loc":"module/field_solver_class.html"},{"title":"parallel_pipe_class – QuickPIC wit Azimuzal Decomposition","text":"Uses mpi parallel_class module~~parallel_pipe_class~~UsesGraph module~parallel_pipe_class parallel_pipe_class module~parallel_class parallel_class module~parallel_pipe_class->module~parallel_class mpi mpi module~parallel_pipe_class->mpi module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~parallel_pipe_class~~UsedByGraph module~parallel_pipe_class parallel_pipe_class module~field_class field_class module~field_class->module~parallel_pipe_class module~ufield_class ufield_class module~field_class->module~ufield_class module~grid_class grid_class module~field_class->module~grid_class module~field_src_class field_src_class module~field_src_class->module~parallel_pipe_class module~field_src_class->module~field_class module~field_src_class->module~grid_class module~input_class input_class module~input_class->module~parallel_pipe_class module~input_class->module~grid_class module~ufield_class->module~parallel_pipe_class module~ufield_class->module~grid_class module~field_e_class field_e_class module~field_e_class->module~parallel_pipe_class module~field_e_class->module~field_class module~field_e_class->module~field_src_class module~field_e_class->module~ufield_class module~field_e_class->module~grid_class module~field_b_class field_b_class module~field_e_class->module~field_b_class module~field_psi_class field_psi_class module~field_e_class->module~field_psi_class module~grid_class->module~parallel_pipe_class module~field_b_class->module~parallel_pipe_class module~field_b_class->module~field_class module~field_b_class->module~field_src_class module~field_b_class->module~ufield_class module~field_b_class->module~grid_class module~simulation_class simulation_class module~simulation_class->module~parallel_pipe_class module~simulation_class->module~field_src_class module~simulation_class->module~input_class module~simulation_class->module~field_e_class module~simulation_class->module~grid_class module~simulation_class->module~field_b_class module~simulation_class->module~field_psi_class module~field_psi_class->module~parallel_pipe_class module~field_psi_class->module~field_class module~field_psi_class->module~field_src_class module~field_psi_class->module~ufield_class module~field_psi_class->module~grid_class program~test_field_eperp test_field_eperp program~test_field_eperp->module~field_class program~test_field_eperp->module~field_src_class program~test_field_eperp->module~ufield_class program~test_field_eperp->module~field_e_class program~test_field_eperp->module~field_b_class program~test_field_eperp->module~field_psi_class program~test_field_bz test_field_bz program~test_field_bz->module~field_class program~test_field_bz->module~field_src_class program~test_field_bz->module~ufield_class program~test_field_bz->module~field_b_class program~test_field_psi test_field_psi program~test_field_psi->module~field_class program~test_field_psi->module~field_src_class program~test_field_psi->module~ufield_class program~test_field_psi->module~field_psi_class program~test_field_bperp test_field_bperp program~test_field_bperp->module~field_class program~test_field_bperp->module~field_src_class program~test_field_bperp->module~ufield_class program~test_field_bperp->module~field_b_class program~test_ufield test_ufield program~test_ufield->module~ufield_class program~test_field_ez test_field_ez program~test_field_ez->module~field_class program~test_field_ez->module~field_src_class program~test_field_ez->module~ufield_class program~test_field_ez->module~field_e_class program~test_field_eperp~2 test_field_eperp program~test_field_eperp~2->module~field_class program~test_field_eperp~2->module~field_src_class program~test_field_eperp~2->module~ufield_class program~test_field_eperp~2->module~field_e_class program~test_field_eperp~2->module~field_b_class program~test_field_bperp_iter test_field_bperp_iter program~test_field_bperp_iter->module~field_class program~test_field_bperp_iter->module~field_src_class program~test_field_bperp_iter->module~ufield_class program~test_field_bperp_iter->module~field_b_class var panmoduleparallel_pipe_classUsedByGraph = svgPanZoom('#moduleparallel_pipe_classUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types parallel_pipe Functions getlidproc getlkstrt getlgrp getlnvp getnstage getstageid Subroutines init_parallel_pipe Derived Types type, public, extends( parallel ) :: parallel_pipe Components Type Visibility Attributes Name Initial integer, private :: nstage = 1 integer, private :: stageid = 0 integer, private :: lidproc integer, private :: lkstrt integer, private :: lgrp integer, private :: lnvp Type-Bound Procedures generic, public :: del => end_parallel procedure, public :: getnvp procedure, public :: getidproc procedure, public :: getkstrt procedure, public :: getlworld procedure, public :: getmreal procedure, public :: getmint procedure, public :: getmdouble procedure, public :: getmcplx procedure, public :: getmchar procedure, public :: getnstage procedure, public :: getstageid procedure, public :: getlidproc procedure, public :: getlkstrt procedure, public :: getlgrp procedure, public :: getlnvp procedure, private :: init_parallel_pipe generic, public :: new => init_parallel, init_parallel_pipe Functions private function getlidproc (this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer private function getlkstrt (this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer private function getlgrp (this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer private function getlnvp (this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer private function getnstage (this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer private function getstageid (this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer Subroutines private subroutine init_parallel_pipe (this, nst) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(inout) :: this integer, intent(in) :: nst","tags":"","loc":"module/parallel_pipe_class.html"},{"title":"ufield_class – QuickPIC wit Azimuzal Decomposition","text":"Uses parallel_pipe_class grid_class param system module~~ufield_class~~UsesGraph module~ufield_class ufield_class module~param param module~ufield_class->module~param module~grid_class grid_class module~ufield_class->module~grid_class module~parallel_pipe_class parallel_pipe_class module~ufield_class->module~parallel_pipe_class module~system system module~ufield_class->module~system module~grid_class->module~parallel_pipe_class module~grid_class->module~system module~parallel_class parallel_class module~parallel_pipe_class->module~parallel_class mpi mpi module~parallel_pipe_class->mpi module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~ufield_class~~UsedByGraph module~ufield_class ufield_class program~test_field_eperp test_field_eperp program~test_field_eperp->module~ufield_class module~field_class field_class program~test_field_eperp->module~field_class module~field_e_class field_e_class program~test_field_eperp->module~field_e_class module~field_b_class field_b_class program~test_field_eperp->module~field_b_class module~field_psi_class field_psi_class program~test_field_eperp->module~field_psi_class module~field_src_class field_src_class program~test_field_eperp->module~field_src_class module~field_class->module~ufield_class program~test_field_bz test_field_bz program~test_field_bz->module~ufield_class program~test_field_bz->module~field_class program~test_field_bz->module~field_b_class program~test_field_bz->module~field_src_class program~test_field_psi test_field_psi program~test_field_psi->module~ufield_class program~test_field_psi->module~field_class program~test_field_psi->module~field_psi_class program~test_field_psi->module~field_src_class program~test_field_bperp test_field_bperp program~test_field_bperp->module~ufield_class program~test_field_bperp->module~field_class program~test_field_bperp->module~field_b_class program~test_field_bperp->module~field_src_class module~field_e_class->module~ufield_class module~field_e_class->module~field_class module~field_e_class->module~field_b_class module~field_e_class->module~field_psi_class module~field_e_class->module~field_src_class program~test_ufield test_ufield program~test_ufield->module~ufield_class program~test_field_ez test_field_ez program~test_field_ez->module~ufield_class program~test_field_ez->module~field_class program~test_field_ez->module~field_e_class program~test_field_ez->module~field_src_class program~test_field_eperp~2 test_field_eperp program~test_field_eperp~2->module~ufield_class program~test_field_eperp~2->module~field_class program~test_field_eperp~2->module~field_e_class program~test_field_eperp~2->module~field_b_class program~test_field_eperp~2->module~field_src_class program~test_field_bperp_iter test_field_bperp_iter program~test_field_bperp_iter->module~ufield_class program~test_field_bperp_iter->module~field_class program~test_field_bperp_iter->module~field_b_class program~test_field_bperp_iter->module~field_src_class module~field_b_class->module~ufield_class module~field_b_class->module~field_class module~field_b_class->module~field_src_class module~field_psi_class->module~ufield_class module~field_psi_class->module~field_class module~field_psi_class->module~field_src_class module~simulation_class simulation_class module~simulation_class->module~field_e_class module~simulation_class->module~field_b_class module~simulation_class->module~field_psi_class module~simulation_class->module~field_src_class module~field_src_class->module~field_class var panmoduleufield_classUsedByGraph = svgPanZoom('#moduleufield_classUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables cls_name cls_level Derived Types ufield Functions add_array add_scalar1 add_scalar2 sub_array sub_scalar1 sub_scalar2 dot_array dot_scalar1 dot_scalar2 get_dim get_nd_all get_nd_dim get_ndp_all get_ndp_dim get_gc_num_all get_gc_num_dim get_nvp_all get_nvp_dim get_noff_all get_noff_dim get_f1 get_f2 Subroutines init_ufield init_ufield_cp end_ufield copy_slice assign_array Variables Type Visibility Attributes Name Initial character(len=20), private, parameter :: cls_name = \"ufield\" integer, private, parameter :: cls_level = 2 Derived Types type, public :: ufield Components Type Visibility Attributes Name Initial real, public, dimension(:,:), pointer :: f1 => null() real, private, dimension(:,:,:), pointer :: f2 => null() integer, private, dimension(2) :: nd integer, private, dimension(2) :: ndp integer, private, dimension(2) :: nvp integer, private :: dim integer, private, dimension(2) :: noff integer, private, dimension(2,2) :: gc_num logical, private :: has_2d real, private, dimension(:), pointer :: buf => null() Type-Bound Procedures generic, public :: new => init_ufield, init_ufield_cp generic, public :: del => end_ufield generic, public :: get_nd => get_nd_all, get_nd_dim generic, public :: get_ndp => get_ndp_all, get_ndp_dim generic, public :: get_gc_num => get_gc_num_all, get_gc_num_dim generic, public :: get_nvp => get_nvp_all, get_nvp_dim generic, public :: get_noff => get_noff_all, get_noff_dim procedure, public :: get_dim procedure, public :: copy_slice procedure, public :: get_f1 procedure, public :: get_f2 generic, public :: assignment(=) => assign_array generic, public :: operator(+) => add_array, add_scalar1, add_scalar2 generic, public :: operator(-) => sub_array, sub_scalar1, sub_scalar2 generic, public :: operator(*) => dot_array, dot_scalar1, dot_scalar2 procedure, private :: end_ufield procedure, private :: init_ufield_cp procedure, private :: init_ufield procedure, private :: get_nd_dim procedure, private :: get_nd_all procedure, private :: get_ndp_dim procedure, private :: get_ndp_all procedure, private :: get_gc_num_dim procedure, private :: get_gc_num_all procedure, private :: get_nvp_dim procedure, private :: get_nvp_all procedure, private :: get_noff_dim procedure, private :: get_noff_all procedure, private, pass(a1) :: add_scalar2 procedure, private, pass(a1) :: add_scalar1 procedure, private, pass(a1) :: add_array procedure, private, pass(a1) :: dot_scalar2 procedure, private, pass(a1) :: dot_scalar1 procedure, private, pass(a1) :: dot_array procedure, private, pass(a1) :: sub_scalar2 procedure, private, pass(a1) :: sub_scalar1 procedure, private, pass(a1) :: sub_array procedure, private :: assign_array Functions private function add_array (a1, a2) result(a3) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: a1 class( ufield ), intent(in) :: a2 Return Value class( ufield ),\n  allocatable private function add_scalar1 (a1, a2) result(a3) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: a1 real, intent(in) :: a2 Return Value class( ufield ),\n  allocatable private function add_scalar2 (a2, a1) result(a3) Arguments Type Intent Optional Attributes Name real, intent(in) :: a2 class( ufield ), intent(in) :: a1 Return Value class( ufield ),\n  allocatable private function sub_array (a1, a2) result(a3) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: a1 class( ufield ), intent(in) :: a2 Return Value class( ufield ),\n  allocatable private function sub_scalar1 (a1, a2) result(a3) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: a1 real, intent(in) :: a2 Return Value class( ufield ),\n  allocatable private function sub_scalar2 (a2, a1) result(a3) Arguments Type Intent Optional Attributes Name real, intent(in) :: a2 class( ufield ), intent(in) :: a1 Return Value class( ufield ),\n  allocatable private function dot_array (a1, a2) result(a3) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: a1 class( ufield ), intent(in) :: a2 Return Value class( ufield ),\n  allocatable private function dot_scalar1 (a1, a2) result(a3) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: a1 real, intent(in) :: a2 Return Value class( ufield ),\n  allocatable private function dot_scalar2 (a2, a1) result(a3) Arguments Type Intent Optional Attributes Name real, intent(in) :: a2 class( ufield ), intent(in) :: a1 Return Value class( ufield ),\n  allocatable private function get_dim (this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value integer private function get_nd_all (this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value integer,\n  dimension(2) private function get_nd_dim (this, dim) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this integer, intent(in) :: dim Return Value integer private function get_ndp_all (this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value integer,\n  dimension(2) private function get_ndp_dim (this, dim) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this integer, intent(in) :: dim Return Value integer private function get_gc_num_all (this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value integer,\n  dimension(2,2) private function get_gc_num_dim (this, dim) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this integer, intent(in) :: dim Return Value integer,\n  dimension(2) private function get_nvp_all (this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value integer,\n  dimension(2) private function get_nvp_dim (this, dim) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this integer, intent(in) :: dim Return Value integer private function get_noff_all (this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value integer,\n  dimension(2) private function get_noff_dim (this, dim) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this integer, intent(in) :: dim Return Value integer private function get_f1 (this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value real,\n  dimension(:,:), pointer private function get_f2 (this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(in) :: this Return Value real,\n  dimension(:,:,:), pointer Subroutines private subroutine init_ufield (this, pp, gp, dim, gc_num, has_2d) Arguments Type Intent Optional Attributes Name class( ufield ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( grid ), intent(in), pointer :: gp integer, intent(in) :: dim integer, intent(in), dimension(2,2) :: gc_num logical, intent(in), optional :: has_2d private subroutine init_ufield_cp (this, that, has_2d) Arguments Type Intent Optional Attributes Name class( ufield ), intent(inout) :: this class( ufield ), intent(in) :: that logical, intent(in), optional :: has_2d private subroutine end_ufield (this) Arguments Type Intent Optional Attributes Name class( ufield ), intent(inout) :: this private subroutine copy_slice (this, idx, dir) Arguments Type Intent Optional Attributes Name class( ufield ), intent(inout) :: this integer, intent(in) :: idx integer, intent(in) :: dir private subroutine assign_array (this, that) Arguments Type Intent Optional Attributes Name class( ufield ), intent(inout) :: this class(*), intent(in) :: that","tags":"","loc":"module/ufield_class.html"},{"title":"quickpic – QuickPIC wit Azimuzal Decomposition","text":"Contents None","tags":"","loc":"program/quickpic.html"},{"title":"test_field_bz – QuickPIC wit Azimuzal Decomposition","text":"Uses field_b_class field_class field_src_class system param mpi ufield_class debug_tool program~~test_field_bz~~UsesGraph program~test_field_bz test_field_bz module~debug_tool debug_tool program~test_field_bz->module~debug_tool mpi mpi program~test_field_bz->mpi module~field_class field_class program~test_field_bz->module~field_class module~field_src_class field_src_class program~test_field_bz->module~field_src_class module~param param program~test_field_bz->module~param module~ufield_class ufield_class program~test_field_bz->module~ufield_class module~field_b_class field_b_class program~test_field_bz->module~field_b_class module~system system program~test_field_bz->module~system module~field_class->module~param module~field_class->module~ufield_class module~field_class->module~system module~grid_class grid_class module~field_class->module~grid_class module~parallel_pipe_class parallel_pipe_class module~field_class->module~parallel_pipe_class module~field_src_class->module~field_class module~field_src_class->module~param module~field_src_class->module~system module~field_src_class->module~grid_class module~field_src_class->module~parallel_pipe_class module~ufield_class->module~param module~ufield_class->module~system module~ufield_class->module~grid_class module~ufield_class->module~parallel_pipe_class module~field_b_class->module~debug_tool module~field_b_class->module~field_class module~field_b_class->module~field_src_class module~field_b_class->module~param module~field_b_class->module~ufield_class module~field_b_class->module~system module~field_b_class->module~grid_class module~field_b_class->module~parallel_pipe_class module~field_solver_class field_solver_class module~field_b_class->module~field_solver_class module~grid_class->module~system module~grid_class->module~parallel_pipe_class module~parallel_pipe_class->mpi module~parallel_class parallel_class module~parallel_pipe_class->module~parallel_class module~field_solver_class->module~debug_tool module~field_solver_class->mpi module~field_solver_class->module~param module~field_solver_class->module~system module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib var panprogramtest_field_bzUsesGraph = svgPanZoom('#programtest_field_bzUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~test_field_bz~~CallsGraph program~test_field_bz test_field_bz mpi_init mpi_init program~test_field_bz->mpi_init write_dbg write_dbg program~test_field_bz->write_dbg mpi_finalize mpi_finalize program~test_field_bz->mpi_finalize init_errors init_errors program~test_field_bz->init_errors end_errors end_errors program~test_field_bz->end_errors interface~write_data write_data program~test_field_bz->interface~write_data proc~write_data1d write_data1d interface~write_data->proc~write_data1d proc~write_data2d write_data2d interface~write_data->proc~write_data2d proc~write_array write_array interface~write_data->proc~write_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables b jay num_modes dim order part_shape nd nvp gc_num dr dxi r ujay_re ujay_im ub_re ub_im p ierr i mode Variables Type Attributes Name Initial type( field_b ) :: b type( field_jay ) :: jay integer :: num_modes = 2 integer :: dim = 3 integer :: order = p_fs_2order integer :: part_shape = p_ps_linear integer, dimension(2) :: nd = (/128, 1/) integer, dimension(2) :: nvp = (/1, 1/) integer, dimension(2,2) :: gc_num real :: dr real :: dxi real :: r type( ufield ), dimension(:), pointer :: ujay_re => null() type( ufield ), dimension(:), pointer :: ujay_im => null() type( ufield ), dimension(:), pointer :: ub_re => null() type( ufield ), dimension(:), pointer :: ub_im => null() real, dimension(:,:), pointer :: p integer :: ierr integer :: i integer :: mode","tags":"","loc":"program/test_field_bz.html"},{"title":"test_field_ez – QuickPIC wit Azimuzal Decomposition","text":"Uses field_e_class field_class field_src_class system param mpi ufield_class debug_tool program~~test_field_ez~~UsesGraph program~test_field_ez test_field_ez module~debug_tool debug_tool program~test_field_ez->module~debug_tool mpi mpi program~test_field_ez->mpi module~field_class field_class program~test_field_ez->module~field_class module~field_src_class field_src_class program~test_field_ez->module~field_src_class module~param param program~test_field_ez->module~param module~ufield_class ufield_class program~test_field_ez->module~ufield_class module~field_e_class field_e_class program~test_field_ez->module~field_e_class module~system system program~test_field_ez->module~system module~field_class->module~param module~field_class->module~ufield_class module~field_class->module~system module~grid_class grid_class module~field_class->module~grid_class module~parallel_pipe_class parallel_pipe_class module~field_class->module~parallel_pipe_class module~field_src_class->module~field_class module~field_src_class->module~param module~field_src_class->module~system module~field_src_class->module~grid_class module~field_src_class->module~parallel_pipe_class module~ufield_class->module~param module~ufield_class->module~system module~ufield_class->module~grid_class module~ufield_class->module~parallel_pipe_class module~field_e_class->module~field_class module~field_e_class->module~field_src_class module~field_e_class->module~param module~field_e_class->module~ufield_class module~field_e_class->module~system module~field_e_class->module~grid_class module~field_e_class->module~parallel_pipe_class module~field_solver_class field_solver_class module~field_e_class->module~field_solver_class module~field_b_class field_b_class module~field_e_class->module~field_b_class module~field_psi_class field_psi_class module~field_e_class->module~field_psi_class module~grid_class->module~system module~grid_class->module~parallel_pipe_class module~parallel_pipe_class->mpi module~parallel_class parallel_class module~parallel_pipe_class->module~parallel_class module~field_solver_class->module~debug_tool module~field_solver_class->mpi module~field_solver_class->module~param module~field_solver_class->module~system module~field_b_class->module~debug_tool module~field_b_class->module~field_class module~field_b_class->module~field_src_class module~field_b_class->module~param module~field_b_class->module~ufield_class module~field_b_class->module~system module~field_b_class->module~grid_class module~field_b_class->module~parallel_pipe_class module~field_b_class->module~field_solver_class module~field_psi_class->module~field_class module~field_psi_class->module~field_src_class module~field_psi_class->module~param module~field_psi_class->module~ufield_class module~field_psi_class->module~system module~field_psi_class->module~grid_class module~field_psi_class->module~parallel_pipe_class module~field_psi_class->module~field_solver_class module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib var panprogramtest_field_ezUsesGraph = svgPanZoom('#programtest_field_ezUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~test_field_ez~~CallsGraph program~test_field_ez test_field_ez mpi_init mpi_init program~test_field_ez->mpi_init write_dbg write_dbg program~test_field_ez->write_dbg mpi_finalize mpi_finalize program~test_field_ez->mpi_finalize init_errors init_errors program~test_field_ez->init_errors end_errors end_errors program~test_field_ez->end_errors interface~write_data write_data program~test_field_ez->interface~write_data proc~write_data1d write_data1d interface~write_data->proc~write_data1d proc~write_data2d write_data2d interface~write_data->proc~write_data2d proc~write_array write_array interface~write_data->proc~write_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables e jay num_modes dim order part_shape nd nvp gc_num dr dxi r ujay_re ujay_im ue_re ue_im p ierr i mode Variables Type Attributes Name Initial type( field_e ) :: e type( field_jay ) :: jay integer :: num_modes = 2 integer :: dim = 3 integer :: order = p_fs_2order integer :: part_shape = p_ps_linear integer, dimension(2) :: nd = (/128, 1/) integer, dimension(2) :: nvp = (/1, 1/) integer, dimension(2,2) :: gc_num real :: dr real :: dxi real :: r type( ufield ), dimension(:), pointer :: ujay_re => null() type( ufield ), dimension(:), pointer :: ujay_im => null() type( ufield ), dimension(:), pointer :: ue_re => null() type( ufield ), dimension(:), pointer :: ue_im => null() real, dimension(:,:), pointer :: p integer :: ierr integer :: i integer :: mode","tags":"","loc":"program/test_field_ez.html"},{"title":"test_field_eperp – QuickPIC wit Azimuzal Decomposition","text":"Uses field_b_class field_e_class field_psi_class field_class field_src_class system param mpi ufield_class debug_tool program~~test_field_eperp~~UsesGraph program~test_field_eperp test_field_eperp module~debug_tool debug_tool program~test_field_eperp->module~debug_tool mpi mpi program~test_field_eperp->mpi module~field_class field_class program~test_field_eperp->module~field_class module~field_src_class field_src_class program~test_field_eperp->module~field_src_class module~param param program~test_field_eperp->module~param module~ufield_class ufield_class program~test_field_eperp->module~ufield_class module~field_e_class field_e_class program~test_field_eperp->module~field_e_class module~field_b_class field_b_class program~test_field_eperp->module~field_b_class module~system system program~test_field_eperp->module~system module~field_psi_class field_psi_class program~test_field_eperp->module~field_psi_class module~field_class->module~param module~field_class->module~ufield_class module~field_class->module~system module~grid_class grid_class module~field_class->module~grid_class module~parallel_pipe_class parallel_pipe_class module~field_class->module~parallel_pipe_class module~field_src_class->module~field_class module~field_src_class->module~param module~field_src_class->module~system module~field_src_class->module~grid_class module~field_src_class->module~parallel_pipe_class module~ufield_class->module~param module~ufield_class->module~system module~ufield_class->module~grid_class module~ufield_class->module~parallel_pipe_class module~field_e_class->module~field_class module~field_e_class->module~field_src_class module~field_e_class->module~param module~field_e_class->module~ufield_class module~field_e_class->module~field_b_class module~field_e_class->module~system module~field_e_class->module~field_psi_class module~field_e_class->module~grid_class module~field_e_class->module~parallel_pipe_class module~field_solver_class field_solver_class module~field_e_class->module~field_solver_class module~field_b_class->module~debug_tool module~field_b_class->module~field_class module~field_b_class->module~field_src_class module~field_b_class->module~param module~field_b_class->module~ufield_class module~field_b_class->module~system module~field_b_class->module~grid_class module~field_b_class->module~parallel_pipe_class module~field_b_class->module~field_solver_class module~field_psi_class->module~field_class module~field_psi_class->module~field_src_class module~field_psi_class->module~param module~field_psi_class->module~ufield_class module~field_psi_class->module~system module~field_psi_class->module~grid_class module~field_psi_class->module~parallel_pipe_class module~field_psi_class->module~field_solver_class module~grid_class->module~system module~grid_class->module~parallel_pipe_class module~parallel_pipe_class->mpi module~parallel_class parallel_class module~parallel_pipe_class->module~parallel_class module~field_solver_class->module~debug_tool module~field_solver_class->mpi module~field_solver_class->module~param module~field_solver_class->module~system module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib var panprogramtest_field_eperpUsesGraph = svgPanZoom('#programtest_field_eperpUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~test_field_eperp~~CallsGraph program~test_field_eperp test_field_eperp mpi_init mpi_init program~test_field_eperp->mpi_init write_dbg write_dbg program~test_field_eperp->write_dbg mpi_finalize mpi_finalize program~test_field_eperp->mpi_finalize init_errors init_errors program~test_field_eperp->init_errors end_errors end_errors program~test_field_eperp->end_errors interface~write_data write_data program~test_field_eperp->interface~write_data proc~write_data1d write_data1d interface~write_data->proc~write_data1d proc~write_data2d write_data2d interface~write_data->proc~write_data2d proc~write_array write_array interface~write_data->proc~write_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables b e psi rho jay djdxi num_modes dim order part_shape nd nvp gc_num dr dxi r uq_re uq_im ue_re ue_im ujay_re ujay_im udjdxi_re udjdxi_im ub_re ub_im upsi_re upsi_im p ierr i mode Variables Type Attributes Name Initial type( field_b ) :: b type( field_e ) :: e type( field_psi ) :: psi type( field_rho ) :: rho type( field_jay ) :: jay type( field_djdxi ) :: djdxi integer :: num_modes = 3 integer :: dim = 3 integer :: order = p_fs_2order integer :: part_shape = p_ps_linear integer, dimension(2) :: nd = (/128, 1/) integer, dimension(2) :: nvp = (/1, 1/) integer, dimension(2,2) :: gc_num real :: dr real :: dxi real :: r type( ufield ), dimension(:), pointer :: uq_re => null() type( ufield ), dimension(:), pointer :: uq_im => null() type( ufield ), dimension(:), pointer :: ue_re => null() type( ufield ), dimension(:), pointer :: ue_im => null() type( ufield ), dimension(:), pointer :: ujay_re => null() type( ufield ), dimension(:), pointer :: ujay_im => null() type( ufield ), dimension(:), pointer :: udjdxi_re => null() type( ufield ), dimension(:), pointer :: udjdxi_im => null() type( ufield ), dimension(:), pointer :: ub_re => null() type( ufield ), dimension(:), pointer :: ub_im => null() type( ufield ), dimension(:), pointer :: upsi_re => null() type( ufield ), dimension(:), pointer :: upsi_im => null() real, dimension(:,:), pointer :: p integer :: ierr integer :: i integer :: mode","tags":"","loc":"program/test_field_eperp.html"},{"title":"test_field_psi – QuickPIC wit Azimuzal Decomposition","text":"Uses field_psi_class field_class field_src_class system param mpi ufield_class debug_tool program~~test_field_psi~~UsesGraph program~test_field_psi test_field_psi module~debug_tool debug_tool program~test_field_psi->module~debug_tool mpi mpi program~test_field_psi->mpi module~field_class field_class program~test_field_psi->module~field_class module~field_src_class field_src_class program~test_field_psi->module~field_src_class module~param param program~test_field_psi->module~param module~ufield_class ufield_class program~test_field_psi->module~ufield_class module~system system program~test_field_psi->module~system module~field_psi_class field_psi_class program~test_field_psi->module~field_psi_class module~field_class->module~param module~field_class->module~ufield_class module~field_class->module~system module~grid_class grid_class module~field_class->module~grid_class module~parallel_pipe_class parallel_pipe_class module~field_class->module~parallel_pipe_class module~field_src_class->module~field_class module~field_src_class->module~param module~field_src_class->module~system module~field_src_class->module~grid_class module~field_src_class->module~parallel_pipe_class module~ufield_class->module~param module~ufield_class->module~system module~ufield_class->module~grid_class module~ufield_class->module~parallel_pipe_class module~field_psi_class->module~field_class module~field_psi_class->module~field_src_class module~field_psi_class->module~param module~field_psi_class->module~ufield_class module~field_psi_class->module~system module~field_psi_class->module~grid_class module~field_psi_class->module~parallel_pipe_class module~field_solver_class field_solver_class module~field_psi_class->module~field_solver_class module~grid_class->module~system module~grid_class->module~parallel_pipe_class module~parallel_pipe_class->mpi module~parallel_class parallel_class module~parallel_pipe_class->module~parallel_class module~field_solver_class->module~debug_tool module~field_solver_class->mpi module~field_solver_class->module~param module~field_solver_class->module~system module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib var panprogramtest_field_psiUsesGraph = svgPanZoom('#programtest_field_psiUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~test_field_psi~~CallsGraph program~test_field_psi test_field_psi mpi_init mpi_init program~test_field_psi->mpi_init write_dbg write_dbg program~test_field_psi->write_dbg mpi_finalize mpi_finalize program~test_field_psi->mpi_finalize init_errors init_errors program~test_field_psi->init_errors end_errors end_errors program~test_field_psi->end_errors interface~write_data write_data program~test_field_psi->interface~write_data proc~write_data1d write_data1d interface~write_data->proc~write_data1d proc~write_data2d write_data2d interface~write_data->proc~write_data2d proc~write_array write_array interface~write_data->proc~write_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables psi q num_modes dim order part_shape nd nvp gc_num dr dxi r uq_re uq_im upsi_re upsi_im p ierr i mode values Variables Type Attributes Name Initial type( field_psi ) :: psi type( field_rho ) :: q integer :: num_modes = 2 integer :: dim = 1 integer :: order = p_fs_2order integer :: part_shape = p_ps_linear integer, dimension(2) :: nd = (/128, 1/) integer, dimension(2) :: nvp = (/1, 1/) integer, dimension(2,2) :: gc_num real :: dr real :: dxi real :: r type( ufield ), dimension(:), pointer :: uq_re => null() type( ufield ), dimension(:), pointer :: uq_im => null() type( ufield ), dimension(:), pointer :: upsi_re => null() type( ufield ), dimension(:), pointer :: upsi_im => null() real, dimension(:,:), pointer :: p integer :: ierr integer :: i integer :: mode real, dimension(1024) :: values = 0.0","tags":"","loc":"program/test_field_psi.html"},{"title":"test_field_eperp – QuickPIC wit Azimuzal Decomposition","text":"Uses field_b_class field_e_class field_class field_src_class system param mpi ufield_class debug_tool program~~test_field_eperp~2~~UsesGraph program~test_field_eperp~2 test_field_eperp module~debug_tool debug_tool program~test_field_eperp~2->module~debug_tool mpi mpi program~test_field_eperp~2->mpi module~field_class field_class program~test_field_eperp~2->module~field_class module~field_src_class field_src_class program~test_field_eperp~2->module~field_src_class module~param param program~test_field_eperp~2->module~param module~ufield_class ufield_class program~test_field_eperp~2->module~ufield_class module~field_e_class field_e_class program~test_field_eperp~2->module~field_e_class module~field_b_class field_b_class program~test_field_eperp~2->module~field_b_class module~system system program~test_field_eperp~2->module~system module~field_class->module~param module~field_class->module~ufield_class module~field_class->module~system module~grid_class grid_class module~field_class->module~grid_class module~parallel_pipe_class parallel_pipe_class module~field_class->module~parallel_pipe_class module~field_src_class->module~field_class module~field_src_class->module~param module~field_src_class->module~system module~field_src_class->module~grid_class module~field_src_class->module~parallel_pipe_class module~ufield_class->module~param module~ufield_class->module~system module~ufield_class->module~grid_class module~ufield_class->module~parallel_pipe_class module~field_e_class->module~field_class module~field_e_class->module~field_src_class module~field_e_class->module~param module~field_e_class->module~ufield_class module~field_e_class->module~field_b_class module~field_e_class->module~system module~field_e_class->module~grid_class module~field_e_class->module~parallel_pipe_class module~field_psi_class field_psi_class module~field_e_class->module~field_psi_class module~field_solver_class field_solver_class module~field_e_class->module~field_solver_class module~field_b_class->module~debug_tool module~field_b_class->module~field_class module~field_b_class->module~field_src_class module~field_b_class->module~param module~field_b_class->module~ufield_class module~field_b_class->module~system module~field_b_class->module~grid_class module~field_b_class->module~parallel_pipe_class module~field_b_class->module~field_solver_class module~grid_class->module~system module~grid_class->module~parallel_pipe_class module~parallel_pipe_class->mpi module~parallel_class parallel_class module~parallel_pipe_class->module~parallel_class module~field_psi_class->module~field_class module~field_psi_class->module~field_src_class module~field_psi_class->module~param module~field_psi_class->module~ufield_class module~field_psi_class->module~system module~field_psi_class->module~grid_class module~field_psi_class->module~parallel_pipe_class module~field_psi_class->module~field_solver_class module~field_solver_class->module~debug_tool module~field_solver_class->mpi module~field_solver_class->module~param module~field_solver_class->module~system module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib var panprogramtest_field_eperp2UsesGraph = svgPanZoom('#programtest_field_eperp2UsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~test_field_eperp~2~~CallsGraph program~test_field_eperp~2 test_field_eperp mpi_init mpi_init program~test_field_eperp~2->mpi_init write_dbg write_dbg program~test_field_eperp~2->write_dbg mpi_finalize mpi_finalize program~test_field_eperp~2->mpi_finalize init_errors init_errors program~test_field_eperp~2->init_errors end_errors end_errors program~test_field_eperp~2->end_errors interface~write_data write_data program~test_field_eperp~2->interface~write_data proc~write_data1d write_data1d interface~write_data->proc~write_data1d proc~write_data2d write_data2d interface~write_data->proc~write_data2d proc~write_array write_array interface~write_data->proc~write_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables b e rho num_modes dim order part_shape nd nvp gc_num dr dxi r uq_re uq_im ue_re ue_im p ierr i mode Variables Type Attributes Name Initial type( field_b ) :: b type( field_e ) :: e type( field_rho ) :: rho integer :: num_modes = 3 integer :: dim = 3 integer :: order = p_fs_2order integer :: part_shape = p_ps_linear integer, dimension(2) :: nd = (/128, 1/) integer, dimension(2) :: nvp = (/1, 1/) integer, dimension(2,2) :: gc_num real :: dr real :: dxi real :: r type( ufield ), dimension(:), pointer :: uq_re => null() type( ufield ), dimension(:), pointer :: uq_im => null() type( ufield ), dimension(:), pointer :: ue_re => null() type( ufield ), dimension(:), pointer :: ue_im => null() real, dimension(:,:), pointer :: p integer :: ierr integer :: i integer :: mode","tags":"","loc":"program/test_field_eperp~2.html"},{"title":"test_field_bperp_iter – QuickPIC wit Azimuzal Decomposition","text":"Uses field_b_class field_class field_src_class system param mpi ufield_class debug_tool program~~test_field_bperp_iter~~UsesGraph program~test_field_bperp_iter test_field_bperp_iter module~debug_tool debug_tool program~test_field_bperp_iter->module~debug_tool mpi mpi program~test_field_bperp_iter->mpi module~field_class field_class program~test_field_bperp_iter->module~field_class module~field_src_class field_src_class program~test_field_bperp_iter->module~field_src_class module~param param program~test_field_bperp_iter->module~param module~ufield_class ufield_class program~test_field_bperp_iter->module~ufield_class module~field_b_class field_b_class program~test_field_bperp_iter->module~field_b_class module~system system program~test_field_bperp_iter->module~system module~field_class->module~param module~field_class->module~ufield_class module~field_class->module~system module~grid_class grid_class module~field_class->module~grid_class module~parallel_pipe_class parallel_pipe_class module~field_class->module~parallel_pipe_class module~field_src_class->module~field_class module~field_src_class->module~param module~field_src_class->module~system module~field_src_class->module~grid_class module~field_src_class->module~parallel_pipe_class module~ufield_class->module~param module~ufield_class->module~system module~ufield_class->module~grid_class module~ufield_class->module~parallel_pipe_class module~field_b_class->module~debug_tool module~field_b_class->module~field_class module~field_b_class->module~field_src_class module~field_b_class->module~param module~field_b_class->module~ufield_class module~field_b_class->module~system module~field_b_class->module~grid_class module~field_b_class->module~parallel_pipe_class module~field_solver_class field_solver_class module~field_b_class->module~field_solver_class module~grid_class->module~system module~grid_class->module~parallel_pipe_class module~parallel_pipe_class->mpi module~parallel_class parallel_class module~parallel_pipe_class->module~parallel_class module~field_solver_class->module~debug_tool module~field_solver_class->mpi module~field_solver_class->module~param module~field_solver_class->module~system module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib var panprogramtest_field_bperp_iterUsesGraph = svgPanZoom('#programtest_field_bperp_iterUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~test_field_bperp_iter~~CallsGraph program~test_field_bperp_iter test_field_bperp_iter mpi_init mpi_init program~test_field_bperp_iter->mpi_init write_dbg write_dbg program~test_field_bperp_iter->write_dbg mpi_finalize mpi_finalize program~test_field_bperp_iter->mpi_finalize init_errors init_errors program~test_field_bperp_iter->init_errors end_errors end_errors program~test_field_bperp_iter->end_errors Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables b jay djdxi num_modes dim part_shape nd nvp gc_num dr dxi r ujay_re ujay_im udjdxi_re udjdxi_im ub_re_new ub_im_new ub_re_old ub_im_old ub_res p ierr i mode iter num_iter res Variables Type Attributes Name Initial type( field_b ) :: b type( field_jay ) :: jay type( field_djdxi ) :: djdxi integer :: num_modes = 2 integer :: dim = 3 integer :: part_shape = p_ps_linear integer, dimension(2) :: nd = (/128, 1/) integer, dimension(2) :: nvp = (/1, 1/) integer, dimension(2,2) :: gc_num real :: dr real :: dxi real :: r type( ufield ), dimension(:), pointer :: ujay_re => null() type( ufield ), dimension(:), pointer :: ujay_im => null() type( ufield ), dimension(:), pointer :: udjdxi_re => null() type( ufield ), dimension(:), pointer :: udjdxi_im => null() type( ufield ), dimension(:), pointer :: ub_re_new => null() type( ufield ), dimension(:), pointer :: ub_im_new => null() type( ufield ), dimension(:), pointer :: ub_re_old => null() type( ufield ), dimension(:), pointer :: ub_im_old => null() type( ufield ) :: ub_res real, dimension(:,:), pointer :: p integer :: ierr integer :: i integer :: mode integer :: iter integer :: num_iter = 10 real, dimension(:,:), pointer :: res => null()","tags":"","loc":"program/test_field_bperp_iter.html"},{"title":"test_field_bperp – QuickPIC wit Azimuzal Decomposition","text":"Uses field_b_class field_class field_src_class system param mpi ufield_class debug_tool program~~test_field_bperp~~UsesGraph program~test_field_bperp test_field_bperp module~debug_tool debug_tool program~test_field_bperp->module~debug_tool mpi mpi program~test_field_bperp->mpi module~field_class field_class program~test_field_bperp->module~field_class module~field_src_class field_src_class program~test_field_bperp->module~field_src_class module~param param program~test_field_bperp->module~param module~ufield_class ufield_class program~test_field_bperp->module~ufield_class module~field_b_class field_b_class program~test_field_bperp->module~field_b_class module~system system program~test_field_bperp->module~system module~field_class->module~param module~field_class->module~ufield_class module~field_class->module~system module~grid_class grid_class module~field_class->module~grid_class module~parallel_pipe_class parallel_pipe_class module~field_class->module~parallel_pipe_class module~field_src_class->module~field_class module~field_src_class->module~param module~field_src_class->module~system module~field_src_class->module~grid_class module~field_src_class->module~parallel_pipe_class module~ufield_class->module~param module~ufield_class->module~system module~ufield_class->module~grid_class module~ufield_class->module~parallel_pipe_class module~field_b_class->module~debug_tool module~field_b_class->module~field_class module~field_b_class->module~field_src_class module~field_b_class->module~param module~field_b_class->module~ufield_class module~field_b_class->module~system module~field_b_class->module~grid_class module~field_b_class->module~parallel_pipe_class module~field_solver_class field_solver_class module~field_b_class->module~field_solver_class module~grid_class->module~system module~grid_class->module~parallel_pipe_class module~parallel_pipe_class->mpi module~parallel_class parallel_class module~parallel_pipe_class->module~parallel_class module~field_solver_class->module~debug_tool module~field_solver_class->mpi module~field_solver_class->module~param module~field_solver_class->module~system module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib var panprogramtest_field_bperpUsesGraph = svgPanZoom('#programtest_field_bperpUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~test_field_bperp~~CallsGraph program~test_field_bperp test_field_bperp mpi_init mpi_init program~test_field_bperp->mpi_init write_dbg write_dbg program~test_field_bperp->write_dbg mpi_finalize mpi_finalize program~test_field_bperp->mpi_finalize init_errors init_errors program~test_field_bperp->init_errors end_errors end_errors program~test_field_bperp->end_errors interface~write_data write_data program~test_field_bperp->interface~write_data proc~write_data1d write_data1d interface~write_data->proc~write_data1d proc~write_data2d write_data2d interface~write_data->proc~write_data2d proc~write_array write_array interface~write_data->proc~write_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables b rho num_modes dim order part_shape nd nvp gc_num dr dxi r uq_re uq_im ub_re ub_im p ierr i mode Variables Type Attributes Name Initial type( field_b ) :: b type( field_rho ) :: rho integer :: num_modes = 3 integer :: dim = 3 integer :: order = p_fs_2order integer :: part_shape = p_ps_linear integer, dimension(2) :: nd = (/128, 1/) integer, dimension(2) :: nvp = (/1, 1/) integer, dimension(2,2) :: gc_num real :: dr real :: dxi real :: r type( ufield ), dimension(:), pointer :: uq_re => null() type( ufield ), dimension(:), pointer :: uq_im => null() type( ufield ), dimension(:), pointer :: ub_re => null() type( ufield ), dimension(:), pointer :: ub_im => null() real, dimension(:,:), pointer :: p integer :: ierr integer :: i integer :: mode","tags":"","loc":"program/test_field_bperp.html"},{"title":"test_ufield – QuickPIC wit Azimuzal Decomposition","text":"Uses ufield_class program~~test_ufield~~UsesGraph program~test_ufield test_ufield module~ufield_class ufield_class program~test_ufield->module~ufield_class module~param param module~ufield_class->module~param module~grid_class grid_class module~ufield_class->module~grid_class module~parallel_pipe_class parallel_pipe_class module~ufield_class->module~parallel_pipe_class module~system system module~ufield_class->module~system module~grid_class->module~parallel_pipe_class module~grid_class->module~system module~parallel_class parallel_class module~parallel_pipe_class->module~parallel_class mpi mpi module~parallel_pipe_class->mpi module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables a1 a2 a3 dim nd nvp gc_num k start finish i Variables Type Attributes Name Initial type( ufield ) :: a1 type( ufield ) :: a2 type( ufield ) :: a3 integer :: dim = 3 integer, dimension(2) :: nd = (/2, 2/) integer, dimension(2) :: nvp = (/1, 1/) integer, dimension(2,2) :: gc_num real :: k = 5.0 real :: start real :: finish integer :: i","tags":"","loc":"program/test_ufield.html"}]}